<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity组件-Transform</title>
      <link href="/2023/05/11/Unity3D/Unity%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6-Transforms/"/>
      <url>/2023/05/11/Unity3D/Unity%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6-Transforms/</url>
      
        <content type="html"><![CDATA[<h1 id="Transform-组件"><a href="#Transform-组件" class="headerlink" title="Transform-组件"></a>Transform-组件</h1><p><strong><code>Transform</code></strong> 用于存储<strong>游戏对象</strong>的位置、旋转、缩放和父级状态，因此非常重要。游戏对象将始终附加 <code>Transform</code> 组件。如果没有变换组件，则无法移除变换或创建游戏对象。</p><h2 id="Transform组件"><a href="#Transform组件" class="headerlink" title="Transform组件"></a><code>Transform</code>组件</h2><p><code>Transform</code> 组件确定对象在场景中的<strong>位置和姿态</strong>。<strong>每个游戏对象都有一个变换</strong>。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-TransformTransform组件视图.png" alt="Transform组件视图"></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Position</strong></td><td style="text-align:left">相对于父级（本地坐标系），在 X、Y 和 Z 坐标中的位置。</td></tr><tr><td style="text-align:center"><strong>Rotation</strong></td><td style="text-align:left">相对于父级，围绕 X、Y 和 Z 轴的旋转，以度为单位。</td></tr><tr><td style="text-align:center"><strong>Scale</strong></td><td style="text-align:left">沿 X、Y 和 Z 轴的变换比例。值“1”是原始大小（导入对象的大小）。选择值旁边的链接图标以切换比例缩放。比例缩放按比例调整刻度值。</td></tr></tbody></table></div><blockquote><p>注意：每个<code>Transform</code>组件面板中的<strong>Position</strong>，指的是相对于父级的位置，一般游戏对象在场景中的位置是世界坐标，因此需要将子级的<strong>Position</strong>以及对应的每一级父级的<strong>Position</strong>相加，才能得到<strong>世界坐标</strong>。而脚本中的<code>Transform</code>对象下的<strong>Position</strong>属性，就是世界坐标。这一点很重要</p><p>为了说明这一点，请看下面例子。</p><p>首先设置父级坐标为 <code>(-2,0,0)</code> ，子级坐标 <code>(0,0,0)</code> ，然后打印出子级 <code>Transform</code> 脚本对象的<strong>Position</strong>属性。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform父级坐标.png" alt="父级坐标"></p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform子级坐标.png" alt="子级坐标"></p><p>将下面测试脚本挂载到子级上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="keyword">this</span>.transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果为：</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform输出的结果.png" alt="输出的结果"></p></blockquote><h2 id="编辑转换"><a href="#编辑转换" class="headerlink" title="编辑转换"></a>编辑转换</h2><p><code>Transform</code> 在 X、Y 和 Z 轴的 3D 空间中或在 X 和 Y 轴的 2D 空间中进行操作。在 Unity 中，这些轴分别由红色、绿色和蓝色表示。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform左手坐标系.png" alt="左手坐标系"></p><p>在场景中，您可以使用移动、旋转和缩放工具修改<code>Transform</code>。这些工具位于 Unity 编辑器的左上角。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-Transform转换-平移.png" alt="转换"></p><h2 id="Parenting——父级"><a href="#Parenting——父级" class="headerlink" title="Parenting——父级"></a>Parenting——父级</h2><p><code>Parenting</code> 是使用 Unity 时要了解的最重要的概念之一。当游戏对象是另一个游戏对象的<strong>父级</strong>，<strong>子游戏对象将完全按照其父游戏对象的方式移动、旋转和缩放</strong>。</p><p>可以把 <code>Parenting</code> 想象成手臂和身体之间的关系：每当你的身体移动时，你的手臂也会随之移动。子对象也可以有自己的子对象，依此类推。所以你的手可以被视为你手臂的“孩子”，然后每只手都有几根手指，等等。任何对象都可以有多个子对象，但只能有一个父对象。这些多层次的父子关系构成了转换<em>层次结构</em>。</p><p>层次结构最顶端的对象（即层次结构中唯一没有父对象的对象）称为<strong>根</strong>。</p><p>可以通过将<strong>层次结构视图中</strong>的任何游戏对象拖动到另一个游戏对象上来创建父级。这将在两个游戏对象之间创建父子关系。</p><h2 id="使用-Transform-的小提示"><a href="#使用-Transform-的小提示" class="headerlink" title="使用 Transform 的小提示"></a>使用 <code>Transform</code> 的小提示</h2><ul><li>在父级转换时，在添加子级之前将父级的位置设置为 <0，0，0> 非常有用。这意味着子项的本地坐标将与全局坐标相同，从而更容易确保子项处于正确的位置。</li><li>如果您正在使用<strong>刚体</strong>，对于物理仿真，请务必阅读<a href="https://docs.unity3d.com/Manual/class-Rigidbody.html">刚体</a>组件参考页面上的 Scale 属性。</li><li>您可以从首选项（<strong>菜单：Unity &gt;首选项</strong>）更改变换轴（和其他 UI 元素）的颜色，然后选择<strong>颜色和键</strong>面板）。</li><li>更改比例会影响子变换的位置。例如，将父项缩放为 （0，0，0） 会将所有子项定位为相对于父项的 （0，0，0）。</li></ul><h1 id="Transform——脚本"><a href="#Transform——脚本" class="headerlink" title="Transform——脚本"></a>Transform——脚本</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>对象的位置、旋转和缩放。场景中的每个对象都有一个变换。 它用于存储和操作对象的位置，旋转和缩放。 每个变换都可以有一个父级，它允许您分层应用位置、旋转和缩放。这是在“层次结构”窗格中看到的层次结构。 它们还支持<strong>枚举器</strong>，因此您可以使用以下方法循环遍历子项：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform transform = gameObject.GetComponent&lt;Transform&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (Transform child <span class="keyword">in</span> transform)</span><br><span class="line">        &#123;</span><br><span class="line">            child.position += Vector3.up * <span class="number">10.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>下面只罗列在游戏开发中，最常用的属性，完整属性列表请参看<a href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity - Scripting API: Transform (unity3d.com)</a>官方文档</p><div class="table-container"><table><thead><tr><th><a href="https://docs.unity3d.com/ScriptReference/Transform-childCount.html">childCount</a></th><th>父级 <code>Transform</code> 有的子级数。（注意：这里是一级子级数）。</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-localPosition.html">localPosition</a></td><td>相对于父级的位置。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-localRotation.html">localRotation</a></td><td>相对于父级的旋转。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-localScale.html">localScale</a></td><td>相对于父级的缩放。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-parent.html">parent</a></td><td>当前 <code>Transform</code> 的父级的 <code>Transform</code> 对象。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-position.html">position</a></td><td>世界坐标空间位置。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform-rotation.html">rotation</a></td><td>一个四元数，用于存储在世界空间中的旋转。</td></tr></tbody></table></div><h2 id="常用公共方法"><a href="#常用公共方法" class="headerlink" title="常用公共方法"></a>常用公共方法</h2><p>下面只罗列在游戏开发中，最常用的公共方法，完整公共方法列表请参看<a href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity - Scripting API: Transform (unity3d.com)</a>官方文档</p><div class="table-container"><table><thead><tr><th><a href="https://docs.unity3d.com/ScriptReference/Transform.DetachChildren.html">DetachChildren</a></th><th>取消所有孩子的父母。如果要在不销毁子层次结构的情况下销毁层次结构的根，则很有用。</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.Find.html">Find</a></td><td><strong>按名称查找</strong>子项并将其返回。注意：只会在一级子级中查找。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.GetChild.html">GetChild</a></td><td>按索引返回转换子项。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.IsChildOf.html">IsChildOf</a></td><td>返回一个布尔值，该值指示转换是否为给定转换的子级。 如果此转换是子转换，则为真，深度子项（子项的子项）或与此转换相同，否则为假。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.Rotate.html">Rotate</a></td><td>使用 Transform.Rotate 以多种方式旋转游戏对象。旋转通常以欧拉角而不是四元数的形式提供。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.RotateAround.html">RotateAround</a></td><td>围绕在世界坐标中通过点的轴按角度旋转变换。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.SetParent.html"><strong>SetParent</strong></a></td><td><strong>设置转换的父级</strong>。</td></tr><tr><td><a href="https://docs.unity3d.com/ScriptReference/Transform.Translate.html">Translate</a></td><td>沿平移方向和距离移动变换。（世界坐标的封装）</td></tr></tbody></table></div><h3 id="Find-方法"><a href="#Find-方法" class="headerlink" title="Find() 方法"></a><code>Find()</code> 方法</h3><p>下面进行测试：</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-TransformFind方法测试-1.png" alt="Find方法测试-1"></p><p>挂载的脚本如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Transform transform = gameObject.GetComponent&lt;Transform&gt;();</span><br><span class="line">        Transform transform1 = transform.Find(<span class="string">&quot;www&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (transform1 == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(transform1.gameObject.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的控制台输出的结果为：</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/Unity组件/组件-TransformFind方法测试-结果.png" alt="Find方法测试-结果"></p><blockquote><p>总结：上面的结果可以看出， <code>Find()</code> 方法，并不能找到二级子级</p></blockquote><h3 id="SetParent（）-方法"><a href="#SetParent（）-方法" class="headerlink" title="SetParent（） 方法"></a><code>SetParent（）</code> 方法</h3><p>声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetParent</span>(<span class="params">Transform parent</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetParent</span>(<span class="params">Transform parent, <span class="built_in">bool</span> worldPositionStays</span>)</span>;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>parent</code> ：要使用的父转换。</li><li><code>worldPositionStays</code><ul><li><code>true</code> ：修改相对于父级的位置、缩放和旋转，<strong>以使对象保持与以前相同的世界空间位置、旋转和缩放</strong>。</li><li><code>false</code> ：设置相对于父级的位置、缩放和旋转，为默认值。（此举可能会改变世界坐标系空间的状态）</li></ul></li></ul><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-12</p></div></div><div class='timeline-item-content'><ol><li>添加了 <code>Find()</code> 方法的测试</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-11</p></div></div><div class='timeline-item-content'><ol><li>创建文档，介绍 Transform 组件的使用</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Unity组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Unity组件 </tag>
            
            <tag> Transform变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/08/Unity3D/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E4%BD%BF%E7%94%A8%E7%93%A6%E7%89%87%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/08/Unity3D/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E4%BD%BF%E7%94%A8%E7%93%A6%E7%89%87%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/08/Unity3D/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/08/Unity3D/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/08/Unity3D/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/05/08/Unity3D/Unity%E5%BC%95%E6%93%8E/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity生命周期</title>
      <link href="/2023/05/03/Unity3D/Unity%E5%BC%95%E6%93%8E/Unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/05/03/Unity3D/Unity%E5%BC%95%E6%93%8E/Unity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Unity引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> Unity引擎 </tag>
            
            <tag> Unity生命周期 </tag>
            
            <tag> 协程 </tag>
            
            <tag> Unity生命周期函数 </tag>
            
            <tag> Unity引擎物理更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏对象的移动以及碰撞基础（2D）</title>
      <link href="/2023/05/02/Unity3D/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E7%A7%BB%E5%8A%A8%E5%8F%8A%E7%A2%B0%E6%92%9E2D/"/>
      <url>/2023/05/02/Unity3D/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E7%A7%BB%E5%8A%A8%E5%8F%8A%E7%A2%B0%E6%92%9E2D/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>此文将主要讲解有关 unity 游戏对象的移动，包含相关的 Unity 设置与 C# 脚本代码。</p></blockquote><h1 id="一、2D-对象移动"><a href="#一、2D-对象移动" class="headerlink" title="一、2D 对象移动"></a>一、2D 对象移动</h1><h2 id="1-1-相关的组件以及内置代码介绍"><a href="#1-1-相关的组件以及内置代码介绍" class="headerlink" title="1.1 相关的组件以及内置代码介绍"></a>1.1 相关的组件以及内置代码介绍</h2><h3 id="1-1-1-Transform-组件（转换）"><a href="#1-1-1-Transform-组件（转换）" class="headerlink" title="1.1.1 Transform 组件（转换）"></a>1.1.1 Transform 组件（转换）</h3><p><strong><code>Transform</code></strong> ：用于存储一个游戏对象的位置、旋转、比例和父级状态。一个 <code>GameObject</code> 将始终附加一个<strong><code>Transform</code> 组件</strong>，不可能删除一个 <code>Transform</code> 或创建一个没有 Transform 的 <code>GameObject</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">name</th><th style="text-align:left">Function</th></tr></thead><tbody><tr><td style="text-align:left">Position</td><td style="text-align:left">在 X、Y 和 Z 坐标中的位置。（此坐标是游戏坐标，且子对象以父对象为基准）</td></tr><tr><td style="text-align:left">Rotation</td><td style="text-align:left">围绕 X、Y 和 Z 轴的旋转，以度为单位</td></tr><tr><td style="text-align:left">Scale</td><td style="text-align:left">沿 X、Y 和 Z 轴的比例。值“1”是原始大小（导入对象的大小）。如果任何刻度值为零，它将变灰并且在启用比例刻度时不会自动调整。</td></tr></tbody></table></div><h3 id="1-1-2-Rigidbody-2D-组件（刚体）"><a href="#1-1-2-Rigidbody-2D-组件（刚体）" class="headerlink" title="1.1.2 Rigidbody 2D 组件（刚体）"></a>1.1.2 <code>Rigidbody 2D</code> 组件（刚体）</h3><p><a href="https://docs.unity3d.com/Manual/class-Rigidbody2D.html">官方手册</a></p><h3 id="1-1-3Time-delteTime-参数"><a href="#1-1-3Time-delteTime-参数" class="headerlink" title="1.1.3Time.delteTime 参数"></a>1.1.3<code>Time.delteTime</code> 参数</h3><p>公共静态浮动<strong>增量时间</strong>。</p><p>描述：从上一帧到当前帧的间隔（以秒为单位）（只读）。</p><p>详细说明：<a href="https://docs.unity3d.com/ScriptReference/Time-deltaTime.html"><code>Time.delteTime</code></a> 。</p><h2 id="1-2-对象移动功能实现"><a href="#1-2-对象移动功能实现" class="headerlink" title="1.2 对象移动功能实现"></a>1.2 对象移动功能实现</h2><h3 id="1-2-1-方法-Ⅰ：直接改变世界坐标"><a href="#1-2-1-方法-Ⅰ：直接改变世界坐标" class="headerlink" title="1.2.1 方法 Ⅰ：直接改变世界坐标"></a>1.2.1 方法 Ⅰ：直接改变世界坐标</h3><p>游戏对象在场景中的世界坐标，是 <code>Transform</code> 组件中的 <code>Position</code> 属性来记录的。通过改变<code>Position</code>属性的值，<strong>强制</strong>改变对象的世界坐标，以达到游戏对象移动的目的。在 Unity 中，对象的 Transform 组件的 Position 属性在 c# 脚本中是一个<font color='red'>三元数</font>。</p><p>优点：</p><ul><li>使用该方法简单</li></ul><p>缺点：</p><ul><li>对象移动不平滑（实际 Unity 对移动进行平滑调整）</li><li>对于有碰撞体积的对象，如果移动速度过快，会穿过碰撞体积</li><li>每执行一次代码，就会改变一次坐标，对于 <code>Updata()</code> 函数来说，帧数的改变会影响移动速度；对 <code>FixedUpdate()</code> 函数没有影响。</li></ul><p>具体的代码如下：</p><ol><li><p>类型 Ⅰ ：</p><p><code>Position</code> 属性可以通过以下方式进行设置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.Position = newPosition</span><br></pre></td></tr></table></figure></li><li><p>类型 Ⅱ：</p><p>除了直接赋值外，<code>Position</code> 属性还可以进行增量设置，即将当前位置增加一个向量值，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 distance = <span class="keyword">new</span> Vertor3(<span class="number">0.01f</span>,<span class="number">0f</span>,<span class="number">0f</span>);<span class="comment">//创建移动向量的三元数</span></span><br><span class="line">transform.Position += distance;<span class="comment">//当前坐标加上移动移动向量，得到移动后的坐标</span></span><br></pre></td></tr></table></figure></li><li><p>类型 Ⅲ：</p><p>官方推荐使用下面的函数用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 distance = <span class="keyword">new</span> Vertor3(<span class="number">0.01f</span>,<span class="number">0f</span>,<span class="number">0f</span>);<span class="comment">//创建移动向量的三元数</span></span><br><span class="line">transform.Translate(distance);<span class="comment">//这个函数其实是对类型Ⅱ代码的封装</span></span><br></pre></td></tr></table></figure></li><li><p>类型 Ⅳ：移动速度单位时间化，与帧数无关</p><p>其中，<code>velocity</code> 是一个 Vector3 类型的速度向量，<code>Time.deltaTime</code> 表示上一帧的时间间隔，这里使用它是为了使运动平滑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.position += velocity * Time.deltaTime;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，<code>Position</code> 属性所表示的是游戏对象在世界坐标系中的位置，而不是相对于它的父级对象或本地坐标系的位置。因此，在进行赋值或增量设置时，应该考虑该游戏对象的当前所处位置，而不是相对位置。</p><p>同时，需要注意的是，在游戏对象使用物理引擎进行运动时，应该使用 <code>Rigidbody</code> 组件来控制它的运动，而不是直接修改 <code>Position</code> 属性。</p><h3 id="1-2-2-固定速度到达某位置"><a href="#1-2-2-固定速度到达某位置" class="headerlink" title="1.2.2 固定速度到达某位置"></a>1.2.2 固定速度到达某位置</h3><p><code>Vector3.MoveTowards()</code> 是 Unity 引擎中一个用于控制向量移动的函数，该函数会返回从一个位置开始朝着目标位置移动一定距离的向量。这个函数通常用于实现许多游戏中的效果，如角色寻路、平滑移动、相机跟随等。函数的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">MoveTowards</span>(<span class="params">Vector3 current, Vector3 target, <span class="built_in">float</span> maxDistanceDelta</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>current</code> 表示当前位置，</li><li><code>target</code> 表示目标位置，</li><li><code>maxDistanceDelta</code> 表示最大的距离变化量。</li></ul><p>函数会沿着从 <code>current</code> 到 <code>target</code> 的方向移动一个距离，该距离不会超过 <code>maxDistanceDelta</code>。</p><p>因此在 Unity 中，可以设置好目标位置以及移动速度（移动距离单位时间化），并且不<strong>断运行该函数同时，不断刷新对象的当前位置为函数的初位置</strong>。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.Position = Vertor3.MoveTowards(transform.Position,targetPosition,speed*Time.delteTime);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>初位置：因为对象不断进行移动，所以初位置就设置当前位置</li><li>末位置：要移动的目标位置</li><li>移动距离：速度 X 时间 = 每次移动的距离</li></ul><blockquote><p>上述函数为了能重复执行，直到对象移动到目标位置，需要把该函数放在 <code>Updata()</code> 函数或 <code>FixedUpdata()</code> 中</p></blockquote><p>例如下面的具体代码实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMovement</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">5f</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector3 targetPos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            targetPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">            targetPos.z = transform.position.z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transform.position = Vector3.MoveTowards(transform.position, targetPos, moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们用 <code>Input.GetMouseButton(0)</code> 来检测玩家是否点击了鼠标左键。如果是，则将 <code>targetPos</code> 的位置设置为鼠标点击位置。然后，我们将对象的当前位置和目标位置作为参数来调用 <code>Vector3.MoveTowards()</code> 函数来实现平滑移动。</p><h3 id="1-2-3-平滑移动"><a href="#1-2-3-平滑移动" class="headerlink" title="1.2.3 平滑移动"></a>1.2.3 平滑移动</h3><p><code>Vector3.SmoothDamp()</code> 是 Unity 引擎中用于平滑移动物体的函数，与 <code>Vector3.MoveTowards()</code> 不同，它可以模拟物理动力学，使得移动更加平滑自然，同时可以避免突变和振荡等不良效果。该函数通常用于实现角色控制、相机跟随、特效等等。</p><p><code>Vector3.SmoothDamp()</code> 函数的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">SmoothDamp</span>(<span class="params">Vector3 current, Vector3 target, <span class="keyword">ref</span> Vector3 currentVelocity, <span class="built_in">float</span> smoothTime, <span class="built_in">float</span> maxSpeed = Mathf.Infinity, <span class="built_in">float</span> deltaTime = Time.deltaTime</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>current</code> 表示当前位置；</li><li><code>target</code> 表示目标位置；</li><li><code>currentVelocity</code> 是一个引用参数，表示当前速度；</li><li><code>smoothTime</code> 表示平滑时间。该值越小，平滑速度越快；</li><li><code>maxSpeed</code> 表示最大速度限制；</li><li><code>deltaTime</code> 是可选参数，表示时间增量；</li></ul><p>在使用 <code>Vector3.SmoothDamp()</code> 函数时，需要特别注意以下几点：</p><ul><li>该函数可以模拟物理动力学，提供了平滑运动的效果，但没有进行碰撞检测。如果需要避免障碍物，应该使用其他算法，例如 A* 算法等。</li><li><code>smoothTime</code> 的值越小，平滑速度越快；反之，平滑速度越慢，过渡时间也会越长。</li><li><code>maxSpeed</code> 设置最大速度可以有效地避免移动速度过快，但过快的移动速度也可能会导致震荡和不稳定的效果。</li><li><code>currentVelocity</code> 参数是一个引用参数，需要在每一帧中传入函数进行更新。</li></ul><p>下面是一个简单的示例，演示如何使用 <code>Vector3.SmoothDamp()</code> 函数实现相机的平滑跟随：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraFollow</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> smoothTime = <span class="number">0.3f</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector3 currentVelocity = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> targetPos = target.position;</span><br><span class="line">            targetPos.z = transform.position.z;</span><br><span class="line">            transform.position = Vector3.SmoothDamp(transform.position, targetPos, <span class="keyword">ref</span> currentVelocity, smoothTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将摄像机的位置设置为玩家的位置。我们将 <code>targetPos</code> 的位置设置为玩家的位置，然后使用 <code>Vector3.SmoothDamp()</code> 函数来实现平滑跟随。我们使用 <code>LateUpdate()</code> 来确保摄像机移动在对象移动后更新。</p><h3 id="1-2-4-固定时间到达某位置"><a href="#1-2-4-固定时间到达某位置" class="headerlink" title="1.2.4 固定时间到达某位置"></a>1.2.4 固定时间到达某位置</h3><p><code>Vector3.Lerp()</code> 函数是 Unity 引擎中的一个线性插值函数。它可以在两个 <code>Vector3</code> 之间进行插值，并返回一个介于它们之间的值。函数定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">Lerp</span>(<span class="params">Vector3 a, Vector3 b, <span class="built_in">float</span> t</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>a</code> 和 <code>b</code> 是两个 <code>Vector3</code>，<code>t</code> 是表示插值系数的 <code>float</code> 值。<code>t</code> 的取值范围是 0 到 1，插值的结果为 <code>a</code> 和 <code>b</code> 的线性组合。当 <code>t</code> 为 0 时，结果为 <code>a</code>；当 <code>t</code> 为 1 时，结果为 <code>b</code>；当 <code>t</code> 为 0.5 时，结果为 <code>a</code> 和 <code>b</code> 的平均值。</p><p>例如下面简单实现了游戏中的以固定时间进行移动：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TMP</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 _start;</span><br><span class="line">    <span class="keyword">public</span> Vector3 _end;</span><br><span class="line">    <span class="keyword">public</span> Transform _cube;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _time = <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _timer = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 valueToLerp;</span><br><span class="line">        _timer += Time.deltaTime;</span><br><span class="line">        <span class="keyword">if</span>(_timer &lt; _time)</span><br><span class="line">        &#123;</span><br><span class="line">            valueToLerp = Vector3.Lerp(_start, _end, _timer / _time);</span><br><span class="line">            _cube.position = valueToLerp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _timer = <span class="number">0.0f</span>;</span><br><span class="line">            valueToLerp = _start;</span><br><span class="line">            _start = _end;</span><br><span class="line">            _end = valueToLerp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Vector3.Lerp()</code> 函数在游戏开发中非常实用，常用于实现平滑移动、颜色渐变、相机跟随等效果。</p><h3 id="1-2-5-增加力迫使对象移动"><a href="#1-2-5-增加力迫使对象移动" class="headerlink" title="1.2.5 增加力迫使对象移动"></a>1.2.5 增加力迫使对象移动</h3><p>前三种移动方式，都是直接改变对象的坐标来进行移动。但是在 unity 引擎下，可能会出现以下情况：移动速度过快，穿过碰撞体积；刚体的移动没有物理规则（如：有重力的情况）；对于需要进行移动碰撞检测时，会出现先移动到碰撞体积内部，然后被碰撞体积弹开，如次反复，就会导致一直碰撞的对象产生剧烈抖动。</p><p>因此，为了使碰撞合乎真实物理，那么使用刚体的移动属性。使用刚体，必须先获取到游戏对象的刚体组件。</p><p>可以用于给刚体物体施加一个力或者瞬间的加速度。如果您想要给人物模型施加一个力，可以将 <code>Rigidbody</code> 组件添加到人物模型上，并使用 <code>AddForce()</code> 函数进行使用。下面是一个简单的示例，演示如何使用 <code>AddForce()</code> 函数使人物模型跳跃：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce = <span class="number">10f</span>;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody rb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Jump&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先在 <code>Start()</code> 函数中获取 <code>Rigidbody</code> 组件，并将其保存在 <code>rb</code> 变量中。在 <code>Update()</code> 函数中检测玩家是否按下了跳跃键（默认为空格键），如果按下了，我们就使用 <code>AddForce()</code> 函数给人物模型施加一个向上的力，使其跳跃。我们使用 <code>ForceMode.Impulse</code> 参数来表示施加瞬时的力。</p><p>需要注意的是，当我们使用 <code>Rigidbody</code> 组件时，需要注意以下几点：</p><ul><li><code>Rigidbody</code> 组件只能添加到物体上，而不能添加到空的游戏对象上。</li><li>需要在物体的初始位置上添加一个刚体物理效果。</li><li>由于是物理效果，所以需要在 <code>FixedUpdate()</code> 中调用 <code>AddForce()</code> 函数；而不是在 <code>Update()</code> 中调用。具体原因可以参考<a href="https://blog.yuilexi.cn/2023/05/03/Unity3D/Unity引擎/Unity生命周期/">Unity 生命周期 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>这篇文章</li></ul><h3 id="1-2-6-改变刚体的速度向量"><a href="#1-2-6-改变刚体的速度向量" class="headerlink" title="1.2.6 改变刚体的速度向量"></a>1.2.6 改变刚体的速度向量</h3><p>游戏对象中刚体组件的速度属性，在 C# 脚本中，用一组三元数进行表示。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Rigidbody _rb;<span class="comment">//存放刚体组件</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 _direction;<span class="comment">//方向</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> _speed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb = GetComponent&lt;Rigidbody&gt;();<span class="comment">//获取刚体组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb.velocity = _direction*_speed;<span class="comment">//改变刚体的速度向量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-7-改变刚体的位置坐标"><a href="#1-2-7-改变刚体的位置坐标" class="headerlink" title="1.2.7 改变刚体的位置坐标"></a>1.2.7 改变刚体的位置坐标</h3><p>刚体有三种状态：<strong><code>Dynamic</code></strong>、 <strong><code>Kinematic</code></strong>、<strong><code>Static</code></strong>，（动态、运动学、静态）。当刚体为： <strong><code>Kinematic</code></strong> 时，刚体不受重力等因素影响，也就没有办法使用<strong>增加力或速度</strong>来使对象移动。</p><p><code>Kinematic</code> 刚体设计为<strong>在模拟下移动</strong>，但只能在非常明确的用户控制下移动。<code>Dynamic</code> 受重力和力的影响，而 <code>Kinematic</code> 则不受。因此， <code>Kinematic</code> 比 <code>Dynamic</code> 访问计算的速度更快，对系统资源的需求也更低。 <code>Kinematic</code> 旨在通过<a href="http://docs.unity3d.com/ScriptReference/Rigidbody2D.MovePosition.html">Rigidbody2D.MovePosition</a>或<a href="http://docs.unity3d.com/ScriptReference/Rigidbody2D.MoveRotation.html">Rigidbody2D.MoveRotation</a>明确重新定位。使用物理查询来检测碰撞，并使用脚本来决定 <code>Rigidbody 2D</code> 应该移动到哪里以及如何移动。</p><p>刚体中，也内置了 <code>Position</code> 属性，并且使用 <code>Rigidbody.MovePosition()</code> 方法来改变该属性。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Rigidbody _rb;<span class="comment">//获取刚体组件</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 _distance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _rb.MovePosition(transform.position+_distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法的使用根 Transform 相似，不过因为是刚体的属性，所以碰撞的更加自然、合乎物理。</li></ul><h1 id="二、2D-碰撞"><a href="#二、2D-碰撞" class="headerlink" title="二、2D 碰撞"></a>二、2D 碰撞</h1><h2 id="2-1-移动并碰撞的过程"><a href="#2-1-移动并碰撞的过程" class="headerlink" title="2.1 移动并碰撞的过程"></a>2.1 移动并碰撞的过程</h2><p>首先，两个存在两个对象 <script type="math/tex">A,B</script> ，它们之间存在间距， <script type="math/tex">A</script> 对象移动且 <script type="math/tex">B</script> 对象不移动，二者都是刚体和碰撞体。游戏每帧或一定时间，运行游戏脚本中的移动函数，下列按每帧计算处理。那么当前帧， <script type="math/tex">A</script> 对象进行位置移动计算；下一帧 <script type="math/tex">A</script> 对象才会移动到对应位置，并且计算下一帧的位置，与此同时进行碰撞检测（只是进行碰撞检测计算）；再下一帧 <script type="math/tex">A</script> 发生碰撞行为（例如弹开等）。</p><p>那么上述可能存在几种情况：</p><ol><li>当 <script type="math/tex">A,B</script> 的碰撞体积足够大， 且移动速度适中，那么 <script type="math/tex">A</script> 与 <script type="math/tex">B</script> 的碰撞体积会重叠极小一部分再弹开，发生抖动（与 Transform 不同，因为是刚体，所以 Unity 内部优化移动，基本感受不到抖动，<strong>存在抖动但是可以忽略</strong>）</li><li>当 <script type="math/tex">A</script> 的碰撞体积很小， <script type="math/tex">B</script> 的碰撞体积很大，移动速度较快时， <script type="math/tex">A</script> 移动到 <script type="math/tex">B</script> 的内部，并不断发生碰撞，而 <script type="math/tex">A</script> 无法弹出 <script type="math/tex">B</script> 的体内（这里有个碰撞之后弹开方向的判定，如果 <script type="math/tex">A</script> 在 <script type="math/tex">B</script> 的内部，就可以认为 <script type="math/tex">A</script> 四面八方都受到力，但是相互抵消，因此 <script type="math/tex">A</script> 无法从 <script type="math/tex">B</script> 内部弹出）</li><li>当 <script type="math/tex">A,B</script> 的碰撞体积很小，且移动速度很快时，可能会出现<strong>移动一次</strong>的距离大于 $B$ 的宽度，就会穿过 <script type="math/tex">B</script> 而不发生碰撞，这与物理相悖（不存在穿墙术吧）</li></ol><h2 id="2-2-碰撞优化方案"><a href="#2-2-碰撞优化方案" class="headerlink" title="2.2 碰撞优化方案"></a>2.2 碰撞优化方案</h2><p>为了解决碰撞过程中的问题，使用以下方法：</p><ul><li><p>刚体组件的属性：<code>Collision Detection</code>（碰撞检测）</p><ul><li><code>Discrete</code>（离散的）：当您将 <strong><code>Collision Detection</code></strong> 设置为 <strong><code>Discrete</code></strong> 时，具有 <code>Rigidbody 2D</code> 和 <code>Collider 2D</code> 的游戏对象可以在物理更新期间<strong>相互重叠或穿过</strong>，前提是它们移动得足够快。碰撞接触仅在新位置生成。</li><li><p><code>Continuous</code>（连续的）：当<strong><code>Collision Detection</code></strong>设置为<strong><code>Continuous</code></strong>时，具有 <code>Rigidbody 2D</code> 和 <code>Collider 2D</code> 的 <code>GameObjects</code> 在更新期间不会相互通过。相反，Unity 计算任何 Collider 2D 的第一个撞击点，并将 <code>GameObject</code> 移动到那里。</p><blockquote><p>请注意，这比<strong>Discrete</strong>需要更多的 CPU 时间。</p></blockquote></li></ul></li><li><p>刚体组件的属性：<code>Interpolate</code>（插值）</p><ul><li><code>None</code>：不应用运动平滑。</li><li><code>Interpolate</code>（插值）：根据游戏对象在前一帧中的位置对运动进行平滑处理。</li><li><code>Extrapolate</code>（外推）：根据对下一帧中其位置的估计来平滑运动。</li></ul></li></ul><p>在不考虑 CPU 速度的情况下：首选：Continuous 和 Extrapolate。但是默认情况基本适用很多场景。</p>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 经典功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 经典功能实现 </tag>
            
            <tag> 2D游戏对象移动 </tag>
            
            <tag> 2D碰撞 </tag>
            
            <tag> 2D刚体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A星寻路算法</title>
      <link href="/2023/05/02/Unity3D/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Astar%E5%AF%BB%E8%B7%AF/"/>
      <url>/2023/05/02/Unity3D/%E7%BB%8F%E5%85%B8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/Astar%E5%AF%BB%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 经典功能实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 经典功能实现 </tag>
            
            <tag> A星寻路算法 </tag>
            
            <tag> 最短路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity之UGUI框架</title>
      <link href="/2023/05/02/Unity3D/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/UGUI%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/05/02/Unity3D/%E5%8A%9F%E8%83%BD%E6%A1%86%E6%9E%B6/UGUI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>UI</code>是一个游戏必不可少的一部分。对于一个游戏系统而言，它的<code>UI</code>也是多种多样的。经常地，个悲剧不同的需求，当前场景中的<code>UI</code>也会随之切换。因此，为了更方便的管理这些<code>UI</code>的状态和行为，开发一个基于<code>UGUI</code>系统的<strong><code>UI</code>管理框架</strong>。</p><h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><ol><li>进入游戏时，首先会加载<strong>主 UI </strong>，<strong>主 UI </strong>随着游戏的进入和退出而加载和销毁。</li><li>通过一些按钮，我们可以打开其他的 UI 界面，同时主 UI 不会消失</li><li>当前场景可以同时存在多级 UI ，只有处于顶级的 UI 才能被选中并进行操作</li><li>除了主 UI 外的其他 UI 均可以在游戏场景未关闭下，手动关闭</li></ol><h1 id="二、框架设计"><a href="#二、框架设计" class="headerlink" title="二、框架设计"></a>二、框架设计</h1><p><img src="http://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/UIFramework.svg" alt="UIFramework"></p><h1 id="三、功能实现"><a href="#三、功能实现" class="headerlink" title="三、功能实现"></a>三、功能实现</h1><h2 id="3-1-UIPanel"><a href="#3-1-UIPanel" class="headerlink" title="3.1 UIPanel"></a>3.1 <code>UIPanel</code></h2><p>这一部分是用于描述 UI 面板属性的一些脚本。</p><h3 id="3-1-1-UIPanelType脚本"><a href="#3-1-1-UIPanelType脚本" class="headerlink" title="3.1.1 UIPanelType脚本"></a>3.1.1 <code>UIPanelType</code>脚本</h3><p>这是一个枚举类，用于描述所有<code>UIPanel</code>的类型（以<code>UIPanel</code>的名字作为它的类型），下面只写了两个例子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UIPanelType</span><br><span class="line">&#123;</span><br><span class="line">    MainMenuUIPanel,</span><br><span class="line">    SettingUIPanel,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-UIPanelInfo脚本"><a href="#3-1-2-UIPanelInfo脚本" class="headerlink" title="3.1.2 UIPanelInfo脚本"></a>3.1.2 <code>UIPanelInfo</code>脚本</h3><p>该脚本下，只有一个类，用于描述<code>UIPanel</code>的类型以及对应模板文件的路径，并且使用属性器进行封装。将该类标记为<strong>可序列化类</strong>，以方便其他解析<code>Json</code>文件方法能够使用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPanelInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> UIPanelType _type;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _path;       <span class="comment">//注意，脚本使用Rescources.load()动态加载，这里的文件路径不需要后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>()</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>(<span class="params">UIPanelType type, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _type = type;</span><br><span class="line">        _path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UIPanelType Type</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _type; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _type = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Path</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _path; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _path = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-BaseUIPanel脚本"><a href="#3-1-3-BaseUIPanel脚本" class="headerlink" title="3.1.3 BaseUIPanel脚本"></a>3.1.3 <code>BaseUIPanel</code>脚本</h3><p><del>由于<code>BaseUIPanel</code>脚本需要挂载到所有面板对象上，因此需要继承<code>MonoBehaviour</code> 。</del> <code>BasePanel</code>里的方法用来描述所有面板共同的一些基本行为，面板的四个状态：进入场景<code>OnEnter</code>、暂停<code>OnPause</code>、继续<code>OnResume</code>（解除暂停）、退出场景<code>OnExit</code>，也是属于这个类的四个方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseUIPanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Manager"><a href="#3-2-Manager" class="headerlink" title="3.2 Manager"></a>3.2 <code>Manager</code></h2><p><code>UIManager</code>类的该 UI 框架的核心，它负责的工作如下：</p><ol><li>自动更新<code>Json</code>文件中记载<code>UIPanel</code>的<code>UIPanelType</code>与路径</li><li>获取所有的<code>UIPanel</code>信息，并将数据加载到脚本中</li><li>使用字典储存所有<code>UIPanel</code>的游戏对象信息</li><li>使用栈储存场景中已加载的<code>UIPanel</code></li></ol><h3 id="3-2-1-单例模式"><a href="#3-2-1-单例模式" class="headerlink" title="3.2.1 单例模式"></a>3.2.1 单例模式</h3><p>把<code>UIManager</code>做成单例模式，使其在游戏中，只有一个<code>UIManager</code>类去管理 UI 。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UIManager s_instance;</span><br><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_instance == <span class="literal">null</span>)</span><br><span class="line">            s_instance = <span class="keyword">new</span> UIManager();</span><br><span class="line">        <span class="keyword">return</span> s_instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-初始化并自动更新Json信息"><a href="#3-2-2-初始化并自动更新Json信息" class="headerlink" title="3.2.2 初始化并自动更新Json信息"></a>3.2.2 初始化并自动更新<code>Json</code>信息</h3><p>这里使用<code>Litjson</code>库来解析<code>Json</code>文件，把<code>Litjson.dll</code>文件添加到对应路径下，并且在代码编辑器中添加对应的引用。脚本中引入命名空间，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br></pre></td></tr></table></figure><p>配置<code>UIpanel</code>预制件文件夹的路径以及<code>Json</code>文件路径，如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放 UIPanel 预制件的文件夹路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _basePahtUIPanelPrefabFolder = Application.dataPath + <span class="string">@&quot;\Resources\UIPanelPrefab\&quot;</span>;</span><br><span class="line"><span class="comment">//存放UIPanel信息的Json文件的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFolderPath = Application.dataPath + <span class="string">@&quot;\Json\UIJson&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFileName = <span class="string">&quot;UIPanelInfo.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>并且创建一个列表，用来获取所有的<code>UIPanelInfo</code>数据，其中也包括未加载到场景中的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;UIPanelInfo&gt; _uIPanelInfos;<span class="comment">//该列表是存放所有的UIPanelInfo信息，包括未加载到游戏场景中的</span></span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>Json</code>路径和数据，并且将数据写入<code>Json</code>文件，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WriteToJsonFile</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName, T t</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> json = JsonMapper.ToJson(t);</span><br><span class="line">    <span class="comment">//如果文件夹不存在，就创建文件夹</span></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">        Directory.CreateDirectory(folderPath);</span><br><span class="line">    <span class="comment">//如果文件不存在，就创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">        File.Create(folderPath + fileName).Dispose();</span><br><span class="line">    <span class="comment">//将数据写入到文件中</span></span><br><span class="line">    File.WriteAllText(folderPath + fileName, json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：传入<code>Json</code>路径，将对应路径下的<code>Json</code>文件中的数据读取到内存（脚本）中，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ReadFromJsonFIle</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">        Directory.CreateDirectory(folderPath);</span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">        File.WriteAllText(folderPath + fileName, <span class="string">&quot;[]&quot;</span>);</span><br><span class="line">    List&lt;T&gt; t = JsonMapper.ToObject&lt;List&lt;T&gt;&gt;(File.ReadAllText(folderPath + fileName));</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个方法：自动更新 <code>Json</code>文件，并获取全部的模板信息，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUIPanelInfo</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先获取当前Json文件中的UIPanelInfo数据</span></span><br><span class="line">    _uIPanelInfos = ReadFromJsonFIle&lt;UIPanelInfo&gt;(_jsonFolderPath, _jsonFileName);</span><br><span class="line">    <span class="comment">//创建UIPanel的文件夹对象</span></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(_basePahtUIPanelPrefabFolder))</span><br><span class="line">        Directory.CreateDirectory(_basePahtUIPanelPrefabFolder);</span><br><span class="line">    DirectoryInfo directoryInfo = <span class="keyword">new</span> DirectoryInfo(_basePahtUIPanelPrefabFolder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历文件夹下的每一个prefab文件。</span></span><br><span class="line">    <span class="comment">//如果当前UIPanelInfo列表中有对应类型的模板信息，就更新路径；没有，就添加对应信息到UIPanelInfo列表</span></span><br><span class="line">    <span class="keyword">foreach</span> (FileInfo fileInfo <span class="keyword">in</span> directoryInfo.GetFiles(<span class="string">&quot;*prefab&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将对应UIPanel模板的名字转换为UIPanel类型</span></span><br><span class="line">        UIPanelType type = (UIPanelType)Enum.Parse(<span class="keyword">typeof</span>(UIPanelType), fileInfo.Name.Replace(<span class="string">&quot;.prefab&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">@&quot;UIPanelPrefab\&quot;</span> + Convert.ToString(type); <span class="comment">//基址+对应模板文件名，组成完整地址（不要后缀）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试在列表中寻找UIpanelInfo对象，如果有，则返回对应的对象；如果没有，则返回null</span></span><br><span class="line">        UIPanelInfo uIPanelInfo = _uIPanelInfos.TrySearchUIPanel(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uIPanelInfo == <span class="literal">null</span>)    <span class="comment">//UIPanel不在该List中</span></span><br><span class="line">        &#123;</span><br><span class="line">            uIPanelInfo = <span class="keyword">new</span> UIPanelInfo(type, path);</span><br><span class="line">            _uIPanelInfos.Add(uIPanelInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//UIPanel在该List中,更新path值</span></span><br><span class="line">        &#123;</span><br><span class="line">            uIPanelInfo.Path = path;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteToJsonFile&lt;List&lt;UIPanelInfo&gt;&gt;(_jsonFolderPath, _jsonFileName, _uIPanelInfos); <span class="comment">//将更新后的模板信息写入Json文件中去</span></span><br><span class="line">    AssetDatabase.Refresh(); <span class="comment">//刷新资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在<code>UIManager</code>的构造方法中调用<code>InitUIPanelInfo()</code>方法，以便于在该管理类创建时，就进行<code>Json</code>文件的更新。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitUIPanelInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-实例化游戏UIPanel对象"><a href="#3-2-3-实例化游戏UIPanel对象" class="headerlink" title="3.2.3 实例化游戏UIPanel对象"></a>3.2.3 实例化游戏<code>UIPanel</code>对象</h3><p>首先，先获取当前场景的<code>Canvas</code>的 <code>Transform</code>组件，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Transform _canvasTransform;<span class="comment">//存放当前场景中的Canvas对象的Transform属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Transform</span></span><br><span class="line"><span class="keyword">public</span> Transform CanvasTransform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_canvasTransform == <span class="literal">null</span>)</span><br><span class="line">            _canvasTransform = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">        <span class="keyword">return</span> _canvasTransform;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; _canvasTransform = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述存在一个问题，使用<code>GameObject.Find(&quot;Canvas&quot;)</code>方法，速度较慢，会占用更多的时间。改进方法中包含<code>set&#123;&#125;</code>部分，后续会讲解原因。</p><p>构造一个方法：传入<code>UIPanel</code>的类型，就能返回对应的<code>Panel</code>游戏对象，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BaseUIPanel <span class="title">GetUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_uIPanelInfos == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> path = _uIPanelInfos.TrySearchUIPanel(uIPanelType).Path;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Resources.Load(path) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">    GameObject insUIPanel = GameObject.Instantiate(Resources.Load(path)) <span class="keyword">as</span> GameObject; <span class="comment">//创建游戏实例对象</span></span><br><span class="line">    insUIPanel.transform.SetParent(CanvasTransform, <span class="literal">false</span>); <span class="comment">//设置父对象</span></span><br><span class="line">    <span class="keyword">return</span> insUIPanel.GetComponent&lt;BaseUIPanel&gt;(); <span class="comment">//返回BaseUIPanel脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-保存当前场景中的-UIPanel-对象"><a href="#3-2-4-保存当前场景中的-UIPanel-对象" class="headerlink" title="3.2.4 保存当前场景中的 UIPanel 对象"></a>3.2.4 保存当前场景中的 UIPanel 对象</h3><p>一般情况下，不同的<code>UI</code>是先打开的后关闭，后打开的先关闭，这符合<strong>栈</strong>的性质。因此使用栈来存放当前的已打开的<code>UIPanel</code>对象。</p><p>首先，创建一个栈的字段，用于存放已打开的<code>UIPanel</code>对象，如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;BaseUIPanel&gt; _currentUIPanels;<span class="comment">//存放当前场景中已加载的UIPanel对象</span></span><br></pre></td></tr></table></figure><p>入栈算法：构造一个方法，将对应的<code>UIPanel</code>压入栈中，并调用<code>OnEnter</code>方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果当前栈为空</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">        _currentUIPanels = <span class="keyword">new</span> Stack&lt;BaseUIPanel&gt;();</span><br><span class="line">    <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel暂停</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BaseUIPanel topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">        topUIPanel.OnPause();</span><br><span class="line">    &#125;</span><br><span class="line">    BaseUIPanel newUIPanel = GetUIPanel(uIPanelType);</span><br><span class="line">    _currentUIPanels.Push(newUIPanel);</span><br><span class="line">    newUIPanel.OnEnter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈算法：构造一个方法，输入顶级<code>UIPanel</code>的类型，就能弹出对应的<code>UIPanel</code>，并调用<code>OnExit</code>方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PopUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果当前栈顶的UIPanel不是要弹出的UIPanel，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Peek().gameObject.name != Convert.ToString(uIPanelType))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果当前栈为空，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果当前栈中没有UIPanel，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出栈顶的UIPanel，并调用OnExit方法</span></span><br><span class="line">    BaseUIPanel topUIPanel = _currentUIPanels.Pop();</span><br><span class="line">    topUIPanel.OnEixt();</span><br><span class="line">    <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel恢复</span></span><br><span class="line">    <span class="keyword">if</span> (_currentUIPanels.Count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">    topUIPanel.OnResume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-初始化并删除场景已存在的UIPanel"><a href="#3-2-5-初始化并删除场景已存在的UIPanel" class="headerlink" title="3.2.5 初始化并删除场景已存在的UIPanel"></a>3.2.5 初始化并删除场景已存在的<code>UIPanel</code></h3><p>如果场景中残留有旧的<code>UIPanel</code>，那么就先删除当前场景中所有的<code>UIPanel</code>，然后再加载<code>UIManager</code>，以便于向场景中添加新的<code>UI</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckUIPanelWhenGameBegin</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;CanvasTransform.childCount&gt; i;)</span><br><span class="line">    &#123;</span><br><span class="line">        GameObject.DestroyImmediate(CanvasTransform.GetChild(i).gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：上述方法中，for 循环并没有将循环因子<code>i</code>进行自增处理，这是由于<code>CanvasTransform.childCount</code>是在动态变化的，因此我们判断的条件是<code>CanvasTransform.childCount&lt;=0</code>，终止循环。</p></blockquote><p>并在构造方法中添加这个方法，以便于在游戏运行开始就执行该方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitUIPanelInfo(); <span class="comment">//初始化UIPanelInfo</span></span><br><span class="line">    CheckUIPanelWhenGameBegin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-UIManagerLoader脚本"><a href="#3-3-UIManagerLoader脚本" class="headerlink" title="3.3 UIManagerLoader脚本"></a>3.3 <code>UIManagerLoader</code>脚本</h2><p>这个类负责在游戏开始的时候加载所有需要的游戏配置，在该 UI 框架里，<code>UIManagerLoader</code>负责在游戏刚开始运行时，提供给<code>Manager</code>类中的<code>Canvas</code>信息，并加载主菜单面板<code>MainMenuPanel</code>。由于这个类需要挂在场景中的物体上，所以需要继承自<code>MonoBehaviour</code>。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先把当前场景中的Canvas对象的Transform属性赋值给UIManager的CanvasTransform属性</span></span><br><span class="line"><span class="comment">//游戏一开始就加载MainMenuUIPanel</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    UIManager.Instance.CanvasTransform = <span class="keyword">this</span>.transform;</span><br><span class="line">    UIManager.Instance.PushUIPanel(UIPanelType.MainMenuUIPanel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="#3-2-3-实例化游戏UIPanel对象">3.2.3 实例化游戏<code>UIPanel</code>对象</a>中，我们提到了使用<code>GameObject.Find(&quot;Canvas&quot;)</code>方法寻找到当前的 UI 画布，但是<code>GameObject.Find(&quot;&quot;)</code>的性能较低，可能会占用较长的时间。因此，改进方法中包含<code>set&#123;&#125;</code>部分，那么可以在<code>UIManagerLoader</code>脚本中，向<code>Manager</code>类传入对应的画布对象，能更快的获取到<code>Canvas</code>对象。</p><h2 id="3-4-完善BaseUIPanel类"><a href="#3-4-完善BaseUIPanel类" class="headerlink" title="3.4 完善BaseUIPanel类"></a>3.4 完善<code>BaseUIPanel</code>类</h2><h3 id="3-4-1-获取CanvasGroup"><a href="#3-4-1-获取CanvasGroup" class="headerlink" title="3.4.1 获取CanvasGroup"></a>3.4.1 获取<code>CanvasGroup</code></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CanvasGroup _canvasGroup;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup = GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">    <span class="keyword">if</span> (_canvasGroup == <span class="literal">null</span>)</span><br><span class="line">        _canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后完善四个方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 打开时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 暂停时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重新启动时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 关闭时需要执行的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-扩展"><a href="#3-5-扩展" class="headerlink" title="3.5 扩展"></a>3.5 扩展</h2><h3 id="3-5-1-列表操作的扩展"><a href="#3-5-1-列表操作的扩展" class="headerlink" title="3.5.1 列表操作的扩展"></a>3.5.1 列表操作的扩展</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ListExtesion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 尝试在列表中查找指定的元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelInfos&quot;&gt;</span>当前操作的列表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>定的元素<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果列表中由指定的元素，就返回该元素；如果没有，就返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIPanelInfo <span class="title">TrySearchUIPanel</span>(<span class="params"><span class="keyword">this</span> List&lt;UIPanelInfo&gt; uIPanelInfos, UIPanelType uIPanelType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (UIPanelInfo uIPanelInfo <span class="keyword">in</span> uIPanelInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uIPanelInfo.Type == uIPanelType)</span><br><span class="line">                <span class="keyword">return</span> uIPanelInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、事件响应"><a href="#四、事件响应" class="headerlink" title="四、事件响应"></a>四、事件响应</h1><p>首先创建新的文件夹<code>UIEvents</code>，然后再该文件夹下创建对应的脚本。例如：对于<code>MainMenuUIPanel</code>面板，创建<code>MainMenuUIPanel</code>类，并继承自<code>BaseUIPanel</code>。并对父类<code>BaseUIPanel</code>中的虚方法进行重写和调用，并构造该面板独有的事件响应函数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainMenuUIPanel</span> : <span class="title">BaseUIPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnter();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEnter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnResume();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEixt();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEixt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开设置界面的按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSettingClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIPanelType.SettingUIPanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将此脚本，挂载到对应的游戏对象上，然后再对应的按钮上设置点击响应事件。</p><p><img src="http://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/Panel添加脚本.png" alt="Panel添加脚本"></p><p><img src="http://imageshack.yuilexi.cn/Unity3D/功能框架/UGUI/添加响应事件.png" alt="添加响应事件"></p><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><details class="folding-tag" ><summary> 完整代码 </summary>              <div class='content'>              <ul><li><p>UIFramework</p><ul><li><p>UIPanel</p><ul><li><p>UIPanelType.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 枚举，用于标识UIPanel的类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> UIPanelType</span><br><span class="line">&#123;</span><br><span class="line">    MainMenuUIPanel,</span><br><span class="line">    SettingUIPanel,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UIPanelInfo.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 描述UIPanel的信息，包括类型和路径</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPanelInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> UIPanelType _type;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _path;       <span class="comment">//注意，脚本使用Rescources.load()动态加载，这里的文件路径不需要后缀</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>()</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIPanelInfo</span>(<span class="params">UIPanelType type, <span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _type = type;</span><br><span class="line">        _path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UIPanelType Type</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _type; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _type = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Path</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _path; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _path = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BasePanel.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 该类需要挂载到每一个Panel的预制件上，因此继承MonoBehaviour</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseUIPanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CanvasGroup _canvasGroup;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _canvasGroup = GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        <span class="keyword">if</span> (_canvasGroup == <span class="literal">null</span>)</span><br><span class="line">            _canvasGroup = gameObject.AddComponent&lt;CanvasGroup&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 打开时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 暂停时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _canvasGroup.blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">        _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重新启动时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">        _canvasGroup.blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        _canvasGroup.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 关闭时需要执行的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Manager</p><ul><li><p>UIManager.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UIElements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 单例模式</span></span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UIManager s_instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UIManager Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s_instance == <span class="literal">null</span>)</span><br><span class="line">                s_instance = <span class="keyword">new</span> UIManager();</span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 单例模式</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 文件路径</span></span><br><span class="line">    <span class="comment">//存放 UIPanel 预制件的文件夹路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _basePahtUIPanelPrefabFolder = Application.dataPath + <span class="string">@&quot;/Resources/UIPanelPrefab/&quot;</span>;</span><br><span class="line">    <span class="comment">//存放UIPanel信息的Json文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFolderPath = Application.dataPath + <span class="string">@&quot;/Json/UIJson/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _jsonFileName = <span class="string">&quot;UIPanelInfo.json&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span> 文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;UIPanelInfo&gt; _uIPanelInfos;   <span class="comment">//该列表是存放所有的UIPanelInfo信息，包括未加载到游戏场景中的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform _canvasTransform; <span class="comment">//存放当前场景中的Canvas对象的Transform属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;BaseUIPanel&gt; _currentUIPanels; <span class="comment">//使用栈，存放当前场景中的所有UIPanel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Transform</span></span><br><span class="line">    <span class="keyword">public</span> Transform CanvasTransform</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_canvasTransform == <span class="literal">null</span>)</span><br><span class="line">                _canvasTransform = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line">            <span class="keyword">return</span> _canvasTransform;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span>.name == <span class="string">&quot;Canvas&quot;</span>)</span><br><span class="line">                _canvasTransform = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitUIPanelInfo(); <span class="comment">//初始化UIPanelInfo</span></span><br><span class="line">        CheckUIPanelWhenGameBegin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 传入路径和对应的数据，把该数据写入到对应路径的Json文件里</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;folderPath&quot;&gt;</span>文件夹路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fileName&quot;&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;t&quot;&gt;</span>写入的数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>数据类型<span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">WriteToJsonFile</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName, T t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> json = JsonMapper.ToJson(t);</span><br><span class="line">        <span class="comment">//如果文件夹不存在，就创建文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">            Directory.CreateDirectory(folderPath);</span><br><span class="line">        <span class="comment">//如果文件不存在，就创建文件</span></span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">            File.Create(folderPath + fileName).Dispose();</span><br><span class="line">        <span class="comment">//将数据写入到文件中</span></span><br><span class="line">        File.WriteAllText(folderPath + fileName, json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 传入文件的路径，就能读取到该文件的数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;folderPath&quot;&gt;</span>文件夹路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fileName&quot;&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ReadFromJsonFIle</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> folderPath, <span class="built_in">string</span> fileName</span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(folderPath))</span><br><span class="line">            Directory.CreateDirectory(folderPath);</span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(folderPath + fileName))</span><br><span class="line">            File.WriteAllText(folderPath + fileName, <span class="string">&quot;[]&quot;</span>);</span><br><span class="line">        List&lt;T&gt; t = JsonMapper.ToObject&lt;List&lt;T&gt;&gt;(File.ReadAllText(folderPath + fileName));</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 自动更新Json文件，并获取到所有的UIPanelInfo数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitUIPanelInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先获取当前Json文件中的UIPanelInfo数据</span></span><br><span class="line">        _uIPanelInfos = ReadFromJsonFIle&lt;UIPanelInfo&gt;(_jsonFolderPath, _jsonFileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建UIPanel的文件夹对象</span></span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(_basePahtUIPanelPrefabFolder))</span><br><span class="line">            Directory.CreateDirectory(_basePahtUIPanelPrefabFolder);</span><br><span class="line">        DirectoryInfo directoryInfo = <span class="keyword">new</span> DirectoryInfo(_basePahtUIPanelPrefabFolder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历文件夹下的每一个prefab文件。</span></span><br><span class="line">        <span class="comment">//如果当前UIPanelInfo列表中有对应类型的模板信息，就更新路径；没有，就添加对应信息到UIPanelInfo列表</span></span><br><span class="line">        <span class="keyword">foreach</span> (FileInfo fileInfo <span class="keyword">in</span> directoryInfo.GetFiles(<span class="string">&quot;*.prefab&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将对应UIPanel模板的名字转换为UIPanel类型</span></span><br><span class="line">            UIPanelType type = (UIPanelType)Enum.Parse(<span class="keyword">typeof</span>(UIPanelType), fileInfo.Name.Replace(<span class="string">&quot;.prefab&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="built_in">string</span> path = <span class="string">@&quot;UIPanelPrefab\&quot;</span> + Convert.ToString(type); <span class="comment">//基址+对应模板文件名，组成完整地址（不要后缀）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试在列表中寻找UIpanelInfo对象，如果有，则返回对应的对象；如果没有，则返回null</span></span><br><span class="line">            UIPanelInfo uIPanelInfo = _uIPanelInfos.TrySearchUIPanel(type);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uIPanelInfo == <span class="literal">null</span>)    <span class="comment">//UIPanel不在该List中</span></span><br><span class="line">            &#123;</span><br><span class="line">                uIPanelInfo = <span class="keyword">new</span> UIPanelInfo(type, path);</span><br><span class="line">                _uIPanelInfos.Add(uIPanelInfo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//UIPanel在该List中,更新path值</span></span><br><span class="line">            &#123;</span><br><span class="line">                uIPanelInfo.Path = path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        WriteToJsonFile&lt;List&lt;UIPanelInfo&gt;&gt;(_jsonFolderPath, _jsonFileName, _uIPanelInfos); <span class="comment">//将更新后的模板信息写入Json文件中去</span></span><br><span class="line">        AssetDatabase.Refresh(); <span class="comment">//刷新资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 根据对应的UIPanel类型，创建游戏实例对象，并返回该对象的BaseUIPanel脚本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>UIPanlel的类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;Exception&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseUIPanel <span class="title">GetUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_uIPanelInfos == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> path = _uIPanelInfos.TrySearchUIPanel(uIPanelType).Path;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Resources.Load(path) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;找不到该UIPanelType的Prefab&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span> 可能会出现的错误，实际开发时，可不用添加这块代码</span></span><br><span class="line"></span><br><span class="line">        GameObject insUIPanel = GameObject.Instantiate(Resources.Load(path)) <span class="keyword">as</span> GameObject; <span class="comment">//创建游戏实例对象</span></span><br><span class="line">        insUIPanel.transform.SetParent(CanvasTransform, <span class="literal">false</span>); <span class="comment">//设置父对象</span></span><br><span class="line">        <span class="keyword">return</span> insUIPanel.GetComponent&lt;BaseUIPanel&gt;(); <span class="comment">//返回BaseUIPanel脚本</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将对应的UIPanel压入栈中，并调用OnEnter方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushUIPanel</span>(<span class="params">UIPanelType uIPanelType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前栈为空</span></span><br><span class="line">        <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">            _currentUIPanels = <span class="keyword">new</span> Stack&lt;BaseUIPanel&gt;();</span><br><span class="line">        <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel暂停</span></span><br><span class="line">        <span class="keyword">if</span> (_currentUIPanels.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BaseUIPanel topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">            topUIPanel.OnPause();</span><br><span class="line">        &#125;</span><br><span class="line">        BaseUIPanel newUIPanel = GetUIPanel(uIPanelType);</span><br><span class="line">        _currentUIPanels.Push(newUIPanel);</span><br><span class="line">        newUIPanel.OnEnter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 输入顶级UIPanel的类型，就能弹出对应的UIPanel，并调用OnExit方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PopUIPanel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前栈为空，就返回</span></span><br><span class="line">        <span class="keyword">if</span> (_currentUIPanels == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果当前栈中没有UIPanel，就返回</span></span><br><span class="line">        <span class="keyword">if</span> (_currentUIPanels.Count &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出栈顶的UIPanel，并调用OnExit方法</span></span><br><span class="line">        BaseUIPanel topUIPanel = _currentUIPanels.Pop();</span><br><span class="line">        topUIPanel.OnEixt();</span><br><span class="line">        <span class="comment">//如果当前栈不为空，就把栈顶的UIPanel恢复</span></span><br><span class="line">        <span class="keyword">if</span> (_currentUIPanels.Count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        topUIPanel = _currentUIPanels.Peek();</span><br><span class="line">        topUIPanel.OnResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 摧毁场景中原来已经存在的UIPanel</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckUIPanelWhenGameBegin</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; CanvasTransform.childCount &gt; i;)</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject.DestroyImmediate(CanvasTransform.GetChild(i).gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UIManager.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManagerLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先把当前场景中的Canvas对象的Transform属性赋值给UIManager的CanvasTransform属性</span></span><br><span class="line">    <span class="comment">//游戏一开始就加载MainMenuUIPanel</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.CanvasTransform = <span class="keyword">this</span>.transform;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIPanelType.MainMenuUIPanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Extension</p><ul><li><p>ListExtension.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ListExtesion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 尝试在列表中查找指定的元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelInfos&quot;&gt;</span>当前操作的列表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;uIPanelType&quot;&gt;</span>定的元素<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果列表中由指定的元素，就返回该元素；如果没有，就返回null<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UIPanelInfo <span class="title">TrySearchUIPanel</span>(<span class="params"><span class="keyword">this</span> List&lt;UIPanelInfo&gt; uIPanelInfos, UIPanelType uIPanelType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (UIPanelInfo uIPanelInfo <span class="keyword">in</span> uIPanelInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (uIPanelInfo.Type == uIPanelType)</span><br><span class="line">                <span class="keyword">return</span> uIPanelInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>UIEvents</p><ul><li><p>MainMenuUIPanel.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainMenuUIPanel</span> : <span class="title">BaseUIPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnter();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEnter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnResume();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEixt();</span><br><span class="line">        Debug.Log(<span class="string">&quot;MainMenuUIPanel OnEixt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSettingClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.PushUIPanel(UIPanelType.SettingUIPanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SettingUIPanel.cs</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SettingUIPanel</span> : <span class="title">BaseUIPanel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEnter();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnEnter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnResume</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnResume();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnResume&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEixt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnEixt();</span><br><span class="line">        Debug.Log(<span class="string">&quot;SettingUIPanel OnEixt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCloseClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIManager.Instance.PopUIPanel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>              </div>            </details><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-8</p></div></div><div class='timeline-item-content'><ol><li>添加了<strong>事件响应</strong>功能，以及将<code>BaseUIPanel</code>类调整为抽象类，因此<code>UIPanel</code>上将会挂载<code>BaseUIPanel</code>的子类，而不是<code>BaseUIPanel</code>。</li><li>更新了 <strong>框架设计</strong> 部分的图示。</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> 功能框架 </category>
          
          <category> GUI </category>
          
          <category> Csharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp </tag>
            
            <tag> 功能框架 </tag>
            
            <tag> GUI </tag>
            
            <tag> UGUI </tag>
            
            <tag> Json </tag>
            
            <tag> Litjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#高级语法</title>
      <link href="/2023/04/30/Programming/Csharp%E7%9F%A5%E8%AF%86%E5%BA%93/Csharp%E5%9F%BA%E7%A1%80/Csharp%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/30/Programming/Csharp%E7%9F%A5%E8%AF%86%E5%BA%93/Csharp%E5%9F%BA%E7%A1%80/Csharp%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文章主要包含特性、反射、属性、索引器、委托、事件、集合、泛型、匿名方法、不安全代码、多线程等 C#的高级用法。</p><p>C#系列教程：</p><ol><li><a href="https://blog.yuilexi.cn/2023/04/26/Programming/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a></li><li><a href="https://blog.yuilexi.cn/2023/04/30/Programming/Csharp知识库/Csharp基础/Csharp高级语法/">C#高级语法 | 🪐星空鸟🪐 (yuilexi.cn)</a>⬅️当前的位置°꒰๑’ꀾ’๑꒱°</li></ol></blockquote><h1 id="特性（Attribute）"><a href="#特性（Attribute）" class="headerlink" title="特性（Attribute）"></a>特性（Attribute）</h1><h1 id="属性（Property）"><a href="#属性（Property）" class="headerlink" title="属性（Property）"></a>属性（Property）</h1><p><strong>属性（Property）</strong> 是类、结构和接口的命名（named）成员。类或结构中的成员变量或方法称为 <strong>域（Field）</strong>。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 <strong>访问器（accessors）</strong> 让私有域的值可被读写或操作。</p><p>属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 <strong>访问器（accessors）</strong>。</p><h2 id="访问器（Accessors）"><a href="#访问器（Accessors）" class="headerlink" title="访问器（Accessors）"></a>访问器（Accessors）</h2><p><font color='red'>属性</font>的<strong>访问器</strong>包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器声明可包含一个 <code>get</code> 访问器、一个 <code>set</code> 访问器，或者同时包含二者。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/ 声明类型为 <span class="built_in">string</span> 的 Code 属性</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> code;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Code</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> code;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型为 string 的 Name 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">     name = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型为 int 的 Age 属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      age = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get</code> 访问器和<code>set</code> 访问器尽管写法奇怪，但它们实际上是两个方法。在访问属性的值时，执行的是<code>get</code> 方法；在给属性赋值时，执行的是<code>set</code> 方法。因此，我们不仅能够对属性进行访问和修改，还可以在<code>get</code> 和<code>set</code> 内部书写逻辑，以便于规范访问和修改。</p><h2 id="抽象属性（Abstract-Properties）"><a href="#抽象属性（Abstract-Properties）" class="headerlink" title="抽象属性（Abstract Properties）"></a>抽象属性（Abstract Properties）</h2><p>抽象类可拥有抽象属性，这些属性应在派生类中被实现。下面的程序说明了这点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述抽象类中的抽象属性，必须在继承的子类中使用<code>override</code>进行重写：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _age = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="索引器（Indexer）"><a href="#索引器（Indexer）" class="headerlink" title="索引器（Indexer）"></a>索引器（Indexer）</h1><p><strong>索引器（Indexer）</strong> 允许一个对象可以像数组一样使用下标的方式来访问。当您为类定义一个索引器时，该类的行为就会像一个 <strong>虚拟数组（virtual array）</strong> 一样。您可以使用数组访问运算符 <strong>[ ]</strong> 来访问该类的的成员。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>一维索引器的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">element-type <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// get 访问器</span></span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 返回 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set 访问器</span></span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 设置 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器的用途"><a href="#索引器的用途" class="headerlink" title="索引器的用途"></a>索引器的用途</h2><p><strong>索引器</strong>的行为的声明在某种程度上类似于<strong>属性</strong>。就像属性一样，您可使用 <strong>get</strong> 和 <strong>set</strong> 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 索引器</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> _size = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>[] _name = <span class="keyword">new</span> <span class="built_in">string</span>[_size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造函数，进行初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _name[i] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//索引器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _name[index];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引超出范围&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                _name[index] = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主程序入口</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person persons = <span class="keyword">new</span> Person();</span><br><span class="line">            persons[<span class="number">0</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">            persons[<span class="number">1</span>] = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">            persons[<span class="number">2</span>] = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">            persons[<span class="number">3</span>] = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Person._size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(persons[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">赵六</span><br><span class="line">a</span><br></pre></td></tr></table></figure><h2 id="重载索引器"><a href="#重载索引器" class="headerlink" title="重载索引器"></a>重载索引器</h2><p><strong>索引器</strong>可被重载。索引器声明的时候也可带有多个参数，且每个参数可以是不同的类型。C# 允许索引器可以是其他类型。例如下面的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">string</span> name]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="委托（Delegate）"><a href="#委托（Delegate）" class="headerlink" title="委托（Delegate）"></a>委托（Delegate）</h1><p>C# 中的<strong>委托</strong>类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类。</p><h2 id="声明委托（Delegate）"><a href="#声明委托（Delegate）" class="headerlink" title="声明委托（Delegate）"></a>声明委托（Delegate）</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">MyDelegate</span> (<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的 <code>string</code> 参数的方法，并返回一个 <code>string</code> 类型变量。声明委托的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="built_in">delegate</span> 返回类型 委托名([参数列表])</span><br></pre></td></tr></table></figure><h2 id="实例化委托（Delegate）"><a href="#实例化委托（Delegate）" class="headerlink" title="实例化委托（Delegate）"></a>实例化委托（Delegate）</h2><p>一旦声明了委托类型，委托对象必须使用 <strong>new</strong> 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 <strong>new</strong> 语句的参数就像方法调用一样书写，但是不带有参数。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"><span class="keyword">namespace</span> 委托</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">First</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;你输入的是&quot;</span> + str + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Second</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str + str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Third</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str + str + str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyDelegate myDelegate1 = <span class="keyword">new</span> MyDelegate(First);</span><br><span class="line">            MyDelegate myDelegate2 = <span class="keyword">new</span> MyDelegate(Second);</span><br><span class="line">            myDelegate2 += Third;</span><br><span class="line">            Console.WriteLine(myDelegate1(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">            Console.WriteLine(myDelegate2(<span class="string">&quot;Hello,C#\n&quot;</span>));</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加到委托变量内的方法，<strong>必须和委托有相同的返回值和参数列表</strong>，同时在<code>new</code>时，必须向委托变量中传入一个方法作为参数，而且只能传入一个方法，这是因为委托这种特殊的类不含无参的构造方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是错误的语法，会报错</span></span><br><span class="line">MyDelegate myDelegate1 = <span class="keyword">new</span> MyDelegate();</span><br><span class="line"><span class="comment">//这是正确的写法</span></span><br><span class="line">MyDelegate myDelegate2 = <span class="keyword">new</span> MyDelegate(Second);</span><br></pre></td></tr></table></figure><h2 id="委托的多播（Multicasting-of-a-Delegate）"><a href="#委托的多播（Multicasting-of-a-Delegate）" class="headerlink" title="委托的多播（Multicasting of a Delegate）"></a>委托的多播（Multicasting of a Delegate）</h2><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。</p><p>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。</p><p>例如上面的代码中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myDelegate2 += Third;</span><br></pre></td></tr></table></figure><h1 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h1><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。</p><p>C# 中使用事件机制实现线程间的通信。</p><h2 id="通过事件使用委托"><a href="#通过事件使用委托" class="headerlink" title="通过事件使用委托"></a>通过事件使用委托</h2><p><strong>事件在类中声明且生成</strong>，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。</p><h2 id="声明事件（Event）"><a href="#声明事件（Event）" class="headerlink" title="声明事件（Event）"></a>声明事件（Event）</h2><p>在类的内部声明事件，首先必须声明该事件的委托类型。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后，声明事件本身，使用 <strong>event</strong> 关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 基于上面的委托定义事件</span><br><span class="line">public event MyDelegate MyEvent;</span><br></pre></td></tr></table></figure><p>例如下面实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel.Design;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 事件</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//发布器类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个整型变量，模拟当前数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明委托</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> str</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明事件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> MyDelegate MyEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发事件的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MyEvent(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;没有订阅者\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果值改变，就调用“触发事件的函数”</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="keyword">this</span>.<span class="keyword">value</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                OnMyEvent(<span class="string">&quot;已经修改了value的值&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅器</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show1</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;小明收到了：“&#123;0&#125;”的消息&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show2</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;小红收到了：“&#123;0&#125;”的消息&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show3</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;小刚收到了：“&#123;0&#125;”的消息&quot;</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//实例化一个发布器类的对象</span></span><br><span class="line">            EventTest eventTest = <span class="keyword">new</span> EventTest();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//订阅事件</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第一次尝试&quot;</span>);</span><br><span class="line">            eventTest.MyEvent += Show1;</span><br><span class="line">            eventTest.MyEvent += Show2;</span><br><span class="line">            eventTest.SetValue(<span class="number">10</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第二次尝试&quot;</span>);</span><br><span class="line">            eventTest.SetValue(<span class="number">10</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第三次尝试&quot;</span>);</span><br><span class="line">            eventTest.MyEvent += Show3;</span><br><span class="line">            eventTest.SetValue(<span class="number">20</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;第四次尝试&quot;</span>);</span><br><span class="line">            eventTest.MyEvent -= Show1;</span><br><span class="line">            eventTest.SetValue(<span class="number">30</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次尝试</span><br><span class="line">小明收到了：“已经修改了value的值”的消息</span><br><span class="line">小红收到了：“已经修改了value的值”的消息</span><br><span class="line">第二次尝试</span><br><span class="line">第三次尝试</span><br><span class="line">小明收到了：“已经修改了value的值”的消息</span><br><span class="line">小红收到了：“已经修改了value的值”的消息</span><br><span class="line">小刚收到了：“已经修改了value的值”的消息</span><br><span class="line">第四次尝试</span><br><span class="line">小红收到了：“已经修改了value的值”的消息</span><br><span class="line">小刚收到了：“已经修改了value的值”的消息</span><br></pre></td></tr></table></figure><h1 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h1><p><strong>集合类</strong>是专门用于数据存储和检索的类。这些类提供了<strong>对栈</strong>、<strong>队列</strong>、<strong>列表</strong>和<strong>哈希表</strong>的支持。大多数集合类实现了相同的接口。</p><p><strong>集合类</strong>服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 <code>Object</code> 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。</p><h2 id="动态数组（ArrayList）"><a href="#动态数组（ArrayList）" class="headerlink" title="动态数组（ArrayList）"></a>动态数组（ArrayList）</h2><p><strong>动态数组</strong>代表了可被单独索引的对象的有序集合。它基本上可以替代一个数组。但是，与数组不同的是，您可以使用<strong>索引</strong>在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。</p><h3 id="ArrayList-类的属性"><a href="#ArrayList-类的属性" class="headerlink" title="ArrayList 类的属性"></a>ArrayList 类的属性</h3><p>下表列出了 <strong>ArrayList</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Capacity</td><td style="text-align:left">获取或设置 ArrayList 可以包含的元素个数。</td></tr><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 ArrayList 中实际包含的元素个数。</td></tr><tr><td style="text-align:left">IsFixedSize</td><td style="text-align:left">获取一个值，表示 ArrayList 是否具有固定大小。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 ArrayList 是否只读。</td></tr><tr><td style="text-align:left">IsSynchronized</td><td style="text-align:left">获取一个值，表示访问 ArrayList 是否同步（线程安全）。</td></tr><tr><td style="text-align:left">Item[Int32]</td><td style="text-align:left">获取或设置指定索引处的元素。</td></tr><tr><td style="text-align:left">SyncRoot</td><td style="text-align:left">获取一个对象用于同步访问 ArrayList。</td></tr></tbody></table></div><h3 id="ArrayList-类的方法"><a href="#ArrayList-类的方法" class="headerlink" title="ArrayList 类的方法"></a>ArrayList 类的方法</h3><p><strong>ArrayList</strong> 类的一些常用的 <strong>方法</strong>：详情请看<a href="https://www.runoob.com/csharp/csharp-arraylist.html">C# 动态数组（ArrayList） | 菜鸟教程 (runoob.com)</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:left"><strong>public virtual int Add( object value )</strong></td><td><strong>在 ArrayList 的末尾添加一个对象</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">public virtual void AddRange( ICollection c )</td><td>在 ArrayList 的末尾添加 ICollection 的元素。</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 ArrayList 中移除所有的元素</strong></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:left"><strong>public virtual bool Contains( object item )</strong></td><td><strong>判断某个元素是否在 ArrayList 中</strong></td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">public virtual ArrayList GetRange( int index, int count )</td><td>返回一个 ArrayList，表示源 ArrayList 中元素的子集</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">public virtual int IndexOf(object)</td><td>返回某个值在 ArrayList 中第一次出现的索引，索引从零开始</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">public virtual void Insert( int index, object value )</td><td>在 ArrayList 的指定索引处，插入一个元素</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left">public virtual void InsertRange( int index, ICollection c )</td><td>在 ArrayList 的指定索引处，插入某个集合的元素。</td></tr><tr><td style="text-align:center"><strong>9</strong></td><td style="text-align:left"><strong>public virtual void Remove( object obj )</strong></td><td><strong>从 ArrayList 中移除第一次出现的指定对象</strong></td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">public virtual void RemoveAt( int index )</td><td>移除 ArrayList 的指定索引处的元素。</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">public virtual void RemoveRange( int index, int count )</td><td>从 ArrayList 中移除某个范围的元素</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left">public virtual void Reverse()</td><td>逆转 ArrayList 中元素的顺序</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left">public virtual void SetRange( int index, ICollection c )</td><td>复制某个集合的元素到 ArrayList 中某个范围的元素上</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left">public virtual void Sort()</td><td>对 ArrayList 中的元素进行排序</td></tr><tr><td style="text-align:center">15</td><td style="text-align:left">public virtual void TrimToSize()</td><td>设置容量为 ArrayList 中元素的实际个数</td></tr></tbody></table></div><h2 id="哈希表（Hashtable）"><a href="#哈希表（Hashtable）" class="headerlink" title="哈希表（Hashtable）"></a>哈希表（Hashtable）</h2><p><code>Hashtable</code> 类代表了一系列基于键的哈希代码组织起来的<strong>键/值</strong>对。它使用<strong>键</strong>来访问集合中的元素。</p><p>当您使用<strong>键</strong>访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个<strong>键/值</strong>对。键用于访问集合中的项目。</p><h3 id="Hashtable-类的属性"><a href="#Hashtable-类的属性" class="headerlink" title="Hashtable 类的属性"></a>Hashtable 类的属性</h3><p>下表列出了 <strong>Hashtable</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 Hashtable 中包含的键值对个数。</td></tr><tr><td style="text-align:left">IsFixedSize</td><td style="text-align:left">获取一个值，表示 Hashtable 是否具有固定大小。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 Hashtable 是否只读。</td></tr><tr><td style="text-align:left">Item</td><td style="text-align:left">获取或设置与指定的键相关的值。</td></tr><tr><td style="text-align:left">Keys</td><td style="text-align:left">获取一个 ICollection，包含 Hashtable 中的键。</td></tr><tr><td style="text-align:left">Values</td><td style="text-align:left">获取一个 ICollection，包含 Hashtable 中的值。</td></tr></tbody></table></div><h3 id="Hashtable-类的方法"><a href="#Hashtable-类的方法" class="headerlink" title="Hashtable 类的方法"></a>Hashtable 类的方法</h3><p>下表列出了 <strong>Hashtable</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>1</strong></td><td style="text-align:left"><strong>public virtual void Add( object key, object value )</strong></td><td><strong>向 Hashtable 添加一个带有指定的键和值的元素</strong></td></tr><tr><td style="text-align:left"><strong>2</strong></td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 Hashtable 中移除所有的元素</strong></td></tr><tr><td style="text-align:left"><strong>3</strong></td><td style="text-align:left"><strong>public virtual bool ContainsKey( object key )</strong></td><td><strong>判断 Hashtable 是否包含指定的键</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual bool ContainsValue( object value )</strong></td><td><strong>判断 Hashtable 是否包含指定的值</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public virtual void Remove( object key )</strong></td><td><strong>从 Hashtable 中移除带有指定的键的元素</strong></td></tr></tbody></table></div><h2 id="排序列表（SortedList）"><a href="#排序列表（SortedList）" class="headerlink" title="排序列表（SortedList）"></a>排序列表（SortedList）</h2><p>SortedList 类代表了一系列按照键来排序的<strong>键/值</strong>对，这些键值对可以通过键和索引来访问。</p><p>排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。</p><h3 id="SortedList-类的属性"><a href="#SortedList-类的属性" class="headerlink" title="SortedList 类的属性"></a>SortedList 类的属性</h3><p>下表列出了 <strong>SortedList</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Capacity</td><td style="text-align:left">获取或设置 SortedList 的容量。</td></tr><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 SortedList 中的元素个数。</td></tr><tr><td style="text-align:left">IsFixedSize</td><td style="text-align:left">获取一个值，表示 SortedList 是否具有固定大小。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 SortedList 是否只读。</td></tr><tr><td style="text-align:left">Item</td><td style="text-align:left">获取或设置与 SortedList 中指定的键相关的值。</td></tr><tr><td style="text-align:left">Keys</td><td style="text-align:left">获取 SortedList 中的键。</td></tr><tr><td style="text-align:left">Values</td><td style="text-align:left">获取 SortedList 中的值。</td></tr></tbody></table></div><h3 id="SortedList-类的方法"><a href="#SortedList-类的方法" class="headerlink" title="SortedList 类的方法"></a>SortedList 类的方法</h3><p>下表列出了 <strong>SortedList</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public virtual void Add( object key, object value )</strong></td><td><strong>向 SortedList 添加一个带有指定的键和值的元素</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 SortedList 中移除所有的元素</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public virtual bool ContainsKey( object key )</strong></td><td><strong>判断 SortedList 是否包含指定的键</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual bool ContainsValue( object value )</strong></td><td><strong>判断 SortedList 是否包含指定的值</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">public virtual object GetByIndex( int index )</td><td>获取 SortedList 的指定索引处的值</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">public virtual object GetKey( int index )</td><td>获取 SortedList 的指定索引处的键</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">public virtual IList GetKeyList()</td><td>获取 SortedList 中的键</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">public virtual IList GetValueList()</td><td>获取 SortedList 中的值</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">public virtual int IndexOfKey( object key )</td><td>返回 SortedList 中的指定键的索引，索引从零开始</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">public virtual int IndexOfValue( object value )</td><td>返回 SortedList 中的指定值第一次出现的索引，索引从零开始</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>public virtual void Remove( object key )</strong></td><td><strong>从 SortedList 中移除带有指定的键的元素</strong></td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>public virtual void RemoveAt( int index )</strong></td><td><strong>移除 SortedList 的指定索引处的元素</strong></td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">public virtual void TrimToSize()</td><td>设置容量为 SortedList 中元素的实际个数</td></tr></tbody></table></div><h2 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h2><p>堆栈（Stack）代表了一个<strong>后进先出</strong>的对象集合。当您需要对各项进行后进先出的访问时，则使用堆栈。当您在列表中添加一项，称为<strong>推入</strong>元素，当您从列表中移除一项时，称为<strong>弹出</strong>元素。</p><h3 id="Stack-类的属性"><a href="#Stack-类的属性" class="headerlink" title="Stack 类的属性"></a>Stack 类的属性</h3><p>下表列出了 <strong>Stack</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 Stack 中包含的元素个数。</td></tr></tbody></table></div><h3 id="Stack-类的方法"><a href="#Stack-类的方法" class="headerlink" title="Stack 类的方法"></a>Stack 类的方法</h3><p>下表列出了 <strong>Stack</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong> 从 Stack 中移除所有的元素</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public virtual bool Contains( object obj )</strong></td><td><strong>判断某个元素是否在 Stack 中</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public virtual object Peek()</strong></td><td><strong>返回在 Stack 的顶部的对象，但不移除它</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual object Pop()</strong></td><td><strong>返回并移除在 Stack 的顶部的对象</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public virtual void Push( object obj )</strong></td><td><strong>向 Stack 的顶部添加一个对象</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">public virtual object[] ToArray()</td><td>复制 Stack 到一个新的数组中</td></tr></tbody></table></div><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列（Queue）代表了一个<strong>先进先出</strong>的对象集合。当您需要对各项进行先进先出的访问时，则使用队列。当您在列表中添加一项，称为<strong>入队</strong>，当您从列表中移除一项时，称为<strong>出队</strong>。</p><h3 id="Queue-类的属性"><a href="#Queue-类的属性" class="headerlink" title="Queue 类的属性"></a>Queue 类的属性</h3><p>下表列出了 <strong>Queue</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 Queue 中包含的元素个数。</td></tr></tbody></table></div><h3 id="Queue-类的方法"><a href="#Queue-类的方法" class="headerlink" title="Queue 类的方法"></a>Queue 类的方法</h3><p>下表列出了 <strong>Queue</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public virtual void Clear()</strong></td><td><strong>从 Queue 中移除所有的元素</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public virtual bool Contains( object obj )</strong></td><td><strong>判断某个元素是否在 Queue 中</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public virtual object Dequeue()</strong></td><td><strong>移除并返回在 Queue 的开头的对象</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public virtual void Enqueue( object obj )</strong></td><td><strong>向 Queue 的末尾添加一个对象</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">public virtual object[] ToArray()</td><td>复制 Queue 到一个新的数组中</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">public virtual void TrimToSize()</td><td>设置容量为 Queue 中元素的实际个数</td></tr></tbody></table></div><h2 id="点阵列（BitArray）"><a href="#点阵列（BitArray）" class="headerlink" title="点阵列（BitArray）"></a>点阵列（BitArray）</h2><p>BitArray 类管理一个紧凑型的位值数组，它使用布尔值来表示，其中 true 表示位是开启的（1），false 表示位是关闭的（0）。</p><p>当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用<strong>整型索引</strong>从点阵列集合中访问各项，索引从零开始。</p><h3 id="BitArray-类的属性"><a href="#BitArray-类的属性" class="headerlink" title="BitArray 类的属性"></a>BitArray 类的属性</h3><p>下表列出了 <strong>BitArray</strong> 类的一些常用的 <strong>属性</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Count</td><td style="text-align:left">获取 BitArray 中包含的元素个数。</td></tr><tr><td style="text-align:left">IsReadOnly</td><td style="text-align:left">获取一个值，表示 BitArray 是否只读。</td></tr><tr><td style="text-align:left">Item</td><td style="text-align:left">获取或设置 BitArray 中指定位置的位的值。</td></tr><tr><td style="text-align:left">Length</td><td style="text-align:left">获取或设置 BitArray 中的元素个数。</td></tr></tbody></table></div><h3 id="BitArray-类的方法"><a href="#BitArray-类的方法" class="headerlink" title="BitArray 类的方法"></a>BitArray 类的方法</h3><p>下表列出了 <strong>BitArray</strong> 类的一些常用的 <strong>方法</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:left">方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">public BitArray And( BitArray value )</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位与操作</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">public bool Get( int index )</td><td>获取 BitArray 中指定位置的位的值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">public BitArray Not()</td><td>把当前的 BitArray 中的位值反转，以便设置为 true 的元素变为 false，设置为 false 的元素变为 true</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">public BitArray Or( BitArray value )</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位或操作</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">public void Set( int index, bool value )</td><td>把 BitArray 中指定位置的位设置为指定的值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">public void SetAll( bool value )</td><td>把 BitArray 中的所有位设置为指定的值</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left">public BitArray Xor( BitArray value )</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位异或操作</td></tr></tbody></table></div><h1 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h1><p><strong>泛型（Generic）</strong> 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。</p><p>例如下面例子，来说明泛型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 泛型</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Number</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> T _number1;</span><br><span class="line">        <span class="keyword">public</span> T _number2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Number&lt;<span class="built_in">int</span>&gt; number = <span class="keyword">new</span> Number&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            number._number1 = <span class="number">1</span>;</span><br><span class="line">            number._number2 = <span class="number">2</span>;</span><br><span class="line">            Console.WriteLine(number._number1 + number._number2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型（Generic）的特性"><a href="#泛型（Generic）的特性" class="headerlink" title="泛型（Generic）的特性"></a>泛型（Generic）的特性</h2><p>使用泛型是一种增强程序功能的技术，具体表现在以下几个方面：</p><ul><li>它有助于您最大限度地重用代码、保护类型的安全以及提高性能。</li><li>您可以创建泛型集合类。</li><li>您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。</li><li>您可以对泛型类进行约束以访问特定数据类型的方法。</li><li>关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。</li></ul><p>在声明泛型方法/泛型类的时候，可以给泛型加上一定的约束来满足我们特定的一些条件。泛型限定条件：</p><ul><li>T：结构（类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型）</li><li>T：类 （类型参数必须是引用类型，包括任何类、接口、委托或数组类型）</li><li>T：new() （类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时 new() 约束必须最后指定）</li><li>T：&lt;基类名&gt; 类型参数必须是指定的基类或派生自指定的基类</li><li>T：&lt;接口名称&gt; 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</li></ul><h1 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h1><p>我们已经提到过，委托是用于引用与其具有相同标签的方法。换句话说，您可以使用委托对象调用可由委托引用的方法。</p><p><strong>匿名方法（Anonymous methods）</strong> 提供了一种传递代码块作为委托参数的技术。匿名方法是没有名称只有主体的方法。</p><p>在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。</p><h2 id="编写匿名方法的语法"><a href="#编写匿名方法的语法" class="headerlink" title="编写匿名方法的语法"></a>编写匿名方法的语法</h2><p>匿名方法是通过使用 <strong>delegate</strong> 关键字创建委托实例来声明的。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delegate void NumberChanger(int n);</span><br><span class="line">...</span><br><span class="line">NumberChanger nc = delegate(int x)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;Anonymous Method: &#123;0&#125;&quot;, x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码块 <strong>Console.WriteLine(“Anonymous Method: {0}”, x);</strong> 是匿名方法的主体。</p><p>委托可以通过匿名方法调用，也可以通过命名方法调用，即，通过向委托对象传递方法参数。</p><blockquote><p><strong>注意:</strong> 匿名方法的主体后面需要一个 <strong><code>;</code></strong></p></blockquote><h1 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h1><p>当一个代码块使用 <strong>unsafe</strong> 修饰符标记时，C# 允许在函数中使用指针变量。<strong>不安全代码</strong>或非托管代码是指使用了<strong>指针</strong>变量的代码块。</p><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h2><p><strong>指针</strong> 是值为另一个变量的地址的变量，即内存位置的直接地址。就像其他变量或常量，您必须在使用指针存储其他变量地址之前声明指针。</p><p>指针变量声明的一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* var-name;</span><br></pre></td></tr></table></figure><p>下面是指针类型声明的实例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">实例</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int* p</code></td><td style="text-align:left"><code>p</code> 是指向整数的指针。</td></tr><tr><td style="text-align:left"><code>double* p</code></td><td style="text-align:left"><code>p</code> 是指向双精度数的指针。</td></tr><tr><td style="text-align:left"><code>float* p</code></td><td style="text-align:left"><code>p</code> 是指向浮点数的指针。</td></tr><tr><td style="text-align:left"><code>int** p</code></td><td style="text-align:left"><code>p</code> 是指向整数的指针的指针。</td></tr><tr><td style="text-align:left"><code>int*[] p</code></td><td style="text-align:left"><code>p</code> 是指向整数的指针的一维数组。</td></tr><tr><td style="text-align:left"><code>char* p</code></td><td style="text-align:left"><code>p</code> 是指向字符的指针。</td></tr><tr><td style="text-align:left"><code>void* p</code></td><td style="text-align:left"><code>p</code> 是指向未知类型的指针。</td></tr></tbody></table></div><h2 id="编译不安全代码"><a href="#编译不安全代码" class="headerlink" title="编译不安全代码"></a>编译不安全代码</h2><p>为了编译不安全代码，您必须切换到命令行编译器指定 <strong>/unsafe</strong> 命令行。</p><p>例如，为了编译包含不安全代码的名为 prog1.cs 的程序，需在命令行中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csc /unsafe prog1.cs</span><br></pre></td></tr></table></figure><h2 id="fixed-关键字"><a href="#fixed-关键字" class="headerlink" title="fixed 关键字"></a>fixed 关键字</h2><p>由于 C#中声明的变量在内存中的存储受垃圾回收器管理；因此一个变量（例如一个大数组）有可能在运行过程中被移动到内存中的其他位置。如果一个变量的内存地址会变化，那么指针也就没有意义了。</p><p>解决方法就是使用 fixed 关键字来固定变量位置不移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static unsafe void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  fixed(int *ptr = int[5])  &#123;//...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stackalloc"><a href="#stackalloc" class="headerlink" title="stackalloc"></a>stackalloc</h3><p>在 unsafe 不安全环境中，我们可以通过 stackalloc 在堆栈上分配内存，因为在堆栈上分配的内存不受内存管理器管理，因此其相应的指针不需要固定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static unsafe void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">  int *ptr = stackalloc int[1] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>线程</strong> 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。</p><p>线程是<strong>轻量级进程</strong>。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。</p><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。</p><p>下面列出了线程生命周期中的各种状态：</p><ul><li><strong>未启动状态</strong>：当线程实例被创建但 Start 方法未被调用时的状况。</li><li><strong>就绪状态</strong>：当线程准备好运行并等待 CPU 周期时的状况。</li><li>不可运行状态<ul><li>已经调用 Sleep 方法</li><li>已经调用 Wait 方法</li><li>通过 I/O 操作阻塞</li></ul></li><li><strong>死亡状态</strong>：当线程已完成执行或已中止时的状况。</li></ul><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在 C# 中，<strong>System.Threading.Thread</strong> 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为<strong>主线程</strong>。</p><p>当 C# 程序开始执行时，主线程自动创建。使用 <strong>Thread</strong> 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 <strong>CurrentThread</strong> 属性访问线程。</p><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-10</p></div></div><div class='timeline-item-content'><ol><li>更新了 <strong>线程</strong> 更详细的用法</li><li>在文章前面添加 <strong>前言</strong> 部分</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp </category>
          
          <category> Csharp基础 </category>
          
          <category> Unity3D基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> Csharp基础 </tag>
            
            <tag> Csharp高级语法 </tag>
            
            <tag> Unity3D基础 </tag>
            
            <tag> 面型对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/04/30/Programming/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/30/Programming/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p><strong>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>。<strong>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性</strong>。 毫无疑问，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="什么是-GOF（四人帮，全拼-Gang-of-Four）？"><a href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？" class="headerlink" title="什么是 GOF（四人帮，全拼 Gang of Four）？"></a>什么是 GOF（四人帮，全拼 Gang of Four）？</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。</li></ul><h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途。</p><ul><li><p>开发人员的共同平台</p><p>​ 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p></li><li><p>最佳的实践</p><p>​ 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p></li></ul><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><ol><li><p><strong>创建型模式</strong></p><p>​ 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul></li><li><p><strong>结构型模式</strong></p><p>​ 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul></li><li><p><strong>行为型模式</strong></p><p>​ 这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul></li></ol><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ol><li><p><strong>开闭原则（Open Close Principle）</strong></p><p>​ 开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>​ 简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></li><li><p><strong>里氏代换原则（Liskov Substitution Principle）</strong></p><p>​ 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>（父类变量里面装载子类对象）。</p><p>​ LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</p><p>​ 里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong></p><p>​ 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong></p><p>​ 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，<strong>它强调降低依赖，降低耦合</strong>。</p></li><li><p><strong>迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>​ 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><strong>合成复用原则（Composite Reuse Principle）</strong></p><p>​ 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p></li></ol><h2 id="采用的语言"><a href="#采用的语言" class="headerlink" title="采用的语言"></a>采用的语言</h2><p>设计模式是针对针对编程的一种思想和解决方法，和使用哪种语言无关。为了更直观地反映设计模式的好处与作用，此文章采用 C# 的语法进行展示。C# 的基本用法，可以参照<a href="https://blog.yuilexi.cn/2023/04/26/Programming/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>这篇文章。</p><h1 id="简单工厂模式（创造）"><a href="#简单工厂模式（创造）" class="headerlink" title="简单工厂模式（创造）"></a>简单工厂模式（创造）</h1><p>工厂模式是 最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式<strong>。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li><li><strong>主要解决：</strong>主要解决接口选择的问题。</li><li><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</li><li><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</li><li><strong>关键代码：</strong>创建过程在其子类执行。</li><li><strong>优点：</strong></li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li><li><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</li></ol><p><img src="http://imageshack.yuilexi.cn/Programming/设计模式/简单工厂模式.svg" alt="简单工厂模式"></p><p>当存在多个子类时，我们可以创建一个父类。每当需要子类对象时，我们都给它一个父类对象，而父类对象中具体装载哪个子类对象，就需要根据用户的需求而定。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面例子将实现一个简单的工厂模式。情景想象：一个工厂可以生产三种笔记本电脑，分别是：联想、惠普和戴尔。工厂事先不知道用户要选择哪种品牌的电脑，但是无论选什么品牌，必定是“电脑”这一物品。</p><p>第一步，先创建一个接口，以便于子类能够继承这个接口。也可以使用抽象类、一般父类实现。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建一个接口：电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintComputer</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建三个笔记本电脑的具体品牌的子类：联想、惠普、戴尔，这三个子类继承上面的<code>IComputer</code>接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在创建三个类，分别是：联想、惠普、戴尔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lenovo</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;联想笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HP</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;惠普笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dell</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;戴尔笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个工厂类，用于实现具体的电脑。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个简单工厂类，用来创建电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComputerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IComputer computer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> Lenovo();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HP&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> HP();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">                computer = <span class="keyword">new</span> Dell();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，作为顾客，要去购买电脑。具体代码在主函数里面实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建电脑对象，返回一个接口实例，而接口中转载不同需求的电脑品牌</span></span><br><span class="line">        IComputer computer1 = ComputerFactory.CreateComputer(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        computer1.PrintComputer();</span><br><span class="line">        IComputer  computer2 = ComputerFactory.CreateComputer(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        computer2.PrintComputer();</span><br><span class="line">        IComputer computer3 = ComputerFactory.CreateComputer(<span class="string">&quot;Dell&quot;</span>);</span><br><span class="line">        computer3.PrintComputer();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管顾客想买什么品牌的电脑，可以直接给他一个<code>电脑</code>（基类），<code>电脑</code>具体是什么品牌（基类里面装什么子类），根据顾客的需求，就能实现对应的品牌（<code>public static IComputer CreateComputer(string type)</code>实现）。这样，就能向用户隐藏内部的逻辑，因为用户接收的是一个基类，而子类的实现与装载已经封装起来。</p><h1 id="抽象工厂模式（创造）"><a href="#抽象工厂模式（创造）" class="headerlink" title="抽象工厂模式（创造）"></a>抽象工厂模式（创造）</h1><p>抽象工厂模式是围绕一个超级工厂创建其他工厂。<strong>该超级工厂又称为其他工厂的工厂</strong>。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong> <strong>在一个工厂里聚合多个同类产品</strong>。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p><p><img src="http://imageshack.yuilexi.cn/Programming/设计模式/抽象工厂模式.svg" alt="抽象工厂模式"></p><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>基于<a href="#具体实现-1">简单工厂模式</a>进行扩展。我们不仅可以选择笔记本的品牌，还可以选择手机的品牌。笔记本和手机之间没有任何关联，都有单独的工厂。而电脑与手机的生产购买逻辑是一样的，因此先创建一个工厂，在选择是哪种工厂，最后选择该工厂的哪个产品。</p><p>基于上面的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再创建一个接口：手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintPhone</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后构造三个手机的品牌的子类：苹果、三星、OPPO，这三个子类继承上面的<code>IPhone</code>接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建三个类，分别是：苹果、三星、OPPO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Samsung</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;三星手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OPPO</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OPPO手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造一个超级工厂的抽象类，用于<strong>具体的工厂的继承</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个抽象的超级工厂类，用于实现某个工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IComputer <span class="title">CreateComputer</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IColor <span class="title">CreateColor</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造电脑品牌和手机品牌的两个工厂，继承于<code>AbstractFactory</code>这个抽象类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造“电脑品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComputerFactort</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Lenovo();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HP&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HP();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dell();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造“手机品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhoneFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Samsung&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Samsung();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;OPPO&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OPPO();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造一个工厂生成器，通过对输入的需求信息分析，进行选择对应的工厂。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个工厂创造器/生成器类，通过传递品牌或颜色信息来获取工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FactoryProducer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">GetFactory</span>(<span class="params"><span class="built_in">string</span> choice</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Computer&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ComputerFactort();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Phone&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhoneFactory();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在主函数中，创建上述工厂，并获得对应的产品。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建电脑工厂</span></span><br><span class="line">        AbstractFactory factoryComputer = FactoryProducer.GetFactory(<span class="string">&quot;Computer&quot;</span>);</span><br><span class="line">        <span class="comment">//创建联想电脑</span></span><br><span class="line">        IComputer computer1 = factoryComputer.CreateComputer(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        computer1.PrintComputer();</span><br><span class="line">        <span class="comment">//创建惠普电脑</span></span><br><span class="line">        IComputer computer2 = factoryComputer.CreateComputer(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        computer2.PrintComputer();</span><br><span class="line">        <span class="comment">//创建戴尔电脑</span></span><br><span class="line">        IComputer computer3 = factoryComputer.CreateComputer(<span class="string">&quot;Dell&quot;</span>);</span><br><span class="line">        computer3.PrintComputer();</span><br><span class="line">        <span class="comment">//创建手机工厂</span></span><br><span class="line">        AbstractFactory factoryPhone = FactoryProducer.GetFactory(<span class="string">&quot;Phone&quot;</span>);</span><br><span class="line">        <span class="comment">//创建苹果手机</span></span><br><span class="line">        IPhone phone1 = factoryPhone.CreateColor(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        phone1.PrintPhone();</span><br><span class="line">        <span class="comment">//创建三星手机</span></span><br><span class="line">        IPhone phone2 = factoryPhone.CreateColor(<span class="string">&quot;Samsung&quot;</span>);</span><br><span class="line">        phone2.PrintPhone();</span><br><span class="line">        <span class="comment">//创建OPPO手机</span></span><br><span class="line">        IPhone phone3 = factoryPhone.CreateColor(<span class="string">&quot;OPPO&quot;</span>);</span><br><span class="line">        phone3.PrintPhone();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;程序结束!&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">联想笔记本</span><br><span class="line">惠普笔记本</span><br><span class="line">戴尔笔记本</span><br><span class="line">苹果手机</span><br><span class="line">三星手机</span><br><span class="line">OPPO手机</span><br><span class="line">程序结束!</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个接口：电脑品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintComputer</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再创建一个接口：手机品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintPhone</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个抽象的超级工厂类，用于实现某个工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建电脑工厂</span></span><br><span class="line">        AbstractFactory factoryComputer = FactoryProducer.GetFactory(<span class="string">&quot;Computer&quot;</span>);</span><br><span class="line">        <span class="comment">//创建联想电脑</span></span><br><span class="line">        IComputer computer1 = factoryComputer.CreateComputer(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">        computer1.PrintComputer();</span><br><span class="line">        <span class="comment">//创建惠普电脑</span></span><br><span class="line">        IComputer computer2 = factoryComputer.CreateComputer(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">        computer2.PrintComputer();</span><br><span class="line">        <span class="comment">//创建戴尔电脑</span></span><br><span class="line">        IComputer computer3 = factoryComputer.CreateComputer(<span class="string">&quot;Dell&quot;</span>);</span><br><span class="line">        computer3.PrintComputer();</span><br><span class="line">        <span class="comment">//创建手机工厂</span></span><br><span class="line">        AbstractFactory factoryPhone = FactoryProducer.GetFactory(<span class="string">&quot;Phone&quot;</span>);</span><br><span class="line">        <span class="comment">//创建苹果手机</span></span><br><span class="line">        IPhone phone1 = factoryPhone.CreateColor(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        phone1.PrintPhone();</span><br><span class="line">        <span class="comment">//创建三星手机</span></span><br><span class="line">        IPhone phone2 = factoryPhone.CreateColor(<span class="string">&quot;Samsung&quot;</span>);</span><br><span class="line">        phone2.PrintPhone();</span><br><span class="line">        <span class="comment">//创建OPPO手机</span></span><br><span class="line">        IPhone phone3 = factoryPhone.CreateColor(<span class="string">&quot;OPPO&quot;</span>);</span><br><span class="line">        phone3.PrintPhone();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;程序结束!&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在创建三个类，分别是：联想、惠普、戴尔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lenovo</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;联想笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HP</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;惠普笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dell</span> : <span class="title">IComputer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintComputer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;戴尔笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建三个类，分别是：苹果、三星、OPPO</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Apple</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;苹果手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Samsung</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;三星手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OPPO</span> : <span class="title">IPhone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPhone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OPPO手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造“电脑品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ComputerFactort</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Lenovo&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Lenovo();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;HP&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HP();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dell();</span><br><span class="line"></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造“手机品牌”的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhoneFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IComputer <span class="title">CreateComputer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IPhone <span class="title">CreateColor</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Samsung&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Samsung();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;OPPO&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OPPO();</span><br><span class="line"></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个工厂创造器/生成器类，通过传递品牌或颜色信息来获取工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FactoryProducer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">GetFactory</span>(<span class="params"><span class="built_in">string</span> choice</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Computer&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ComputerFactort();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Phone&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhoneFactory();</span><br><span class="line"></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式（创造）"><a href="#单例模式（创造）" class="headerlink" title="单例模式（创造）"></a>单例模式（创造）</h1><p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><img src="http://imageshack.yuilexi.cn/Programming/设计模式/单例模式.svg" alt="单例模式"></p><h2 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="单线程，懒汉式"><a href="#单线程，懒汉式" class="headerlink" title="单线程，懒汉式"></a>单线程，懒汉式</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个单例类的对象，用于存放当前类的唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="comment">//构造函数私有化，防止外界创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用属性的访问器来生成单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当前类的实例为空，则创建一个新的实例，否则返回当前实例</span></span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅可以用访问器，还可以使用方法来进行访问实例化的对象。例如将上面代码改写为下面的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个单例类的对象，用于存放当前类的唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="comment">//构造函数私有化，防止外界创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前对象的方法，修饰为静态方法，以便于直接能“类名.方法”进行调用，而不是使用“对象名.方法”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断当前类的唯一实例是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果为空，则创建一个新的实例</span></span><br><span class="line">            _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不为空，则直接返回当前实例</span></span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全，加锁"><a href="#线程安全，加锁" class="headerlink" title="线程安全，加锁"></a>线程安全，加锁</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span></span><br><span class="line">        <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">        <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span></span><br><span class="line">        <span class="keyword">lock</span> (locker)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全，双重锁定"><a href="#线程安全，双重锁定" class="headerlink" title="线程安全，双重锁定"></a>线程安全，双重锁定</h3><p>上面代码对于每个线程都会对线程辅助对象<code>locker</code>加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（<code>uniqueInstance==null</code>）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能。</p><p>为了改进上面实现方式的缺陷，我们只需要在<code>lock</code>语句前面加一句（<code>uniqueInstance==null</code>）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它<strong><font color='red'>双重锁定</font></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span></span><br><span class="line">        <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">        <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span></span><br><span class="line">        <span class="comment">// 双重锁定只需要一句判断就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建造者模式（创造）"><a href="#建造者模式（创造）" class="headerlink" title="建造者模式（创造）"></a>建造者模式（创造）</h1><p><strong>建造者模式</strong>使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决：</strong>将变与不变分离开。</p><p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</p><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h2 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="http://imageshack.yuilexi.cn/Programming/设计模式/建造者模式.svg" alt="建造者模式"></p><p>情景如下：我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 _Item_ 接口和实现 _Item_ 接口的实体类，以及一个表示食物包装的 _Packing_ 接口和实现 _Packing_ 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>首先，构造两个接口，分别是包装和食物，其中食物里面包含有包装的实现。代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个食物的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line">    <span class="function">IPacking <span class="title">GetFoodPacking</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个包装的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetPackingType</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后构造两个具体的包装类，并继承自<code>IPacking</code>接口。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装：纸盒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Wrapper</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包装：瓶子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bottle</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于食物有两大类：汉堡和饮料，因此，这里不直接构造具体食物的类，而是先构造两个抽象类：汉堡和冷饮，然后再构造它们的子类：素食汉堡、鸡肉汉堡、可口可乐、百事可乐。在抽象类中，会具体实现包装类型的选择，而不是在具体的某一食物类中实现选择。具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//食物：抽象汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Burger</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//食物：抽象冷饮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ColdDrink</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造实现四种具体的食物类：素食汉堡类、鸡肉汉堡类、可口可乐类、百事可乐类。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//素食汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VegBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鸡肉汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChickenBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可口可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coke</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//百事可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pepsi</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，构造一个菜单管理的类<code>Meal</code>，该类可以实现的功能有：</p><ul><li>向菜单中添加具体的食物</li><li>计算出食物的价格</li><li>打印输出当前菜单的所有情况</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个套餐类，用于组合食物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Meal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IFood&gt; _foodList = <span class="keyword">new</span> List&lt;IFood&gt;();  <span class="comment">//创建一个列表，用于存储当前所有食物</span></span><br><span class="line">    <span class="comment">//向列表中添加食物的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFood</span>(<span class="params">IFood food</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._foodList.Add(food);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前套餐的总价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetCost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            cost += food.GetFoodPrice();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//展示当前套餐的所有食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowFood</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你的食物如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;食物: &#123;0&#125; ；&quot;</span>, food.GetFoodName());</span><br><span class="line">            Console.Write(<span class="string">&quot;包装: &#123;0&#125;；&quot;</span>, food.GetFoodPacking().GetPackingType());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;单价: &#123;0&#125;；&quot;</span>, food.GetFoodPrice());</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;总价：&#123;0&#125;&quot;</span>, GetCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的所有过程，均由售卖方执行，而作为顾客，只需要点餐就能获得对应的食物。这一部分在函数中进行，用于最终实现点餐的过程。具体代码如下;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Meal meal1 = <span class="keyword">new</span> Meal(); <span class="comment">//先生成一个菜单管理器实例</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> VegBurger()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> Coke()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.ShowFood();</span><br><span class="line">        Meal meal2 = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        meal2.ShowFood();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，结果如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你的食物如下：</span><br><span class="line">食物: Veg Burger ；包装: Wrapper；单价: <span class="number">25</span>；</span><br><span class="line">食物: Coke ；包装: Bottle；单价: <span class="number">30</span>；</span><br><span class="line">总价：<span class="number">55</span></span><br><span class="line">你的食物如下：</span><br><span class="line">食物: Chicken Burger ；包装: Wrapper；单价: <span class="number">50.5</span>；</span><br><span class="line">食物: Chicken Burger ；包装: Wrapper；单价: <span class="number">50.5</span>；</span><br><span class="line">食物: Pepsi ；包装: Bottle；单价: <span class="number">35</span>；</span><br><span class="line">总价：<span class="number">136</span></span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Meal meal1 = <span class="keyword">new</span> Meal(); <span class="comment">//先生成一个菜单管理器实例</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> VegBurger()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.AddFood(<span class="keyword">new</span> Coke()); <span class="comment">//向菜单管理器中添加食物</span></span><br><span class="line">        meal1.ShowFood();</span><br><span class="line">        Meal meal2 = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal2.AddFood(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        meal2.ShowFood();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个食物的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IPacking <span class="title">GetFoodPacking</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个包装的接口，方便后面继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetPackingType</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个套餐类，用于组合食物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Meal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IFood&gt; _foodList = <span class="keyword">new</span> List&lt;IFood&gt;();  <span class="comment">//创建一个列表，用于存储当前所有食物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//像列表中添加食物的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFood</span>(<span class="params">IFood food</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._foodList.Add(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前套餐的总价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetCost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            cost += food.GetFoodPrice();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示当前套餐的所有食物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowFood</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你的食物如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> food <span class="keyword">in</span> <span class="keyword">this</span>._foodList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;食物: &#123;0&#125; ；&quot;</span>, food.GetFoodName());</span><br><span class="line">            Console.Write(<span class="string">&quot;包装: &#123;0&#125;；&quot;</span>, food.GetFoodPacking().GetPackingType());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;单价: &#123;0&#125;；&quot;</span>, food.GetFoodPrice());</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;总价：&#123;0&#125;&quot;</span>, GetCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 构造两个具体的包装类，并继承自`IPacking`接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包装：纸盒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Wrapper</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wrapper&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装：瓶子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bottle</span> : <span class="title">IPacking</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetPackingType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bottle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span> 构造两个具体的包装类，并继承自`IPacking`接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 构造两个抽象的食物类，并继承自`IFood`接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//食物：抽象汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Burger</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//食物：抽象冷饮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ColdDrink</span> : <span class="title">IFood</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPacking <span class="title">GetFoodPacking</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span> 构造两个抽象的食物类，并继承自`IFood`接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 具体的食物类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//素食汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VegBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Veg Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡肉汉堡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChickenBurger</span> : <span class="title">Burger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chicken Burger&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可口可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coke</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Coke&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//百事可乐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pepsi</span> : <span class="title">ColdDrink</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">GetFoodName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pepsi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetFoodPrice</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span> 具体的食物类</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> Csharp </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构(C语言版)</title>
      <link href="/2023/04/30/UniversityStudy/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/04/30/UniversityStudy/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><p><strong>程序 = 数据结构 + 算法</strong> </p><h2 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h2><p>一般来说，用计算机解决一个具体问题，大致需要经过下列几个步骤：</p><ol><li>重具体问题中抽象出一个适当的数学模型</li><li>设计一个解数学模型的算法</li><li>编写程序，进行调试、调整直至得到最终答案</li></ol><p>但是有很多非数值问题无法用数学方程加以描述。例如：树、图等结构。</p><p>描述这类非数值计算问题的数学模型不再是数学方程，而是诸如表、树和图之类的数据结构。因此，简单来说，数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作的学科。</p><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><p><strong>数据</strong>：是对客观事物的符号表示，计算机科学中值所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p><strong>数据元素</strong>：是数据的基本单位。一个数据元素可由若干个<strong>数据项</strong>组成。<strong>数据项是数据不可分割的最小单位</strong>。数据元素是数据项的集合。</p><p><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的一个子集。</p><p><strong>数据结构</strong>：是相互之间存在一种或多种特定关系的数据元素的集合。数据之间的相互关系称为<strong>结构</strong>。</p><p>根据数据元素之间关系的不同特性，通常有以下 4 种基本结构：</p><ol><li>集合</li><li>线性结构</li><li>树形结构</li><li>图状结构或网状结构</li></ol><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><h3 id="1-4-1-算法"><a href="#1-4-1-算法" class="headerlink" title="1.4.1 算法"></a>1.4.1 算法</h3><p><strong>算法</strong>是对特定问题求解步骤的一种描述，它是指令的有限序列，每一条指令代表一个或多个操作。具有下列 5 个重要特性：</p><ol><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出</li></ol><h3 id="1-4-2-算法设计的要求"><a href="#1-4-2-算法设计的要求" class="headerlink" title="1.4.2 算法设计的要求"></a>1.4.2 算法设计的要求</h3><p>应考虑达到以下目标：</p><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储</li></ol><h3 id="1-4-3-算法效率的度量"><a href="#1-4-3-算法效率的度量" class="headerlink" title="1.4.3 算法效率的度量"></a>1.4.3 算法效率的度量</h3><p>算法执行时间需要依据该算法编制的程序在计算机上运行时所消耗的时间来度量。度量一个程序的执行时间，通常有两种方法：</p><ol><li><p>事后统计法</p></li><li><p>事前分析估算法</p><p> ​    一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素</p><ol><li>依据的算法选用何种策略</li><li>问题的规模</li><li>书写程序的语言</li><li>编译程序所产生的机器代码的质量</li><li>机器执行指令的速度</li></ol></li></ol><p>一般情况下，算法中基本操作重复执行的次数是问题规模 <script type="math/tex">n</script> 的某个函数 <script type="math/tex">f(n)</script> ，算法的事件量度记作</p><script type="math/tex; mode=display">T(n)=O(f(n))</script><p>它表示随问题规模 <script type="math/tex">n</script> 的增大，算法执行时间的增长率和 <script type="math/tex">f(n)</script> 的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p><h3 id="1-4-4-算法的存储空间要求"><a href="#1-4-4-算法的存储空间要求" class="headerlink" title="1.4.4 算法的存储空间要求"></a>1.4.4 算法的存储空间要求</h3><p>类似于算法的时间复杂度，以<strong>空间复杂度</strong>作为算法所需存储空间的量度，记作</p><script type="math/tex; mode=display">S(n)=O(f(n))</script><h1 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h1><h2 id="2-1-线性表的定义"><a href="#2-1-线性表的定义" class="headerlink" title="2.1 线性表的定义"></a>2.1 线性表的定义</h2><p><strong>线性表</strong>是最常用的且最简单的一种数据结构。简言之，一个线性表是 <script type="math/tex">n</script> 个数据元素的有限序列。例如：</p><script type="math/tex; mode=display">(A,B,C,D,\dots )</script><p>在稍微复杂的线性表中，一个数据元素可以有若干个<strong>数据项</strong>组成。在这种情况下，常把数据元素称为<strong>记录</strong>，含有大量记录的线性表又称为<strong>文件</strong>。</p><p><strong>算法 2.1</strong>：已知线性表 <script type="math/tex">LA</script> 和 <script type="math/tex">LB</script> 中的数据元素按值非递减有序排列，现要求将 <script type="math/tex">LA</script> 和 <script type="math/tex">LB</script> 归并为一个新的线性表 <script type="math/tex">LC</script> ，且 <script type="math/tex">LC</script> 中的数据元素也要按值非递减有序排列。假设，</p><script type="math/tex; mode=display">\begin{align}LA & = (3,5,8,11)\\LB&=(2,6,8,9,11,15,20)\end{align}</script><p>则</p><script type="math/tex; mode=display">LC = (2,3,5,6,8,8,9,11,11,15,20)</script><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> la, lb; <span class="comment">//数组长度</span></span><br><span class="line">    <span class="type">int</span> *LC;    <span class="comment">//指向新数组的指针</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> LA[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span> LB[] = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    la = (<span class="type">int</span>)(<span class="keyword">sizeof</span>(LA) / <span class="keyword">sizeof</span>(LA[<span class="number">0</span>])); <span class="comment">//计算数组长度</span></span><br><span class="line">    lb = (<span class="type">int</span>)(<span class="keyword">sizeof</span>(LB) / <span class="keyword">sizeof</span>(LB[<span class="number">0</span>])); <span class="comment">//计算数组长度</span></span><br><span class="line">    LC = (<span class="type">int</span> *)<span class="built_in">malloc</span>((la + lb) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span> (i &lt; la &amp;&amp; j &lt; lb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (LA[i] &lt; LB[j])</span><br><span class="line">        &#123;</span><br><span class="line">            LC[i + j] = LA[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LC[i + j] = LB[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; la)</span><br><span class="line">    &#123;</span><br><span class="line">        LC[i + j] = LA[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; lb)</span><br><span class="line">    &#123;</span><br><span class="line">        LC[i + j] = LB[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; la + lb; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, LC[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n程序结束！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">11</span> <span class="number">11</span> <span class="number">15</span> <span class="number">20</span> </span><br><span class="line">程序结束！</span><br></pre></td></tr></table></figure><h2 id="2-2-线性表的顺序表示和实现"><a href="#2-2-线性表的顺序表示和实现" class="headerlink" title="2.2 线性表的顺序表示和实现"></a>2.2 线性表的顺序表示和实现</h2><p>线性表的顺序表示指的是用一组地址连续的存储单元，依次存储线性表的数据元素。</p><p>假设线性表的每个元素需占用 <script type="math/tex">l</script> 个存储单元，应以所占的第一个单元的存储地址作为数据元素的存储位置。则线性表中第 <script type="math/tex">i+1</script> 个数据元素的存储位置为</p><script type="math/tex; mode=display">LOC(a_{i+1} ) = LOC(a_{i} )+l</script><p>一般来说，线性表的第 <script type="math/tex">i</script> 个数据元素 <script type="math/tex">a_{i}</script> 的存储位置为</p><script type="math/tex; mode=display">LOC(a_{i} ) = LOC(a_{1} )+(i-1)\times l</script><p>例如下面的代码，将展示线性表的地址排列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;一个int类型变量的长度（字节）为：%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;| %d &quot;</span>, &amp;number[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n程序结束！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个int类型变量的长度（字节）为：<span class="number">0</span></span><br><span class="line">| <span class="number">6422000</span> | <span class="number">6422004</span> | <span class="number">6422008</span> | <span class="number">6422012</span> | <span class="number">6422016</span> | <span class="number">6422020</span> | <span class="number">6422024</span> | <span class="number">6422028</span> | <span class="number">6422032</span> | <span class="number">6422036</span></span><br><span class="line"></span><br><span class="line">程序结束！</span><br></pre></td></tr></table></figure><p><strong>算法 2.3</strong> 线性表中插入元素，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">102</span>, <span class="number">114</span>&#125;;</span><br><span class="line">    <span class="comment">//输出插入前的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个元素，地址为%d，值为%d \n&quot;</span>, i, &amp;number[i], number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将102插入到数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (number[i] &gt; <span class="number">102</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">6</span>; j &gt;= i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                number[j + <span class="number">1</span>] = number[j];</span><br><span class="line">            &#125;</span><br><span class="line">            number[i] = <span class="number">102</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出插入后的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个元素，地址为%d，值为%d \n&quot;</span>, i, &amp;number[i], number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">0</span>个元素，地址为<span class="number">6422000</span>，值为<span class="number">1</span> </span><br><span class="line">第<span class="number">1</span>个元素，地址为<span class="number">6422004</span>，值为<span class="number">4</span></span><br><span class="line">第<span class="number">2</span>个元素，地址为<span class="number">6422008</span>，值为<span class="number">8</span></span><br><span class="line">第<span class="number">3</span>个元素，地址为<span class="number">6422012</span>，值为<span class="number">102</span></span><br><span class="line">第<span class="number">4</span>个元素，地址为<span class="number">6422016</span>，值为<span class="number">114</span></span><br><span class="line">第<span class="number">5</span>个元素，地址为<span class="number">6422020</span>，值为<span class="number">0</span></span><br><span class="line">第<span class="number">6</span>个元素，地址为<span class="number">6422024</span>，值为<span class="number">0</span></span><br><span class="line">第<span class="number">0</span>个元素，地址为<span class="number">6422000</span>，值为<span class="number">1</span></span><br><span class="line">第<span class="number">1</span>个元素，地址为<span class="number">6422004</span>，值为<span class="number">4</span></span><br><span class="line">第<span class="number">2</span>个元素，地址为<span class="number">6422008</span>，值为<span class="number">8</span></span><br><span class="line">第<span class="number">3</span>个元素，地址为<span class="number">6422012</span>，值为<span class="number">102</span></span><br><span class="line">第<span class="number">4</span>个元素，地址为<span class="number">6422016</span>，值为<span class="number">102</span></span><br><span class="line">第<span class="number">5</span>个元素，地址为<span class="number">6422020</span>，值为<span class="number">114</span></span><br><span class="line">第<span class="number">6</span>个元素，地址为<span class="number">6422024</span>，值为<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="2-3-线性表的链式表示和实现"><a href="#2-3-线性表的链式表示和实现" class="headerlink" title="2.3 线性表的链式表示和实现"></a>2.3 线性表的链式表示和实现</h2><p>线性表的顺序存储结构特点是逻辑关系上相邻的两个元素在物理位置上也相邻。然而，从另一方面来看，在做插入或删除操作时，需要移动大量的元素。因此我们将讨论线性表的另一种表示方法——链式存储结构，由于它不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但是同时也失去了顺序表可随机存取的优点。</p><h3 id="2-3-1-线性链表"><a href="#2-3-1-线性链表" class="headerlink" title="2.3.1 线性链表"></a>2.3.1 线性链表</h3><p>线性表的链式存储结构特点是：用一组<strong>任意</strong>的存储单元存储线性表的数据元素。除了存储本身外，还需要存储一个指示其直接后继的信息。这两部分信息组成的数据元素的存储映像，称为<strong>结点</strong>。它包含有两个域：</p><ul><li>存储数据元素的域称为<strong>数据域</strong></li><li>存储直接后继存储位置的域称为<strong>指针域</strong></li></ul><p>指针域中存储的信息称为<strong>指针或链</strong>。 $n$ 个结点链结成一个<strong>链表</strong>，即为线性表。</p><script type="math/tex; mode=display">(a_{1},a_{2},\dots ,a_{n} )</script><p>的<strong>链式存储结构</strong>。又有于此链表的每个节点中只包含一个指针域，故又称<strong>线性链表</strong>或<strong>单链表</strong>。</p><p><img src="https://imageshack.yuilexi.cn/University/数据结构/数据结构/链表.svg" alt="链表"></p><p>整个链表的存取必须从<strong>头指针</strong>开始进行，头指针指示链表中第一个结点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”，即<code>NULL</code>。</p><p>有时，我们在单链表的第一个结点之前附设一个结点，称之为<strong>头结点</strong>。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等类的附加信息，头结点的指针域存储指向第一个结点的指针。</p><hr><p><strong>算法 2.8</strong> ：构造链表数据为 <code>(1,2,6,56,214,543)</code>，像链表中添加元素<code>(100,200)</code>，删除元素<code>214</code>。</p><p>首先构造一个描述当前结点信息的结构体，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>构造一个：写一个输入数组，就能将数组转换为链表的方法<code>changeToList(int data[])</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组转化为链表</span></span><br><span class="line">Node *<span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head, *current;</span><br><span class="line">    head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;value = length;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;next = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        current-&gt;next-&gt;value = data[i];</span><br><span class="line">        current-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上述方法构造出来的链表，含有一个头结点，数据域存储当前链表的长度（不含头结点）。链表的长度为 $n$ ，但是表示的数据只有 $n-1$ 个。</p><p>构造一个：输出链表的方法<code>print(Node nodes)</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Node *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *current = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表的长度为：%d\n&quot;</span>, head-&gt;value);</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个：给定数据，删除链表对应元素的方法<code>void delete (Node *head, int value)</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表中按顺序删除一个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Node *head, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *current = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;next-&gt;value == value)</span><br><span class="line">        &#123;</span><br><span class="line">            current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    --(head-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在主函数中调用相关的方法，对前面所有的函数进行测试，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *<span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> length)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">(Node * head)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">insert</span><span class="params">(Node * head, <span class="type">int</span> value)</span>;</span><br><span class="line">    <span class="type">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">150</span>&#125;;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">delete</span> <span class="params">(Node * head, <span class="type">int</span> value)</span>;</span><br><span class="line">    Node *head = changeToList(data, <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]));</span><br><span class="line">    print(head);</span><br><span class="line">    insert(head, <span class="number">20</span>);</span><br><span class="line">    print(head);</span><br><span class="line">    delete (head, <span class="number">101</span>);</span><br><span class="line">    print(head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">链表的长度为：<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">34</span> <span class="number">100</span> <span class="number">101</span> <span class="number">150</span></span><br><span class="line">链表的长度为：<span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">20</span> <span class="number">34</span> <span class="number">100</span> <span class="number">101</span> <span class="number">150</span></span><br><span class="line">链表的长度为：<span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">20</span> <span class="number">34</span> <span class="number">100</span> <span class="number">150</span></span><br><span class="line">程序结束</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-2-循环链表"><a href="#2-3-2-循环链表" class="headerlink" title="2.3.2 循环链表"></a>2.3.2 循环链表</h3><p><strong>循环链表</strong>是一种链表数据结构，与普通链表的不同之处在于<strong>它的最后一个节点指向链表的第一个节点</strong>。</p><ul><li>这种结构的好处在于它可以轻松地实现循环遍历操作，因为它不需要特别处理链表的尾部节点。</li><li>它的缺点是比普通链表的操作要稍微复杂一些，因为需要特别处理第一个节点的前驱节点以及最后一个节点的后继节点。</li><li>另外，循环链表也需要注意避免出现死循环的情况。</li></ul><p><img src="http://imageshack.yuilexi.cn/University/数据结构/数据结构/循环链表.svg" alt="循环列表"></p><p>循环链表的操作和线性链表基本一致，差别仅在于<strong>算法中的循环条件不是<code>p == NULL</code>或者是<code>P-&gt;next == NULL</code>，而是是否等于头结点</strong>。</p><h3 id="2-3-3-双向链表"><a href="#2-3-3-双向链表" class="headerlink" title="2.3.3 双向链表"></a>2.3.3 双向链表</h3><p>前面讨论的节点中只有一个直接后记的指针域，因此，从某个节点出发，只能顺指针往后巡查其它节点。为克服单链表这种单向性的缺点，可利用<strong>双向链表</strong>。</p><p><img src="http://imageshack.yuilexi.cn/University/数据结构/数据结构/双向链表.svg" alt="双向链表"></p><h2 id="2-4-一元多项式的表示及相加"><a href="#2-4-一元多项式的表示及相加" class="headerlink" title="2.4 一元多项式的表示及相加"></a>2.4 一元多项式的表示及相加</h2><p><strong>符号多项式的操作，已经成为表处理的典型应用</strong>。在数学上，一个一元多项式 $P_{n} (x)$ 可按升幂写成：</p><script type="math/tex; mode=display">P_{n} (x) = p_{0} x^{0} +p_{1} x^{1} +p_{2} x^{2} +\dots +p_{n} x^{n}</script><p>它是由 $n+1$ 个系数唯一确定。因此在计算机里，它可以用一个线性表 $P$ 来表示：</p><script type="math/tex; mode=display">P=(p_{0},p_{1},p_{2},\dots ,p_{n} )</script><p>假设 $Q_{m}(x)$ 是一元 $m$ 次多项式，同样可用线性表 $Q$ 表示：</p><script type="math/tex; mode=display">Q=(q_{0},q_{1},q_{2},\dots ,q_{m} )</script><p>为了不失一般性，设 $m&lt;n$ ，则两个多项式相加的结果为可用线性表 $R$ 表示：</p><script type="math/tex; mode=display">R=(p_{0}+q_{0},p_{1}+q_{1},p_{2}+q_{2},\dots ,p_{m}+q_{m},p_{m+1},\dots ,p_{n} )</script><p>显然，我们可以对 $P,Q,R$ 采用顺序存储结构，使得多项式相加的算法定义的十分简单。然而，在通常的应用中，多项式的次数可能很高且变化很大，使得顺序存储结构的最大长度很难确定。例如下面形式：</p><script type="math/tex; mode=display">S(x)=1+3x^{10000} +2x^{20000}</script><p>的多项式时，就要用一长度为20001的线性表来表示，表中仅有三个非零元素，这种对存储空间的浪费时应当避免的。</p><p>因此，使用链表只存储非零的幂项元素，链表结点的数据域包含两个元素，当前的系数以及幂指数。</p><hr><p><strong>算法：多项式相加</strong>  现在有两个多项式，求出两个多项式的和。</p><p>首先，先构造结点的结构体元素。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">//幂指数</span></span><br><span class="line">    <span class="type">float</span> coef; <span class="comment">//系数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>然后构造一个将多项式元素的数组转化为链表的方法。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组转化为链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[][<span class="number">2</span>], <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head, *current;</span><br><span class="line">    head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;value = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;next = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        current-&gt;next-&gt;value = data[i][<span class="number">0</span>];</span><br><span class="line">        current-&gt;next-&gt;coef = data[i][<span class="number">1</span>];</span><br><span class="line">        current-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着构造一个将链表打印成多项式的方法。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印链表为多项式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Node *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *current = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;多项式为M(x) = &quot;</span>);</span><br><span class="line">    <span class="comment">//多项式第一项是不是常数，如果是常数，则不打印x^0。并且第一项系数为正时，不加+号</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;value == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;coef);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dx^%d &quot;</span>, current-&gt;coef, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%+dx^%d &quot;</span>, current-&gt;coef, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在主函数中，构造方法来实现多项式的相加。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">7</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">17</span>, <span class="number">5</span>&#125;&#125;; <span class="comment">//多项式A, 7x^0 + 3x^1 + 9x^8 + 5x^17</span></span><br><span class="line"><span class="type">int</span> B[][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">22</span>&#125;, &#123;<span class="number">8</span>, <span class="number">-9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *<span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[][<span class="number">2</span>], <span class="type">int</span> length)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">(Node * head)</span>;</span><br><span class="line">    Node *P, *Q;               <span class="comment">//多项式P和Q</span></span><br><span class="line">    Node *currentP, *currentQ; <span class="comment">//多项式P和Q的当前项</span></span><br><span class="line">    <span class="comment">// 1. 将数组转化为链表,并打印</span></span><br><span class="line">    P = changeToList(A, <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]));</span><br><span class="line">    Q = changeToList(B, <span class="keyword">sizeof</span>(B) / <span class="keyword">sizeof</span>(B[<span class="number">0</span>]));</span><br><span class="line">    print(P);</span><br><span class="line">    print(Q);</span><br><span class="line">    <span class="comment">// 2. 多项式相加</span></span><br><span class="line">    currentP = P;</span><br><span class="line">    currentQ = Q;</span><br><span class="line">    <span class="keyword">while</span> (currentP-&gt;next != <span class="literal">NULL</span> &amp;&amp; currentQ-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentP-&gt;next-&gt;value &lt; currentQ-&gt;next-&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            currentP = currentP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentP-&gt;next-&gt;value == currentQ-&gt;next-&gt;value)</span><br><span class="line">            &#123;</span><br><span class="line">                currentP-&gt;next-&gt;coef += currentQ-&gt;next-&gt;coef;</span><br><span class="line">                <span class="comment">//如果相加后系数为0，则删除该项，并释放内存</span></span><br><span class="line">                <span class="keyword">if</span> (currentP-&gt;next-&gt;coef == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *temp = currentP-&gt;next;</span><br><span class="line">                    currentP-&gt;next = currentP-&gt;next-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                currentP = currentP-&gt;next;</span><br><span class="line">                currentQ = currentQ-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp;</span><br><span class="line">                tmp = currentQ-&gt;next;</span><br><span class="line">                currentQ-&gt;next = currentQ-&gt;next-&gt;next;</span><br><span class="line">                tmp-&gt;next = currentP-&gt;next;</span><br><span class="line">                currentP-&gt;next = tmp;</span><br><span class="line">                currentP = currentP-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当多项式Q还有剩余，直接接到P后面</span></span><br><span class="line">    <span class="keyword">if</span> (currentQ-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        currentP-&gt;next = currentQ-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    print(P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多项式为M(x) = <span class="number">7</span> +<span class="number">3</span>x^<span class="number">1</span> +<span class="number">9</span>x^<span class="number">8</span> +<span class="number">5</span>x^<span class="number">17</span> </span><br><span class="line">多项式为M(x) = <span class="number">8</span>x^<span class="number">1</span> +<span class="number">22</span>x^<span class="number">7</span> <span class="literal">-9x</span>^<span class="number">8</span></span><br><span class="line">多项式为M(x) = <span class="number">7</span> +<span class="number">11</span>x^<span class="number">1</span> +<span class="number">22</span>x^<span class="number">7</span> +<span class="number">5</span>x^<span class="number">17</span></span><br><span class="line">程序结束!</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">//幂指数</span></span><br><span class="line">    <span class="type">int</span> coef;  <span class="comment">//系数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">7</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">17</span>, <span class="number">5</span>&#125;&#125;; <span class="comment">//多项式A, 7x^0 + 3x^1 + 9x^8 + 5x^17</span></span><br><span class="line"><span class="type">int</span> B[][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">22</span>&#125;, &#123;<span class="number">8</span>, <span class="number">-9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *<span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[][<span class="number">2</span>], <span class="type">int</span> length)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">(Node * head)</span>;</span><br><span class="line">    Node *P, *Q;               <span class="comment">//多项式P和Q</span></span><br><span class="line">    Node *currentP, *currentQ; <span class="comment">//多项式P和Q的当前项</span></span><br><span class="line">    <span class="comment">// 1. 将数组转化为链表,并打印</span></span><br><span class="line">    P = changeToList(A, <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]));</span><br><span class="line">    Q = changeToList(B, <span class="keyword">sizeof</span>(B) / <span class="keyword">sizeof</span>(B[<span class="number">0</span>]));</span><br><span class="line">    print(P);</span><br><span class="line">    print(Q);</span><br><span class="line">    <span class="comment">// 2. 多项式相加</span></span><br><span class="line">    currentP = P;</span><br><span class="line">    currentQ = Q;</span><br><span class="line">    <span class="keyword">while</span> (currentP-&gt;next != <span class="literal">NULL</span> &amp;&amp; currentQ-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentP-&gt;next-&gt;value &lt; currentQ-&gt;next-&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line">            currentP = currentP-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentP-&gt;next-&gt;value == currentQ-&gt;next-&gt;value)</span><br><span class="line">            &#123;</span><br><span class="line">                currentP-&gt;next-&gt;coef += currentQ-&gt;next-&gt;coef;</span><br><span class="line">                <span class="comment">//如果相加后系数为0，则删除该项，并释放内存</span></span><br><span class="line">                <span class="keyword">if</span> (currentP-&gt;next-&gt;coef == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node *temp = currentP-&gt;next;</span><br><span class="line">                    currentP-&gt;next = currentP-&gt;next-&gt;next;</span><br><span class="line">                    <span class="built_in">free</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                currentP = currentP-&gt;next;</span><br><span class="line">                currentQ = currentQ-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node *tmp;</span><br><span class="line">                tmp = currentQ-&gt;next;</span><br><span class="line">                currentQ-&gt;next = currentQ-&gt;next-&gt;next;</span><br><span class="line">                tmp-&gt;next = currentP-&gt;next;</span><br><span class="line">                currentP-&gt;next = tmp;</span><br><span class="line">                currentP = currentP-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当多项式Q还有剩余，直接接到P后面</span></span><br><span class="line">    <span class="keyword">if</span> (currentQ-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        currentP-&gt;next = currentQ-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    print(P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组转化为链表</span></span><br><span class="line">Node *<span class="title function_">changeToList</span><span class="params">(<span class="type">int</span> data[][<span class="number">2</span>], <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *head, *current;</span><br><span class="line">    head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;value = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;next = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        current-&gt;next-&gt;value = data[i][<span class="number">0</span>];</span><br><span class="line">        current-&gt;next-&gt;coef = data[i][<span class="number">1</span>];</span><br><span class="line">        current-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表为多项式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Node *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *current = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;多项式为M(x) = &quot;</span>);</span><br><span class="line">    <span class="comment">//多项式第一项是不是常数，如果是常数，则不打印x^0。并且第一项系数为正时，不加+号</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;value == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;coef);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%dx^%d &quot;</span>, current-&gt;coef, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%+dx^%d &quot;</span>, current-&gt;coef, current-&gt;value);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="三、栈和队列"><a href="#三、栈和队列" class="headerlink" title="三、栈和队列"></a>三、栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><h3 id="3-1-1-栈的定义"><a href="#3-1-1-栈的定义" class="headerlink" title="3.1.1 栈的定义"></a>3.1.1 栈的定义</h3><p><strong>栈</strong>（Stack）是一种特殊的线性表，<strong>它只能在表的一端进行插入和删除操作</strong>，这一端被称为<strong>栈顶（Top）</strong>，另一端被称为<strong>栈底（Bottom）</strong>。栈的特点是“<strong>先进后出</strong>”（Last In First Out，LIFO），即最后插入的元素最先被删除，而最先插入的元素最后被删除。栈在计算机科学中被广泛应用，例如函数调用、表达式求值、中缀表达式转后缀表达式等。</p><p><img src="http://imageshack.yuilexi.cn/University/数据结构/数据结构/栈的基本结构.svg" alt="栈的基本结构"></p><h3 id="3-1-2-栈的表示和实现"><a href="#3-1-2-栈的表示和实现" class="headerlink" title="3.1.2 栈的表示和实现"></a>3.1.2 栈的表示和实现</h3><p>栈也有两种存储表示方法。</p><ul><li>顺序栈。即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。</li><li>链栈。</li></ul><h2 id="3-2-栈的应用"><a href="#3-2-栈的应用" class="headerlink" title="3.2 栈的应用"></a>3.2 栈的应用</h2><p>（略）</p><h2 id="3-3-栈与递归的实现"><a href="#3-3-栈与递归的实现" class="headerlink" title="3.3 栈与递归的实现"></a>3.3 栈与递归的实现</h2><p>栈还有一个重要应用是在程序设计语言上实现递归</p><h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><h2 id="书籍信息"><a href="#书籍信息" class="headerlink" title="书籍信息"></a>书籍信息</h2><ol><li><p>数据结构（C语言版）</p><ul><li>编著：严蔚敏、吴伟民</li><li>出版社：清华大学出版社</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
          <category> C语言 </category>
          
          <category> 考研 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 考研 </tag>
            
            <tag> 大学学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/2023/04/30/Programming/Java%E7%9F%A5%E8%AF%86%E5%BA%93/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/30/Programming/Java%E7%9F%A5%E8%AF%86%E5%BA%93/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、认识Java"><a href="#一、认识Java" class="headerlink" title="一、认识Java"></a>一、认识Java</h1><p>Java 是目前软件设计中优秀的程序设计语言。不仅用来开发大型的应用程序，而且特别适合于Internet的应用开发，其已成为网络时代最重要的语言之一。</p><p>Java技术目前最活跃的领域大致分为两个大方向</p><ul><li>面向企业应用：旨在提升企业竞争力；</li><li>面向移动应用：旨在提供更多、更方便的个性化服务。</li></ul><p>Java 具有三方面的内涵：</p><ul><li>是一种编程语言</li><li>具有一套开发工具</li><li>具有一个运行环境</li></ul><h2 id="1-1-Java-简介"><a href="#1-1-Java-简介" class="headerlink" title="1.1 Java 简介"></a>1.1 Java 简介</h2><h3 id="1-1-1-Java-的特点"><a href="#1-1-1-Java-的特点" class="headerlink" title="1.1.1 Java 的特点"></a>1.1.1 Java 的特点</h3><ol><li><p>简单性</p><p> ​    语法简单，Java语言不使用指针，并提供了自动垃圾回收机制，使程序员无需担忧内存管理。</p></li><li><p>面向对象的程序设计语言</p></li><li><p>跨平台：一次编译到处运行</p><p> <img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/Java程序流.png" alt="Java程序流"></p></li><li><p>安全性</p><ol><li>要求显式的变量类型声明</li><li>不支持指针，杜绝了内存的非法访问</li><li>自动内存单元收集防止了内存泄露</li><li>可以自动发现数组和字符串的越界，防止堆栈溢出</li><li>提供了异常处理机制，简化错误处理任务</li><li><p>运行时环境还有类装载器，字节码校验器和安全管理器这三个组。</p><p><img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/Java运行环境.png" alt="Java运行环境"></p></li></ol></li><li><p>多线程性</p><ol><li>Java运行时环境本身就是多线程的。若干个系统线程运行负责必要的无用单元回收、系统维护等系统级操作；</li><li>另一方面，Java 语言内置多线程控制，可大大简化多线程应用程序开发。</li></ol></li><li><p>动态性</p><p> ​    Java程序执行时所需要调用的类在运行时动态地加载到内存中，这使得Java程序运行所需的内存开销小。可以被用于许多嵌入式系统。</p></li></ol><h3 id="1-1-2-跨平台原理"><a href="#1-1-2-跨平台原理" class="headerlink" title="1.1.2 跨平台原理"></a>1.1.2 跨平台原理</h3><ol><li>Java 编译器生成与特定体系结构无关的字节码指令，</li><li>Java运行时环境中的 Java 虚拟机（JVM：Java Virtual Machine）</li></ol><p><img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/Java运行环境.png" alt="Java运行环境"></p><p>JVM的内部体系结构：</p><p><img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/JVM的内部体系结构.png" alt="JVM的内部体系结构"></p><p>Java 有两种执行方式：</p><ul><li><strong>解释执行</strong>：逐条读入字节码，逐条解释成机器指令</li><li><strong>即时编译</strong>：JVM将解释后的字节码发给 JIT 编译器翻译成机器码，并保存起来以备再用。为了加快执行速度，只对经常使用的热代码编译。</li></ul><h2 id="1-2-Java-开发环境"><a href="#1-2-Java-开发环境" class="headerlink" title="1.2 Java 开发环境"></a>1.2 Java 开发环境</h2><h3 id="1-2-1-JDK"><a href="#1-2-1-JDK" class="headerlink" title="1.2.1 JDK"></a>1.2.1 JDK</h3><p>JDK：<strong>最基本的开发环境</strong>。</p><p>JDK：</p><ul><li>开发工具：主要是 JavaC 及基本核心类</li><li><strong>运行环境</strong>：JRE、JVM 及基本核心类</li><li><p>其他工具：Jar、Javadoc、Javah、Javap等</p><p> 按java的应用环境分如下版本：</p></li><li><p>JavaEE(java enterprise edition)</p><p>  ​    主要用于开发企业级分布式的网络程序，如电子商务网站和 ERP 系统，核心为 EJB 。Java EE 主要包括：</p><ul><li>Java SE</li><li>EnterpriceJavaBeans（EJB）</li><li>Java Servlets API </li><li>Java Server Pages（JSP）</li><li><p>Extensible Markup Language (XML)</p><p>​    当前主流架构(SSH)：Struts + Spring + Hibernate/Mybatis</p></li></ul></li><li><p>JavaSE(java stand edition)</p><p>  ​    主要用于桌面应用程序开发，是JAVA的基础。包含Java语言基础、JDBC数据库操作、I/O输入输出、网络通信、多线程等技术。</p></li><li><p>JavaME(java micro edition)</p><p>  ​    针对消费类的电子设备如掌上电脑、手机、汽车导航系统等。特点是：语言精简、运行环境高度优化。</p></li></ul><p>Windows操作系统下，JDK的项目结构如下：</p><p><img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/JDK项目结构.png" alt="JDK项目结构"></p><h3 id="1-2-2-配置环境变量"><a href="#1-2-2-配置环境变量" class="headerlink" title="1.2.2 配置环境变量"></a>1.2.2 配置环境变量</h3><p>什么是环境变量：</p><p>环境变量也称为系统变量，是由操作系统提供的一种与操作系统中运行的程序进行通信的机制，一般可为运行的程序提供配置信息。环境变量一般为“名字:值”对。在Shell编程中以${变量名}来取某变量的值</p><p><strong>常用的 Java 环境变量包括</strong>：</p><ul><li>JAVA_HOME</li><li>CLASSPATH</li><li>PATH</li></ul><p>在安装完JDK之后，为了能在任何目录中使用编译器和解释器，可在系统特性中设置环境变量：path、classpath</p><p>JDK 中常用的工具：</p><ul><li>JShell：JDK9出现的工具</li></ul><p><img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/JDK中常用的工具.png" alt="JDK中常用的工具"></p><h3 id="1-2-3-文本编辑器"><a href="#1-2-3-文本编辑器" class="headerlink" title="1.2.3 文本编辑器"></a>1.2.3 文本编辑器</h3><p>常用的 Java 文本编辑器有Notepad++、EditPlus、Sublime和Visual Studio等。</p><h3 id="1-2-4-目前主流集成开发平台"><a href="#1-2-4-目前主流集成开发平台" class="headerlink" title="1.2.4 目前主流集成开发平台"></a>1.2.4 目前主流集成开发平台</h3><ul><li><p>IBM公司: Eclipse/MyEclipse </p></li><li><p>Sun microsystem公司: Netbeans（GUI）  </p></li><li><p>IntelliJ IDEA</p></li><li><p>甲骨文：Oracle JDeveloper</p></li></ul><blockquote><p>此文档中所有Java代码的开发环境为：IntelliJ IDEA 2023.1</p></blockquote><h1 id="二、Java-语法基础"><a href="#二、Java-语法基础" class="headerlink" title="二、Java 语法基础"></a>二、Java 语法基础</h1><h2 id="2-1-Java-语法特点"><a href="#2-1-Java-语法特点" class="headerlink" title="2.1 Java 语法特点"></a>2.1 Java 语法特点</h2><h3 id="2-1-1-Java-程序结构"><a href="#2-1-1-Java-程序结构" class="headerlink" title="2.1.1 Java 程序结构"></a>2.1.1 Java 程序结构</h3><p>第一个 Java 程序，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJava_001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java程序是由一个或多个类组成的</p></li><li><p>类是由类首部、类体两大部分组成</p></li><li><p>类体定义了成员变量和方法</p><p>  ​    类的最简单定义如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 &#123;    <span class="comment">//类首部</span></span><br><span class="line">成员:  fields         <span class="comment">//成员变量，Java 中也称字段</span></span><br><span class="line">成员:  methods        <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  ​    </p><p>  ​    方法定义形式如下所示：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型  方法名 ([类型<span class="number">1</span> 形参<span class="number">1</span>, 类型<span class="number">2</span> 形参<span class="number">2</span>,…])&#123;  </span><br><span class="line">   局部变量;</span><br><span class="line">   方法体</span><br><span class="line">   语句或语句块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  ​    </p></li></ul><h3 id="2-1-2-Java-代码规范"><a href="#2-1-2-Java-代码规范" class="headerlink" title="2.1.2 Java 代码规范"></a>2.1.2 Java 代码规范</h3><ol><li>Java 是区分大小写的</li><li>Java 语句是最小的执行单位；每条语句以分号 “;” 结束</li><li>大括号{  }内的一系列语句称为语句块</li><li>Java源文件以“.java” 结尾，此文件中最多只能有一个类被声明为public，保存时源文件名需与public类名相同，如果文件中不存在public类，源文件名无要求</li><li>一个源文件包含几个类就可以编译出几个.class文件。</li><li>多个.java文件如果他们之间有调用关系，那么编译时只要编译主文件其他的关联文件也会一并被联合编译</li></ol><h3 id="2-1-3-注释"><a href="#2-1-3-注释" class="headerlink" title="2.1.3 注释"></a>2.1.3 注释</h3><ol><li>单行注释</li><li>多行注释</li><li>文档注释</li></ol><h3 id="2-1-4-关键字"><a href="#2-1-4-关键字" class="headerlink" title="2.1.4 关键字"></a>2.1.4 关键字</h3><div class="table-container"><table><thead><tr><th style="text-align:center">abstract</th><th style="text-align:center">boolean</th><th style="text-align:center">break</th><th style="text-align:center">byte</th><th style="text-align:center">case</th><th style="text-align:center">catch</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">class</td><td style="text-align:center">const *</td><td style="text-align:center">continue</td><td style="text-align:center">default</td><td style="text-align:center">do</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">else</td><td style="text-align:center">extends</td><td style="text-align:center">final</td><td style="text-align:center">finally</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">for</td><td style="text-align:center">goto *</td><td style="text-align:center">if</td><td style="text-align:center">implements</td><td style="text-align:center">import</td><td style="text-align:center">instanceof</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">interface</td><td style="text-align:center">long</td><td style="text-align:center">native</td><td style="text-align:center">new</td><td style="text-align:center">package</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">protected</td><td style="text-align:center">public</td><td style="text-align:center">return</td><td style="text-align:center">short</td><td style="text-align:center">static</td></tr><tr><td style="text-align:center">strictfp **</td><td style="text-align:center">super</td><td style="text-align:center">switch</td><td style="text-align:center">synchronized</td><td style="text-align:center">this</td><td style="text-align:center">throw</td></tr><tr><td style="text-align:center">throws</td><td style="text-align:center">transient</td><td style="text-align:center">try</td><td style="text-align:center">void</td><td style="text-align:center">volatile</td><td style="text-align:center">while</td></tr></tbody></table></div><blockquote><p>注: <em>当前未被使用，*</em>使用于Java2</p></blockquote><h3 id="2-1-5-标识符"><a href="#2-1-5-标识符" class="headerlink" title="2.1.5 标识符"></a>2.1.5 标识符</h3><p>标识：常量、变量、数据类型、类和方法。</p><p>组成规则：</p><ul><li>字母(A~Z、a~z)、特殊符号($、_)和数字(0~9)</li><li>开头不能是数字</li><li>不能为关键词：true、false、null</li><li>大小写敏感</li></ul><p>一般约定：</p><ul><li>表示常量的标识符全部大写，如RED</li><li>表示类名的标识符用 Pascal 命名规范</li><li>表示公有方法和实例变量的标识符用小写字母开始（小驼峰命名法）</li><li>表示私有或局部变量的标识符全部用小写字母，如next_value</li></ul><p>空白符：空格、换行符、制表符</p><p>分号：表示语句结束，或用于for循环语句中</p><p>逗号：变量之间的分隔</p><p>冒号：? : /switch循环中的case语句</p><p>花括号：类体、方法体、复合语句(for/while/switch/if)</p><h2 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h2><h3 id="2-2-1数据类型"><a href="#2-2-1数据类型" class="headerlink" title="2.2.1数据类型"></a>2.2.1数据类型</h3><p>值类型</p><p>内置的基本数据类型如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th><th style="text-align:center">范围</th><th style="text-align:center">表示法</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8 位、有符号、二进制补码表示的整数</td><td style="text-align:center">-128 ~ 127</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16 位、有符号、二进制补码表示的整数</td><td style="text-align:center">-32768 ~ 32767</td><td style="text-align:center">321</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32位、有符号的、二进制补码表示的整数</td><td style="text-align:center">-2^31 ~ 2^31-1</td><td style="text-align:center">412</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64 位、有符号、二进制补码表示的整数</td><td style="text-align:center">-2^63 ~ 2^63-1</td><td style="text-align:center">3219L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">单精度、32位、符合IEEE 754标准的浮点数</td><td style="text-align:center"></td><td style="text-align:center">0.0f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">双精度、64 位、符合 IEEE 754 标准的浮点数</td><td style="text-align:center"></td><td style="text-align:center">0.0d</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">表示一位的信息</td><td style="text-align:center">true 和 false</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">一个单一的 16 位 Unicode 字符</td><td style="text-align:center"></td></tr></tbody></table></div><p>引用类型：</p><ul><li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。变量一旦声明后，类型就不能被改变了。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li></ul><h3 id="2-2-2-类型转换"><a href="#2-2-2-类型转换" class="headerlink" title="2.2.2 类型转换"></a>2.2.2 类型转换</h3><p>将一种类型的数据转换为另一种类型的数据</p><ul><li><p>操作数转换为同种类型，然后运算</p></li><li><p>整数型、实数型和字符型</p></li><li><p>表达形式:  (类型) 操作数</p></li></ul><p>两种方法</p><ol><li><p>隐型类型转换:：自动类型转换(系统完成)</p><p> ​    宽化转换(widening conversion)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> j=<span class="number">60</span>; </span><br><span class="line"><span class="type">short</span> k=<span class="number">4</span>; </span><br><span class="line"><span class="type">int</span> l=<span class="number">31</span>; </span><br><span class="line"><span class="type">long</span> m=<span class="number">4l</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> result=<span class="number">0l</span>;</span><br><span class="line">result +=j-<span class="number">8</span>;</span><br><span class="line">result *=k+<span class="number">2</span>;</span><br><span class="line">result /=m+<span class="number">1</span>;</span><br><span class="line">result -=l;</span><br><span class="line">result %=m;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>显型类型转换: 强制类型转换</p><p> ​    窄化转换 (narrowing conversion)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.5</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br><span class="line">System.out.println(“b=<span class="string">&quot; + b);</span></span><br></pre></td></tr></table></figure><p> ​    编译: “possible loss of precision”。数据精度丢失→数据丢失</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">float</span>)a;</span><br><span class="line"></span><br><span class="line">System.out.println(“b=<span class="string">&quot; + b);</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-运算符与表达式"><a href="#2-3-运算符与表达式" class="headerlink" title="2.3 运算符与表达式"></a>2.3 运算符与表达式</h2><h3 id="2-3-1-算数运算符"><a href="#2-3-1-算数运算符" class="headerlink" title="2.3.1 算数运算符"></a>2.3.1 算数运算符</h3><p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:left">加法 - 相加运算符两侧的值</td><td style="text-align:left">A + B 等于 30</td></tr><tr><td style="text-align:center">-</td><td style="text-align:left">减法 - 左操作数减去右操作数</td><td style="text-align:left">A – B 等于 -10</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">乘法 - 相乘操作符两侧的值</td><td style="text-align:left">A * B等于200</td></tr><tr><td style="text-align:center">/</td><td style="text-align:left">除法 - 左操作数除以右操作数</td><td style="text-align:left">B / A等于2</td></tr><tr><td style="text-align:center">％</td><td style="text-align:left">取余 - 左操作数除以右操作数的余数</td><td style="text-align:left">B%A等于0</td></tr><tr><td style="text-align:center">++</td><td style="text-align:left">自增: 操作数的值增加1</td><td style="text-align:left">B++ 或 ++B 等于 21</td></tr><tr><td style="text-align:center">—</td><td style="text-align:left">自减: 操作数的值减少1</td><td style="text-align:left">B— 或 —B 等于 19</td></tr></tbody></table></div><p><strong>自增自减运算符</strong>：</p><ol><li>自增（++）自减（—）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</li><li>前缀自增自减法(++a,—a)： 先进行自增或者自减运算，再进行表达式运算。</li><li>后缀自增自减法(a++,a—)：先进行表达式运算，再进行自增或者自减运算 </li></ol><h3 id="2-3-2-关系运算符"><a href="#2-3-2-关系运算符" class="headerlink" title="2.3.2 关系运算符"></a>2.3.2 关系运算符</h3><p>表格中的实例整数变量A的值为10，变量B的值为20：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td style="text-align:left">（A == B）为假。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td style="text-align:left">(A != B) 为真。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td style="text-align:left">（A&gt; B）为假。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td style="text-align:left">（A &lt;B）为真。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td style="text-align:left">（A&gt; = B）为假。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td style="text-align:left">（A &lt;= B）为真。</td></tr></tbody></table></div><h3 id="2-3-3-位运算符"><a href="#2-3-3-位运算符" class="headerlink" title="2.3.3 位运算符"></a>2.3.3 位运算符</h3><p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center">＆</td><td style="text-align:left">如果相对应位都是1，则结果为1，否则为0</td><td style="text-align:left">（A＆B），得到12，即0000 1100</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">如果相对应位都是 0，则结果为 0，否则为 1</td><td style="text-align:left">（A&#124;B）得到61，即 0011 1101</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">如果相对应位值相同，则结果为0，否则为1</td><td style="text-align:left">（A ^ B）得到49，即 0011 0001</td></tr><tr><td style="text-align:center">〜</td><td style="text-align:left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td style="text-align:left">（〜A）得到-61，即1100 0011</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td style="text-align:left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td style="text-align:left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td style="text-align:center">&gt;&gt;&gt;</td><td style="text-align:left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td style="text-align:left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table></div><h3 id="2-3-4-逻辑运算符"><a href="#2-3-4-逻辑运算符" class="headerlink" title="2.3.4 逻辑运算符"></a>2.3.4 逻辑运算符</h3><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td style="text-align:left">（A &amp;&amp; B）为假。</td></tr><tr><td style="text-align:center">&#124;&#124;</td><td style="text-align:left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td style="text-align:left">（A&#124;&#124; B）为真。</td></tr><tr><td style="text-align:center">！</td><td style="text-align:left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td style="text-align:left">！（A &amp;&amp; B）为真。</td></tr></tbody></table></div><h3 id="2-3-5-赋值运算符"><a href="#2-3-5-赋值运算符" class="headerlink" title="2.3.5 赋值运算符"></a>2.3.5 赋值运算符</h3><p>下面是Java语言支持的赋值运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td style="text-align:left">C = A + B将把A + B得到的值赋给C</td></tr><tr><td style="text-align:center">+ =</td><td style="text-align:left">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td style="text-align:left">C + = A等价于C = C + A</td></tr><tr><td style="text-align:center">- =</td><td style="text-align:left">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td style="text-align:left">C - = A等价于C = C - A</td></tr><tr><td style="text-align:center">* =</td><td style="text-align:left">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td style="text-align:left">C <em> = A等价于C = C </em> A</td></tr><tr><td style="text-align:center">/ =</td><td style="text-align:left">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td style="text-align:left">C / = A，C 与 A 同类型时等价于 C = C / A</td></tr><tr><td style="text-align:center">（％）=</td><td style="text-align:left">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td style="text-align:left">C％= A等价于C = C％A</td></tr><tr><td style="text-align:center">&lt;&lt; =</td><td style="text-align:left">左移位赋值运算符</td><td style="text-align:left">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td style="text-align:center">&gt;&gt; =</td><td style="text-align:left">右移位赋值运算符</td><td style="text-align:left">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td style="text-align:center">＆=</td><td style="text-align:left">按位与赋值运算符</td><td style="text-align:left">C＆= 2等价于C = C＆2</td></tr><tr><td style="text-align:center">^ =</td><td style="text-align:left">按位异或赋值操作符</td><td style="text-align:left">C ^ = 2等价于C = C ^ 2</td></tr><tr><td style="text-align:center">&#124;=</td><td style="text-align:left">按位或赋值操作符</td><td style="text-align:left">C &#124;= 2等价于C = C \</td><td>2</td></tr></tbody></table></div><h3 id="2-3-6-其他运算符"><a href="#2-3-6-其他运算符" class="headerlink" title="2.3.6 其他运算符"></a>2.3.6 其他运算符</h3><ol><li><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">variable</span> <span class="variable">x</span> <span class="operator">=</span> (expression) ? value <span class="keyword">if</span> <span class="literal">true</span> : value <span class="keyword">if</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>instanceof 运算符。该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Object reference variable) <span class="keyword">instanceof</span>  (class/<span class="keyword">interface</span> <span class="title class_">type</span>)</span><br></pre></td></tr></table></figure><p> ​    </p></li></ol><h3 id="2-3-7-运算优先级"><a href="#2-3-7-运算优先级" class="headerlink" title="2.3.7 运算优先级"></a>2.3.7 运算优先级</h3><p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">操作符</th><th style="text-align:left">关联性</th></tr></thead><tbody><tr><td style="text-align:left">后缀</td><td style="text-align:left">() [] . (点操作符)</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">一元</td><td style="text-align:left">expr++ expr—</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">一元</td><td style="text-align:left">++expr —expr + - ～ ！</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">乘性</td><td style="text-align:left">* /％</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">加性</td><td style="text-align:left">+ -</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&gt; &gt;= &lt; &lt;=</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">相等</td><td style="text-align:left">== !=</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">按位与</td><td style="text-align:left">＆</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">按位异或</td><td style="text-align:left">^</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">按位或</td><td style="text-align:left">&#124;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">逻辑与</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">逻辑或</td><td style="text-align:left">&#124;&#124;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">？：</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">赋值</td><td style="text-align:left">= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = &#124; =</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">逗号</td><td style="text-align:left">，</td><td style="text-align:left">左到右</td></tr></tbody></table></div><h3 id="2-3-8-表达式"><a href="#2-3-8-表达式" class="headerlink" title="2.3.8 表达式"></a>2.3.8 表达式</h3><ul><li><p>算术表达式</p><p>  ​    数字或变量进行算术运算，本质上还是一个数。</p></li><li><p>赋值表达式</p><p>  ​    作用：将<strong>赋值运算符</strong>右边量的值（或者算术表达式的值），赋给左边的变量。</p></li><li><p>逻辑表达式</p><p>  ​    逻辑表达式，其本身相当于一个 boolean 类型的变量。根据具体情况，表达式会取 true 或者 false 。</p></li></ul><h2 id="2-4-常量与变量"><a href="#2-4-常量与变量" class="headerlink" title="2.4 常量与变量"></a>2.4 常量与变量</h2><h3 id="2-4-1-常量"><a href="#2-4-1-常量" class="headerlink" title="2.4.1 常量"></a>2.4.1 常量</h3><p>程序执行过程中，值保持不变的量，称为<strong>常量</strong>。常量有以下类型：整型常量、实型常量、布尔型常量、字符型常量、字符串常量</p><h3 id="2-4-2-变量"><a href="#2-4-2-变量" class="headerlink" title="2.4.2 变量"></a>2.4.2 变量</h3><p>程序执行过程中，值可以改变的量，称为<strong>变量</strong>。整型变量、实型变量、字符型变量、字符串变量、布尔变量等。</p><p>变量定义语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 变量名[ = 初值];</span><br><span class="line"><span class="comment">//For example</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-变量的作用域"><a href="#2-4-3-变量的作用域" class="headerlink" title="2.4.3 变量的作用域"></a>2.4.3 变量的作用域</h3><p>变量的使用范围，一般如下图所示：</p><p><img src="https://imageshack.yuilexi.cn/Programming/Java知识库/Java基础语法/变量的作用域.png" alt="变量的作用域"></p><p>作用域(Scope)：在当前大括号 “{ }” 中声明的变量，作用范围只有大括号以内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJava_001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，就会出现一下错误：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java: 找不到符号</span><br><span class="line">  符号:   变量 a</span><br><span class="line">  位置: 类 MyJava_001</span><br></pre></td></tr></table></figure><p><strong><font color='red'>final变量</font></strong>：带有关键字final的变量。final 变量初始化后不能再改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//a = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行，程序不会报错。但是如果把注释的语句加上，那么程序就会抛出以下错误：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java: 可能已分配变量a</span><br></pre></td></tr></table></figure><h2 id="2-5-基本输入输出"><a href="#2-5-基本输入输出" class="headerlink" title="2.5 基本输入输出"></a>2.5 基本输入输出</h2><h3 id="2-5-1-Java-输出"><a href="#2-5-1-Java-输出" class="headerlink" title="2.5.1 Java 输出"></a>2.5.1 Java 输出</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();</span><br><span class="line">System.out.print();</span><br><span class="line">System.out.printf();</span><br></pre></td></tr></table></figure><p>说明如下：</p><ul><li>System 是一个类</li><li>out 是一个public static字段：它接受输出数据</li></ul><p>println()，print()和printf()之间的区别</p><ul><li>print() ：它在引号内打印字符串。</li><li>println() ：它在引号内打印字符串，类似于print()方法。然后光标移动到下一行的开头。</li><li>printf() ：Tt提供<strong>字符串格式化</strong>（类似于C / C ++编程中的printf）</li></ul><h3 id="2-5-2-Java-输入"><a href="#2-5-2-Java-输入" class="headerlink" title="2.5.2 Java 输入"></a>2.5.2 Java 输入</h3><p>Java提供了不同的方法来从用户那里获取输入。但是，您将学习使用Scanner类的对象从用户那里获取输入。</p><p>为了使用的对象Scanner，我们需要导入java.util.Scanner包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure><p>然后，我们需要创建Scanner类对象。我们可以使用该对象从用户那里获取输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Scanner对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//接受用户的输入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n你输入的是：&quot;</span>+ number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>System.in：对象读数据的基本单位是一个字节，可用方法System.in.read()顺序读入一个字节，或利用方法 System.in.read(byte b[],int off,int length) 连续读入多个字节。用户程序通常需要将字节数据解析成不同类型的数据进行处理。</p><p>为了简化这部分工作，可以用 Scanner 对象将字节流转化成基本数据类型</p><h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><h2 id="3-1-选择结构"><a href="#3-1-选择结构" class="headerlink" title="3.1 选择结构"></a>3.1 选择结构</h2><h3 id="3-1-1-单-if-语句"><a href="#3-1-1-单-if-语句" class="headerlink" title="3.1.1 单 if 语句"></a>3.1.1 单 if 语句</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)</span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-if…else-语句"><a href="#3-1-2-if…else-语句" class="headerlink" title="3.1.2 if…else 语句"></a>3.1.2 if…else 语句</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，下面代码;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isChild</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isChild)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是孩子。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printfIn(<span class="string">&quot;我不是孩子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-switch-语句"><a href="#3-1-3-switch-语句" class="headerlink" title="3.1.3 switch 语句"></a>3.1.3 switch 语句</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:  语句序列; [<span class="keyword">break</span>;]</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:  语句序列; [<span class="keyword">break</span>;]</span><br><span class="line">        ......</span><br><span class="line">    [<span class="keyword">default</span>: 默认语句;]</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure><h2 id="3-2-循环结构"><a href="#3-2-循环结构" class="headerlink" title="3.2 循环结构"></a>3.2 循环结构</h2><h3 id="3-2-1-while-循环"><a href="#3-2-1-while-循环" class="headerlink" title="3.2.1 while 循环"></a>3.2.1 while 循环</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(逻辑表达式)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-do-while-循环"><a href="#3-2-2-do-while-循环" class="headerlink" title="3.2.2 do-while 循环"></a>3.2.2 do-while 循环</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(逻辑表达式)</span><br></pre></td></tr></table></figure><h3 id="3-2-3-for-循环"><a href="#3-2-3-for-循环" class="headerlink" title="3.2.3 for 循环"></a>3.2.3 for 循环</h3><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(赋值表达式;逻辑表达式;赋值表达式)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环的几点注意</p><ul><li><p>初始化部分和迭代因子可以包含多个语句，以“,”分开</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">10</span>; i&lt;j; i++, j--) &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ​    </p></li><li><p>初始化部分、条件判断部分和迭代因子可以为空语句，但以“;”分开，表示无限循环</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;  <span class="comment">// infinite loop</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ​    </p></li></ul><h3 id="3-2-4-增强-for-循环（for-each）"><a href="#3-2-4-增强-for-循环（for-each）" class="headerlink" title="3.2.4 增强 for 循环（for-each）"></a>3.2.4 增强 for 循环（for-each）</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。语法格式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-程序跳转语句"><a href="#3-3-程序跳转语句" class="headerlink" title="3.3 程序跳转语句"></a>3.3 程序跳转语句</h2><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。</p><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p><p>return：方法返回</p><p>throw：抛出异常(Exception)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h1 id="四、复杂数据类型"><a href="#四、复杂数据类型" class="headerlink" title="四、复杂数据类型"></a>四、复杂数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组是一组<strong>同类型</strong>的变量或对象的集合。</p><ul><li>数组的类型可以是基本类型，或类和接口</li><li>数组中<strong>每个元素的类型相同</strong></li><li>引用数组元素通过数组名[下标]</li><li>数组下标(数组的索引)从0开始</li></ul><p>数组是一种特殊的对象(Object)</p><ul><li>定义类型 (声明)</li><li>创建数组 (分配内存空间) : new</li><li>释放 (Java虚拟机完成)</li></ul><p>一维数组、多维数组</p><h3 id="4-1-1-一维数组的创建——new关键字"><a href="#4-1-1-一维数组的创建——new关键字" class="headerlink" title="4.1.1 一维数组的创建——new关键字"></a>4.1.1 一维数组的创建——<font color='red'>new</font>关键字</h3><p>一维数组的元素只有一个下标变量。例如：整型数组 A[] </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] scores;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的分数是：&quot;</span>,scores);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，上述代码会报错，因为 Java 数组在声明时，并没有为其分配内存空间。</p><p>数组的创建：用 <font color='red'>new</font> 来创建数组，为数组元素分配内存空间，并对数组元素进行初始化。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名 = <span class="keyword">new</span> 类型[数组长度];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-数组的初始化"><a href="#4-1-2-数组的初始化" class="headerlink" title="4.1.2 数组的初始化"></a>4.1.2 数组的初始化</h3><ol><li><p>对每个元素初始化</p><p> ​    例如下面你代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;a&lt;<span class="number">5</span>;a++)&#123;</span><br><span class="line">            scores[a] = <span class="number">90</span> + a;</span><br><span class="line">            System.out.println(scores[a]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>整体初始化</p><p> ​    例如下面的代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;a&lt;<span class="number">5</span>;a++)&#123;</span><br><span class="line">            System.out.println(scores[a]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​    </p></li></ol><h3 id="4-1-3-数组的操作"><a href="#4-1-3-数组的操作" class="headerlink" title="4.1.3 数组的操作"></a>4.1.3 数组的操作</h3><ol><li><p>一维数组的复制</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java学习的代码测试;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 数组复制 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] b;</span><br><span class="line">        <span class="type">int</span>[] c = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        b = a;</span><br><span class="line">        System.arraycopy(a, <span class="number">1</span>, c, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;b数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;c数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            System.out.print(c[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​    直接用等号进行复制，其实是赋给等号左边一个引用，二者共用一块内存空间。</p><p> ​    <code>System.arraycopy(A[],int b, C[], int d, int l)</code>说明：</p><ul><li>将数组 A 从 A[b] 开始的 l 个元素赋给数组C的 C[d]开始的后 l 个元素</li></ul></li></ol><h3 id="4-1-4-多维数组"><a href="#4-1-4-多维数组" class="headerlink" title="4.1.4 多维数组"></a>4.1.4 多维数组</h3><p>多维数组的声明、创建、调用等与一维数组类似。</p><h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><h1 id="五、面向对象程序设计——类"><a href="#五、面向对象程序设计——类" class="headerlink" title="五、面向对象程序设计——类"></a>五、面向对象程序设计——类</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>面向对象(Object Oriented-OO) </p><ul><li>面向对象编程(Object Oriented Programming-OOP)</li><li>面向对象是一种软件开发的方法，</li></ul><p>第一个面向对象的语言: Simula-67。第一个成功的面向对象编程语言: Smalltalk。目前的主流：C++, JAVA, C#等</p><ol><li>用客观世界中描述事物的方法来描述程序中要解决的问题</li><li>万事万物都是对象</li><li>程序便是成堆的对象，彼此通过消息的传递，请求其他对象进行工作 </li></ol><p><strong>五个基本概念：对象、类、封装性、继承性、多态性</strong></p><h2 id="5-2-类的定义"><a href="#5-2-类的定义" class="headerlink" title="5.2 类的定义"></a>5.2 类的定义</h2><h3 id="5-2-1-类的基本格式"><a href="#5-2-1-类的基本格式" class="headerlink" title="5.2.1 类的基本格式"></a>5.2.1 类的基本格式</h3><p>类的定义的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 [extends 父类] implements [接口]&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    成员方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类的修饰符(modifier)<ul><li>public：公共类，可以被其他任何类所使用</li><li>无修饰/默认：仅能被同一个包中的其他类引用</li><li>abstract：抽象类，不能被实例化/即创建对象</li><li>final：最终类不能被继承</li></ul></li><li>extends：一个类继承另一个类</li><li>implements：一个类实现一些接口(interface)的方法，用以变相实现多重继承</li></ul><h3 id="5-2-2-Package-包的概念"><a href="#5-2-2-Package-包的概念" class="headerlink" title="5.2.2 Package/包的概念"></a>5.2.2 Package/包的概念</h3><p>包(Package)的概念</p><ul><li>通过包来管理命名空间(naming space)</li><li>防止同名的类发生冲突</li><li>形成层次化的结构，便于管理</li></ul><h3 id="5-2-3-类的成员"><a href="#5-2-3-类的成员" class="headerlink" title="5.2.3 类的成员"></a>5.2.3 类的成员</h3><p>对象具有<strong>状态</strong>和<strong>行为</strong>。</p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> Java基础语法 </tag>
            
            <tag> 服务器开发 </tag>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程-线程-协程</title>
      <link href="/2023/04/30/Unity3D/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2023/04/30/Unity3D/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h1><h2 id="1-1-进程的概念和特征"><a href="#1-1-进程的概念和特征" class="headerlink" title="1.1 进程的概念和特征"></a>1.1 进程的概念和特征</h2><h3 id="1-1-1-进程的定义"><a href="#1-1-1-进程的定义" class="headerlink" title="1.1.1 进程的定义"></a>1.1.1 进程的定义</h3><p>进程是程序的一次执行过程。进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p><p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单元。<strong>每个进程都有自己的独立内存空间</strong>，<strong>不同进程间可以进行进程间通信</strong>。进程<strong>重量级比较大</strong>，占据独立内存，上下文进程间的切换开销（栈寄存器、虚拟内存、文件句柄）比较大，但相对稳定安全。进程的上级为操作系统，有自己固定的堆栈。</p><h3 id="1-1-2-进程的特征"><a href="#1-1-2-进程的特征" class="headerlink" title="1.1.2 进程的特征"></a>1.1.2 进程的特征</h3><p><strong>动态性</strong>：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。<strong>动态性是进程最基本的特征</strong>。</p><p><strong>并发性</strong>：指多个进程实体同时存于内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。</p><p><strong>独立性</strong>：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单元。凡未建立 PCB 的程序都不能作为一个独立的单元参与运行。</p><p><strong>异步性</strong>：由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</p><p><strong>结构性</strong>：每个进程都配置一个 PCB 对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制块三部分组成的。</p><h2 id="1-2-进程的状态和转换"><a href="#1-2-进程的状态和转换" class="headerlink" title="1.2 进程的状态和转换"></a>1.2 进程的状态和转换</h2><p><strong>运行态</strong>：进程正在处理机上运行。在单机处理机环境下，每个时刻最多只有一个进程处于运行态。</p><p><strong>就绪态</strong>：进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将他们排成一个队列，成为<strong>就绪队列</strong>。</p><p><strong>阻塞态</strong>：又称等待态。进程正在等待某一事件而暂定运行，如等待某资源为可用或等待输入/输出完成。<strong>即使处理机空闲，该进程也不能运行</strong>。</p><p><strong>创建态</strong>：进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤：首先申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，然后由系统为该进程分配运行时所必须的资源，最后把该进程转入就绪态。</p><p><strong>结束态</strong>：进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须置该进程为结束态，然后再进一步处理资源释放和回收等工作。</p><p><img src="https://imageshack.yuilexi.cn/Unity3D/Csharp-Unity脚本开发/进程-线程-协程/进程的状态转换.svg" alt="进程的状态转换"></p><h3 id="1-3-进程的通信"><a href="#1-3-进程的通信" class="headerlink" title="1.3 进程的通信"></a>1.3 进程的通信</h3><p>进程间通信通常有以下几种方式：</p><p><strong>管道（Pipe）</strong>：管道是 Unix 中最古老的进程间通信的形式，我们把从一个进程连接到另一个进程的一个数据流称为一个“管道”。其本质是内核中固定大小的缓冲区。</p><p><strong>命名管道（Named Pipes）</strong>：“命名管道”又名“命名管线”（Named Pipes），命名管道支持可靠的、单向或双向的数据通信。不同于匿名管道的是：命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p><p><strong>消息队列（MQ，Message Quene）</strong>：消息队列用于在进程间通信的过程中将消息按照队列存储起来，常见的 MQ 有 ActiveMQ、RocketMQ、RabbitMQ、Kafka 等。</p><p><strong>信号量（Semaphore）</strong>：有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前,线程必须获取一个信号量。</p><p><strong>共享内存（Share Memory）</strong>：共享内存是三个 IPC 机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。</p><p><strong>套接字（Socket）</strong>：就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。</p><p>对于游戏开发者来说，最为常用的是 Socket，这是长连接网络游戏的核心。</p><h1 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h1><h2 id="2-1-线程的概念"><a href="#2-1-线程的概念" class="headerlink" title="2.1 线程的概念"></a>2.1 线程的概念</h2><p><img src="https://imageshack.yuilexi.cn/Unity3D/Csharp-Unity脚本开发/进程-线程-协程/进程与线程的关系.svg" alt="进程与线程的关系"></p><p>线程也被称为轻量级进程，是操作系统调度（CPU 调度）执行的最小单位，是进程的子集，是进程中实际运作单位。一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每个线程并行执行不同的任务。</p><p>线程本身基本不拥有资源，而是访问隶属于进程的资源，一个进程拥有至少一个或多个线程，线程间共享进程的地址空间。</p><p>由于线程是阻塞式的，如果想要同步执行 IO，每个 IO 都必须开启一个新线程，多线程开销较大，适合多任务处理，进程崩溃不影响其他进程，而线程只是一个进程的不同执行路线。</p><p>线程有自己的堆栈，却没有单独的地址空间，进程死就等于所有线程死，所以多进程要比多线程健壮。但在进程切换时，消耗资源较大，效率较差。</p><p>线程是并发的，且是阻塞式同步的，一旦资源死锁，线程将陷入混乱。在同步线程的执行过程中，线程的执行切换是由 CPU 轮转时间片的分配来决定的。</p><p><img src="https://imageshack.yuilexi.cn/Unity3D/Csharp-Unity脚本开发/进程-线程-协程/线程的运行状态.svg" alt="线程的运行状态"></p><h1 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h1><h2 id="3-1-协程的概念"><a href="#3-1-协程的概念" class="headerlink" title="3.1 协程的概念"></a>3.1 协程的概念</h2><p>协程是比线程更轻量级的存在，协程不由操作系统内核所管理，而是完全由程序所控制（也就是在用户态执行）。</p><p><strong>协程的好处是性能大幅提升，不会像线程切换那样消耗资源</strong>。同一时间只能执行某个协程，开辟多个协程开销不大。适合对任务进行分时处理。</p><p>协程有自己的寄存器和上下文栈。协程调度切换时，将寄存器和上下文栈保存到其他地方，并在协程切换回来时恢复之前保存的寄存器和上下文栈。由于直接对栈进行操作，基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文切换非常快。</p><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程。线程和进程都是同步机制，而协程是异步机制，无需阻塞。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用时的状态。多协程间对 CPU 的使用是依次进行的，每次只有一个协程工作，而其他协程处于休眠状态。</p><p><strong>实际上多个协程是在一个线程中的，只不过每个协程对 CPU 进行分时</strong>。协程可以访问和使用 Unity 的所有方法和 <code>Component</code>。</p><p>函数（子程序）的调用是通过栈实现的，一个线程就是执行一个函数，函数调用总是一个入口，一个返回，调用顺序是明确的，而协程在函数内部是可以中断的，然后转而执行其他函数，在适当的时候再返回来继续执行。</p><p>函数（子程序）的切换不是由线程切换，而是程序自身控制，因此没有线程切换开销。和多线程相比，线程越多，协程的性能优势就越明显，并且协程因为依次执行，不存在线程安全问题，变量访问不会冲突，共享资源也无需加锁，只需要判断状态即可，所以执行效率比线程高很多。</p><h2 id="3-2-协程的原理和作用"><a href="#3-2-协程的原理和作用" class="headerlink" title="3.2 协程的原理和作用"></a>3.2 协程的原理和作用</h2><p><strong>协程</strong>在<code>Unity</code>中是一个很重要的概念，我们知道，在使用<code>Unity</code>进行游戏开发时，一般（注意是一般）不考虑<strong>多线程</strong>，那么如何处理一些在主任务之外的需求呢，<code>Unity</code>给我们提供了协程这种方式。</p><blockquote><p><strong>在 Unity 中一般不考虑多线程的原因是</strong>：因为在<code>Unity</code>中，只能在主线程中获取物体的组件、方法、对象，如果脱离这些，<code>Unity</code>的很多功能无法实现，那么多线程的存在与否意义就不大了</p></blockquote><p>线程与协程有什么区别呢：</p><ul><li>对于协程而言，同一时间只能执行一个协程，而线程则是并发的，可以同时有多个线程在运行</li><li>两者在内存的使用上是相同的，共享堆，不共享栈</li></ul><p>其实对于两者最关键，最简单的区别是微观上线程是并行（对于多核 CPU）的，而协程是串行的</p><h3 id="3-2-1-关于协程"><a href="#3-2-1-关于协程" class="headerlink" title="3.2.1 关于协程"></a>3.2.1 关于协程</h3><p>从字面意义上理解就是协助程序的意思，我们在主任务进行的同时，需要一些分支任务配合工作来达到最终的效果。例如，在进行主任务的过程中我们需要一个对资源消耗极大的操作（比如存档）时候，如果在一帧中实现这样的操作，游戏就会变得十分卡顿，这个时候，我们就可以通过协程，在一定的帧内完成该工作的处理，同时不影响主任务的进行</p><h3 id="3-2-2-协程的原理"><a href="#3-2-2-协程的原理" class="headerlink" title="3.2.2 协程的原理"></a>3.2.2 协程的原理</h3><p>首先需要了解协程不是线程，协程依旧是在主线程中进行。其次是，协程是通过迭代器来实现功能的，通过关键字<code>IEnumerator</code> 来定义一个迭代方法</p><blockquote><ul><li><code>IEnumerator</code>：是一个实现迭代器功能的接口</li><li><code>IEnumerable</code>：是在<code>IEnumerator</code>基础上的一个封装接口，有一个<code>GetEnumerator()</code>方法返回<code>IEnumerator</code></li></ul></blockquote><p>在迭代器中呢，最关键的是 yield 的使用，这是实现我们协程功能的主要途径，通过该关键方法，可以使得协程的运行暂停、记录下一次启动的时间与位置等。</p><h3 id="3-2-3-协程的使用"><a href="#3-2-3-协程的使用" class="headerlink" title="3.2.3 协程的使用"></a>3.2.3 协程的使用</h3><p>首先通过一个迭代器定义一个返回值为 <code>IEnumerator</code> 的方法，然后在程序中通过 <code>StartCoroutine</code> 来开启一个协程即可：</p><p><code>StartCoroutine</code> 的两种重载方式：</p><ol><li><code>StartCoroutine(string methodName)</code>：这种是没有参数的情况，直接通过方法名（字符串形式，不加括号）来开启协程</li><li><code>StartCoroutine(string methodName，object values)</code>：带参数的通过方法名和参数进行调用</li><li><code>StartCoroutine(IEnumerator routine)</code>：通过<strong>调用方法</strong>的形式开启协程</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过迭代器定义一个方法</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">First</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">Second</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在程序种调用协程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    StartCoroutine(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    StartCoroutine(<span class="string">&quot;Second&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//方法三</span></span><br><span class="line">    StartCoroutine(First());</span><br><span class="line">    StartCoroutine(Second(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个协程开始后，同样会对应一个结束协程的方法<code>StopCoroutine</code>与<code>StopAllCoroutines</code>两种方式，但是需要注意的是，两者的使用需要遵循一定的规则，在介绍规则之前，同样介绍一下关于<code>StopCoroutine</code>重载：</p><ul><li><code>StopCoroutine（string methodName）</code>：通过方法名（字符串）来进行</li><li><code>StopCoroutine（IEnumerator routine）</code>:通过方法形式来调用</li><li><code>StopCoroutine(Coroutine routine)</code>：通过指定的协程来关闭</li></ul><p>如果我们是使用<code>StartCoroutine（string methodName）</code>来开启一个协程的，那么结束协程就只能使用<code>StopCoroutine（string methodName）</code>和<code>StopCoroutine(Coroutine routine)</code>来结束协程，</p><h3 id="3-2-4-yield-关键字-🧠🧠"><a href="#3-2-4-yield-关键字-🧠🧠" class="headerlink" title="3.2.4 yield 关键字 🧠🧠"></a>3.2.4 yield 关键字 🧠🧠</h3><p>要想理解协程，就要理解<code>yield</code>。在<code>Unity</code>的脚本的生命周期，<code>yield</code> 也是脚本生命周期的一些执行方法，不同的<code>yield</code> 的方法处于生命周期的不同位置。</p><p>在协程函数中，<code>yield</code> 之前的代码会在协程开启后一次运行完毕，而<code>yield</code> 之后的代码，需要满足特定的条件才会运行。</p><ul><li><code>yield return null</code>; 暂停协程等待下一帧继续执行</li><li><code>yield return 0或其他数字</code>; 暂停协程等待下一帧继续执行</li><li><code>yield return new WairForSeconds(时间)</code>; 等待规定时间后继续执行</li><li><code>yield return StartCoroutine(&quot;协程方法名&quot;)</code>;开启一个协程（嵌套协程）</li></ul><p>接下来看几个特殊的<code>yield</code>，他们是用在一些特殊的区域，一般不会有机会去使用，但是对于某些特殊情况的应对会很方便</p><ul><li><code>yield return GameObject</code>：当游戏对象被获取到之后执行</li><li><code>yield return new WaitForFixedUpdate()</code>：等到下一个固定帧数更新</li><li><code>yield return new WaitForEndOfFrame()</code>：等到所有相机画面被渲染完毕后更新</li><li><code>yield break</code>; 跳出协程对应方法，其后面的代码不会被执行</li></ul><p>通过上面的一些<code>yield</code>一些用法以及其在脚本生命周期中的位置，我们也可以看到关于协程不是线程的概念的具体的解释，所有的这些方法都是在主线程中进行的，只是有别于我们正常使用的<code>Update</code>与<code>LateUpdate</code>这些可视的方法</p><h3 id="3-2-5-协程的内核：迭代器-🧠🧠"><a href="#3-2-5-协程的内核：迭代器-🧠🧠" class="headerlink" title="3.2.5 协程的内核：迭代器 🧠🧠"></a>3.2.5 协程的内核：迭代器 🧠🧠</h3><p>从程序的角度讲，协程的核心就是迭代器。</p><p>想要定义一个协程方法有两个因素，</p><ol><li>方法的返回值为 <code>IEnumerator</code></li><li>方法中有 yield 关键字。</li></ol><p>当代码满足以上两个条件时，此方法的执行就具有了迭代器的特质，其核心就是 <code>MoveNext</code> 方法。方法内的内容将会被分成两部分：yield 之前的代码和 yield 之后的代码。yield 之前的代码会在第一次执行<code>MoveNext</code>时执行， yield 之后的代码会在第二次执行<code>MoveNext</code>时执行。</p><p>在 Unity 中，<code>MoveNext</code>的执行时机是以帧为单位的，无论你是设置了延迟时间，还是通过按钮调用<code>MoveNext</code>，亦或是根本没有设置执行条件，Unity 都会在每一帧的生命周期中判断当前帧是否满足协程所定义的条件，一旦满足，当前帧就会抽出 CPU 时间执行你所定义的协程迭代器的<code>MoveNext</code>（即 yield 后面部分）。注意，只要方法中有 yield 语句，那么方法的返回值就必须是 <code>IEnumerator</code> ，不然无法通过编译。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Windows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IEnumerator _objects;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _objects = Function();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (UnityEngine.Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            _objects.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Function</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;我是<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每执行一次 <code>MoveNext()</code>方法，就会使对应的协程<strong>往下执行一步</strong>。而使用 <code>StartCoroutine()</code>函数，相当于把 <code>MoveNext()</code>的使用权，交给 <code>Unity</code>编辑器，通过 <code>yield</code> 后面的条件，来确定何时往下执行。</p><h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp脚本基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 协程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 游戏引擎 </tag>
            
            <tag> 游戏优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity单列模式</title>
      <link href="/2023/04/30/Unity3D/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/04/30/Unity3D/Csharp%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，也同样适用于其他的语言和场景。这种类型的设计模式属于创建型模式，<strong>它提供了一种创建对象的最佳方式</strong>。23 种设计模式之一。</p><p>这种模式涉及到一个单一的类，<strong>该类负责创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意</strong>：</p><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><h1 id="二、为什么要用单列模式"><a href="#二、为什么要用单列模式" class="headerlink" title="二、为什么要用单列模式"></a>二、为什么要用单列模式</h1><p>在 Unity 脚本开发中，有时我们希望某些游戏对象在游戏中只有一个实例，例如：玩家角色等；或者我们构造了一个对游戏的某些功能进行管理的类，例如：UI 管理类等。上述情况，我们只希望存在一个玩家角色或者由<strong>一个管理类的实例</strong>管理 UI 系统，因此，就需要使用单例模式。</p><h1 id="三、单例模式实现方法"><a href="#三、单例模式实现方法" class="headerlink" title="三、单例模式实现方法"></a>三、单例模式实现方法</h1><h2 id="3-1-Unity-游戏对象的处理方法"><a href="#3-1-Unity-游戏对象的处理方法" class="headerlink" title="3.1 Unity 游戏对象的处理方法"></a>3.1 Unity 游戏对象的处理方法</h2><p>由于控制 Unity 游戏对象的脚本类全部继承于 MonoBehaviour 这个父类，因此我们可以构造一个单例模式的类，该类继承于 MonoBehaviour ，而游戏对象的脚本类继承于<strong>该单例模式类</strong>，就能做到多层级继承。</p><h3 id="3-1-1-方法-①：简单方法"><a href="#3-1-1-方法-①：简单方法" class="headerlink" title="3.1.1 方法 ①：简单方法"></a>3.1.1 方法 ①：简单方法</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonPatten</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> SingletonPatten();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li>首先这个类是公共类，其他脚本可以调用该类。</li><li>该类里面有一个静态成员：该类的实例化对象，使用静态成员表示该成员在内存中只有一份数据。</li><li>静态的成员：存放的是实例化对象，使用属性器进行访问，因为只有 get 模块，因此外部只能访问不能修改，</li><li>get 模块内部，就是单例模式的核心：如果当前字段中存在实例对象，那就返回这个对象；如果没有，就新创建一个实例化对象在返回。</li></ul><h3 id="3-1-2-方法-②：完整方法——构造单例基类"><a href="#3-1-2-方法-②：完整方法——构造单例基类" class="headerlink" title="3.1.2 方法 ②：完整方法——构造单例基类"></a>3.1.2 方法 ②：完整方法——构造单例基类</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//abstract 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SingletonMonobehavior</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T _instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//virtual 虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _instance = <span class="keyword">this</span> <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：首先把单例类定义为一个抽象类，因此该类必须被继承，不能直接实例化。该类使用了泛型的方法，可以使多个子类单独工作，降低耦合性，使其互不影响，并且提高代码利用率。然后再将 Awake() 方法定义为一个虚方法。</p><p>虚方法：</p><ul><li>必须有方法体，哪怕是一个分号</li><li>子类直接继承父类的非私有虚方法，子类可以重写(overwrite)或者选择不重写<ul><li>这与抽象方法不同，抽象方法必须重写才能使用</li><li>因此，每个单例类共同的功能——单例算法，写在虚方法 Awake() 中，并在子类中重写这个方法，并且调用父类方法</li><li>还可以在子类重写的方法中，定义子类的特有的算法代码。</li></ul></li></ul><h2 id="3-2-其他类的处理方法"><a href="#3-2-其他类的处理方法" class="headerlink" title="3.2 其他类的处理方法"></a>3.2 其他类的处理方法</h2><h3 id="3-2-1-方法-①：简单方法"><a href="#3-2-1-方法-①：简单方法" class="headerlink" title="3.2.1 方法 ①：简单方法"></a>3.2.1 方法 ①：简单方法</h3><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonPatten</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPatten Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> SingletonPatten();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp脚本基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity3D </tag>
            
            <tag> Csharp </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单列模式 </tag>
            
            <tag> 脚本开发 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2023/04/28/UniversityStudy/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2023/04/28/UniversityStudy/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、矩阵及应用"><a href="#一、矩阵及应用" class="headerlink" title="一、矩阵及应用"></a>一、矩阵及应用</h1><h2 id="1-1-高斯消元法"><a href="#1-1-高斯消元法" class="headerlink" title="1.1 高斯消元法"></a>1.1 高斯消元法</h2><p>引例：</p><p>分析，根据题意得到的方程组的如下：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle x_{1} & + & x_{2} & + & x_{3} & + & x_{4} & = & 1\\\displaystyle 20x_{1} & + & 16x_{2} & + & 10x_{3} & + &15 x_{4} & = & 15\\\displaystyle 3x_{1} & + & 8x_{2} & + & 2x_{3} & + & 5x_{4} & = & 5\\\displaystyle 10x_{1} & + & 25x_{2} & + & 20x_{3} & + & 5x_{4} & = & 12\\\end{matrix}\right.</script><p>在方程组中每一个方程的左端是未知量的一次齐次式，右端是常数，这样的方程组称为<font color='red'>线性方程组</font> 。</p><p>线性方程组中的解的全体构成的集合称为解集合，解方程组就是求其全部解，亦即求出解集合。如果两个方程组有相同的解集合，则称他们<font color='red'>同解</font> 。</p><h2 id="1-2-矩阵的定义与运算"><a href="#1-2-矩阵的定义与运算" class="headerlink" title="1.2 矩阵的定义与运算"></a>1.2 矩阵的定义与运算</h2><h3 id="1-2-1-矩阵的定义"><a href="#1-2-1-矩阵的定义" class="headerlink" title="1.2.1 矩阵的定义"></a>1.2.1 矩阵的定义</h3><p><strong>定义 1.1</strong> ：有 $ m\times n $ 个数 $\displaystyle a_{ij} (i = 1,2,\dots ,m;j=1,2,\dots ,n)$ 排成的 $m$ 行 $n$ 列的矩形数表：</p><script type="math/tex; mode=display">\displaystyle A = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\ a_{21} & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\ a_{m1} & a_{m2} & \dots  &a_{mn}\end{vmatrix}</script><p>称为 $m$ 行 $n$ 列<font color='red'>矩阵</font> （matrix），简称 $m\times n$ 矩阵，通常用大写字母表示。元素全是实数的矩阵称为<strong>实矩阵</strong>；元素全是复数的矩阵称为<strong>复矩阵</strong>。</p><h3 id="1-2-2-几种特殊矩阵"><a href="#1-2-2-几种特殊矩阵" class="headerlink" title="1.2.2 几种特殊矩阵"></a>1.2.2 几种特殊矩阵</h3><ul><li><p>行矩阵，又称<font color='red'>行向量</font> 。只有一行的矩阵。</p><script type="math/tex; mode=display">  \displaystyle A = \begin{bmatrix}  a_{1}   & a_{2}  & \dots  &a_{n}   \end{bmatrix}</script></li><li><p>列矩阵，又称<font color='red'>列向量</font> 。只有一列的矩阵。</p><script type="math/tex; mode=display">  \displaystyle B = \begin{bmatrix}  b_{1}   \\ b_{2}  \\ \vdots  \\b_{m}   \end{bmatrix}</script></li><li><p><font color='red'>零矩阵</font>：元素全为零的矩阵。记作：<script type="math/tex">O</script> 。</p></li><li><p>$n$ 阶方阵：行数和列数相等的矩阵。</p></li><li><p><font color='red'>上三角矩阵</font>：主对角线一下的元素全为零的<strong>方阵</strong>。</p><script type="math/tex; mode=display">  \displaystyle A = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\0 & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\0 & 0 & \dots  &a_{nn}\end{vmatrix}</script></li><li><p><font color='red'>下三角矩阵</font>：主对角线以上的元素全为零的<strong>方阵</strong>。</p><script type="math/tex; mode=display">  \displaystyle A = \begin{vmatrix} a_{11}  & 0 & \dots  & 0\\ a_{21} & a_{22} & \dots  & 0 \\ \vdots  & \vdots  &  &\vdots  \\ a_{n1} & a_{n2} & \dots  &a_{nn}\end{vmatrix}</script></li><li><p><font color='red'>对角阵</font>：主对角线以外的元素全为零的<strong>方阵</strong>。</p><script type="math/tex; mode=display">  \displaystyle A = \begin{vmatrix} a_{11}  & 0 & \dots  & 0\\ 0 & a_{22} & \dots  & 0 \\ \vdots  & \vdots  &  &\vdots  \\ 0 & 0 & \dots  &a_{nn}\end{vmatrix}</script></li><li><p><font color='red'>单位矩阵</font>：主对角线上全为 1 的 $n$ 阶对角矩阵。记作： $E_{n}$ 。</p><script type="math/tex; mode=display">  \displaystyle A = \begin{bmatrix} 1 &  &  & \\  & 1 &  & \\  &  &  \ddots & \\  &  &  &1\end{bmatrix}</script></li><li><p>系数矩阵：线性方程组所有系数所构成的矩阵，称为线性方程组的<font color='red'>系数矩阵</font>。</p></li><li><p>增广矩阵：由线性方程组所有系数和常数项所构成阿矩阵，称为线性方程组的<font color='red'>增广矩阵</font> ，并记作 $\displaystyle \widetilde{A} =(A,b)$ 或者 $\widetilde{A}=[A,b]$ 。</p></li></ul><h3 id="1-2-3-矩阵的运算"><a href="#1-2-3-矩阵的运算" class="headerlink" title="1.2.3 矩阵的运算"></a>1.2.3 矩阵的运算</h3><p><strong>定义 1.2</strong> ：设有两个同型的矩阵 $\displaystyle A,B$ ，它们的<strong>和</strong>记作 $\displaystyle A+B$ 。规定</p><script type="math/tex; mode=display">\displaystyle A+B = \begin{bmatrix} a_{11}+b_{11}   & a_{12}+b_{12} & \cdots  & a_{1n}+b_{1n}\\a_{21}+b_{21}  & a_{22}+b_{22} &  \cdots & a_{2n}+b_{2n}\\\vdots  & \vdots  & \ddots  &\vdots  \\ a_{m1}+b_{m1} & a_{m2}+b_{m2} & \dots  &a_{mn}+b_{mn}\end{bmatrix}</script><p><strong>定义 1.3</strong> ：数 $\lambda$ 与矩阵 $A$ 的乘积，简称 <strong>数乘</strong> ，记作 $\lambda A$ 。规定</p><script type="math/tex; mode=display">\displaystyle \lambda A = \begin{bmatrix} \lambda a_{11}& \lambda a_{12} & \cdots  & \lambda a_{1n}\\\lambda a_{21} & \lambda a_{22} &  \cdots & \lambda a_{2n}\\\vdots  & \vdots  & \ddots  &\vdots  \\ \lambda a_{m1} & \lambda a_{m2}& \dots  &\lambda a_{mn}\end{bmatrix}</script><p>矩阵的<strong>加法</strong>和<strong>数乘</strong>统称为矩阵的<font color='red'>线性运算</font>。不难验证，矩阵的<strong>线性运算</strong>法则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>运算法则</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>$\displaystyle A+B=B+A$</td></tr><tr><td style="text-align:center">2</td><td>$\displaystyle (A+B)+C=A+(B+C)$</td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle A+O = A$</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle A+(-A) = O$</td></tr><tr><td style="text-align:center">5</td><td>$\displaystyle 1A= A$</td></tr><tr><td style="text-align:center">6</td><td>$\displaystyle (\lambda \mu )A= \lambda (\mu A)=\mu (\lambda A)$</td></tr><tr><td style="text-align:center">7</td><td>$\displaystyle (\lambda +\mu )A= \lambda A+\mu A$</td></tr><tr><td style="text-align:center">8</td><td>$\displaystyle \lambda (A+B) = \lambda A+\lambda B$</td></tr></tbody></table></div><p><strong>定义 1.4</strong> ：设矩阵 $\displaystyle a_{ij} (i = 1,2,\dots ,m;j=1,2,\dots ,n)$ </p><script type="math/tex; mode=display">\displaystyle c_{ij} = \sum_{k=1}^{s} a_{ik} b_{kj}</script><p><strong>只有左边矩阵的列数等于右边矩阵的行数，两个矩阵才能相乘</strong>。</p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/矩阵的乘积.png" alt="线代矩阵相乘"></p><p> 矩阵的乘法运算法则：</p><div class="table-container"><table><thead><tr><th>序号</th><th>运算法则</th></tr></thead><tbody><tr><td>1</td><td>$\displaystyle (AB)C = A(BC)$</td></tr><tr><td>2</td><td>$\displaystyle A(B+C) = AB+AC$</td></tr><tr><td>3</td><td>$\displaystyle \lambda (AB)= (\lambda A)B=A(\lambda B)$</td></tr><tr><td>4</td><td>$\displaystyle A_{m\times n} E_{_{n} }  = E_{n} A_{m\times n}=A_{m\times n}$</td></tr><tr><td>5</td><td>$\displaystyle A^{k} A^{l}  = A^{k+l} ,(A^{k})^{l} =A^{kl} $</td></tr></tbody></table></div><p><strong>定义 1.5</strong> ：对于变量 $\displaystyle y_{1},y_{2} ,\dots,y_{m} $ ，若它们均能由变量 $\displaystyle x_{1} ,x_{2} ,\dots  ,x_{n} $ 线性表示，即有：</p><script type="math/tex; mode=display">\left\{\begin{matrix} y_{1}  & = & a_{11}x_{1} & + & a_{12}x_{2} & + & \cdots  & + & a_{1n}x_{n}\\  y_{2} & = & a_{21}x_{1} & + & a_{22}x_{2} & + & \cdots  & + &a_{2n}x_{n} \\  & \vdots  &  &  &  &  &  &  & \\  y_{n} & = & a_{m1}x_{1} & + & a_{m2}x_{2} & + & \dots  & + &a_{mn}x_{n}\end{matrix}\right.</script><p>则称此关系式为变量到变量的<font color='red'>线性变换</font> ，可以用矩阵乘积来表示：</p><script type="math/tex; mode=display">y = \begin{bmatrix}y_{1}  \\y_{2} \\ \vdots \\y_{m}\end{bmatrix} = \begin{vmatrix} a_{11}  & a_{12} & \dots  & a_{1n}\\ a_{21} & a_{22} & \dots  &a_{2n} \\ \vdots  & \vdots  &  &\vdots  \\ a_{m1} & a_{m2} & \dots  &a_{mn}\end{vmatrix}\begin{bmatrix}x_{1}  \\ x_{2}\\ \vdots \\x_{n}\end{bmatrix} = Ax</script><p><strong>定义 1.6</strong> ：将矩阵 $A$ 的行换成同序列数的列而得到的矩阵，称为 $A$ 的<font color='red'>转置矩阵</font>，记作 $\displaystyle  A^{T} \text{或者} A^{‘} $ 。即：</p><script type="math/tex; mode=display">A = \begin{bmatrix} a_{11}  &  a_{12} & \dots  &  a_{1n}\\ a_{21} &  a_{22} & \dots  &  a_{2n}\\\vdots   & \vdots  & \ddots  &\vdots  \\ a_{m1} &  a_{m2} & \dots  & a_{mn}\end{bmatrix},\quad A^{T} =\begin{bmatrix} a_{11}  &  a_{21} & \dots  &  a_{n1}\\ a_{12} &  a_{22} & \dots  &  a_{n2}\\\vdots   & \vdots  & \ddots  &\vdots  \\ a_{1m} &  a_{2m} & \dots  & a_{nm}\end{bmatrix}</script><p>如果 $n$ 阶方阵 $A$ 满足 $\displaystyle  A^{T} =A$ ，则称 $A$ 为 <font color='red'>对称矩阵</font> ；如果 $n$ 阶方阵 $A$ 满足 $\displaystyle  A^{T} =-A$ ，则称 $A$ 为 <font color='red'>反对称矩阵</font> 。</p><p>转置矩阵的运算法则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>运算法则</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>$\displaystyle  (A^{T})^{T}  = A$</td></tr><tr><td style="text-align:center">2</td><td>$\displaystyle  (A+B)^{T}  = A^{T} +B^{T} $</td></tr><tr><td style="text-align:center">3</td><td>$\displaystyle  (\lambda A)^{T}  = \lambda A^{T} $</td></tr><tr><td style="text-align:center">4</td><td>$\displaystyle  (AB)^{T}  = B^{T}  A^{T} $</td></tr></tbody></table></div><h2 id="1-3-可逆矩阵"><a href="#1-3-可逆矩阵" class="headerlink" title="1.3 可逆矩阵"></a>1.3 可逆矩阵</h2><p>我们已经介绍了矩阵的加法、减法、数乘以及乘法运算，那么矩阵有没有除法运算呢？</p><h3 id="1-3-1-可逆矩阵的定义"><a href="#1-3-1-可逆矩阵的定义" class="headerlink" title="1.3.1 可逆矩阵的定义"></a>1.3.1 可逆矩阵的定义</h3><p><strong>定义 1.7</strong>：设 $A$ 为 $n$ 阶方阵，若存在 $n$ 阶方阵 $B$ ，使得 $\displaystyle AB = BA = E_{n} $ ，其中 $\displaystyle  E_{n} $ 为 $n$ 阶<strong>单位矩阵</strong>，则称 $A$ 为<font color='red'>可逆矩阵</font>（或称 $A$ 是 <strong>可逆的</strong>），并称 $B$ 是 $A$ 的逆矩阵。</p><h3 id="1-3-2-可逆矩阵的性质"><a href="#1-3-2-可逆矩阵的性质" class="headerlink" title="1.3.2 可逆矩阵的性质"></a>1.3.2 可逆矩阵的性质</h3><p><strong>性质 1.1</strong> ：若矩阵 $A$ 可逆，则 $A$ 的逆矩阵唯一。</p><ul><li><p>证明：</p><p>  ​    假设 $ B,C $ 都是 $A$ 的逆矩阵，则有 $AB = BA = E$ 和 $AC = CA = E$ 。则有</p><script type="math/tex; mode=display">  B =BE=B(AC)=(BA)C=C</script><p>  ​    因此， $A$ 的逆矩阵是唯一的。    </p></li></ul><p><strong>性质 1.2</strong> ：若矩阵 $A$ 可逆，则 $A^{-1}$ 也是可逆的 $(A^{-1})^{-1} =A$ 。</p><p><strong>性质 1.3</strong> ：若矩阵 $A$ 可逆，数 $\displaystyle \lambda  \ne 0$ ，则 $\displaystyle \lambda A $ 是可逆的，且 $\displaystyle \left ( \lambda A  \right ) ^{-1}  = \frac{1}{\lambda } A^{-1} $ 。</p><p><strong>性质 1.4</strong> ：若 $A,B$ 均为可逆方阵，则 $AB$ 也是可逆的，且 $\displaystyle (AB)^{-1}  = B^{-1} A^{-1} $ 。</p><p><strong>性质 1.5</strong> ：若 $A$ 可逆，则 $A^{T}$ 也是可逆的，且 $\displaystyle (A^{T} )^{-1}  = (A^{-1} )^{T} $ 。</p><h2 id="1-4-分块矩阵"><a href="#1-4-分块矩阵" class="headerlink" title="1.4 分块矩阵"></a>1.4 分块矩阵</h2><p>在矩阵运算中，特别是针对高阶矩阵，常常采用矩阵分块的方法将其简化为较低阶的矩阵进行计算。我们用若干条纵、横线将高阶矩阵 $A$ 分成若干个小矩阵，每一个小矩阵称为 $A$ 的子块，以子块为元素的矩阵称为 <font color='red'>分块矩阵</font> 。</p><p><img src="https://imageshack.yuilexi.cn/University/线性代数/分块矩阵.png" alt="分块矩阵"></p><ol><li><p>加法运算：与一般矩阵加法运算形式一致</p></li><li><p>数乘运算：与一般矩阵数乘运算形式一致</p></li><li><p>乘法运算：与一般矩阵乘法运算形式一致</p></li><li><p>分块矩阵的转置：</p><script type="math/tex; mode=display"> \begin{align}\displaystyle 设A = \begin{bmatrix} A_{11}  &  A_{12} & \cdots  & A_{1s} \\  A_{21} &  A_{22} & \cdots  & A_{2s} \\ \vdots  & \vdots   & \ddots   & \vdots \\ A_{r1}  &  A_{r2} & \cdots  & A_{rs}\end{bmatrix},则有A^{T}  = \begin{bmatrix} A_{11}^{T}   &  A_{21}^{T}  & \cdots  & A_{r1}^{T}  \\  A_{12}^{T}  &  A_{22}^{T}  & \cdots  & A_{r2}^{T}  \\ \vdots  & \vdots   & \ddots   & \vdots \\ A_{1s}^{T}   &  A_{2s}^{T}  & \cdots  & A_{rs}^{T} \end{bmatrix}\end{align}</script></li><li><p>分块对角矩阵</p><script type="math/tex; mode=display"> \begin{align}\displaystyle A =\begin{bmatrix} A_{1}  &   &   &  \\   &  A_{2} &   &  \\   &   & \ddots   &  \\   &  &   & A_{r}\end{bmatrix}\end{align}</script><p> ​    主对角线上的子块 $\displaystyle A_{i} (i=1,2,\dots ,r)$ 均是方阵，其余子块全是零矩阵，则称 $A$ 为分块对角矩阵，记为： $\displaystyle A = diag(A_{1} ,A_{2} ,\dots ,A_{r} )$ 。</p></li></ol><h2 id="1-5-初等变换与初等矩阵"><a href="#1-5-初等变换与初等矩阵" class="headerlink" title="1.5 初等变换与初等矩阵"></a>1.5 初等变换与初等矩阵</h2><h3 id="1-5-1-初等变换"><a href="#1-5-1-初等变换" class="headerlink" title="1.5.1 初等变换"></a>1.5.1 初等变换</h3><p><strong>定义 1.8</strong> ：下面三种变换称为 <strong>矩阵的初等行变换</strong> ：</p><ol><li>交换两行的位置</li><li>以非零数 $k$ 乘以某行</li><li>把某行的 $k$ 倍加到另一行上</li></ol><p>将定义 1.8 的“行”换为“列”，就得到<strong>矩阵的初等列变换</strong> 。矩阵的初等行变换与初等列变换统称为矩阵的<font color='red'>初等变换</font> 。</p><p>如果矩阵<script type="math/tex">A</script> 经过有限次初等变换，得到矩阵 $B$ ，就称矩阵 $A$ 和矩阵 $B$ <strong>等价</strong>，记作：$\displaystyle A\sim B$ 。</p><p><strong>矩阵的等价关系具有以下性质</strong>：</p><ol><li>反身性： $\displaystyle A\sim A$ </li><li>对称性： $\displaystyle 若A\sim B,则B\sim A$ </li><li>传递性： $\displaystyle 若A\sim B,B\sim C,则A\sim C$ </li></ol><p><font color='red'>行阶梯矩阵</font> 是指满足下面两个条件的矩阵：</p><ol><li>如果有零行（元素全为零的行），则零行位于非零行的下方；</li><li>非零行的首个非零元素（亦称为基准或主元素），前面零元的个数从上往下依次增加。</li></ol><p>当行阶梯矩阵进一步满足：非零行的首非零元均为 1 ，且所在列的其余元素均为 0 ，则称为 <font color='red'>最简行阶梯矩阵</font>（或称<font color='red'>行最简形</font>） 。</p><h3 id="1-5-2-初等矩阵"><a href="#1-5-2-初等矩阵" class="headerlink" title="1.5.2 初等矩阵"></a>1.5.2 初等矩阵</h3><p><strong>定义 1.9</strong> ： $n$ 阶单位矩阵 $E$ 经过一次初等变换所得到的矩阵称为 <font color='red'>初等矩阵</font> 或 <font color='red'>初等方阵</font> 。</p><p><strong>定理 1.2</strong> ：设 $A$ 是一个 $m\times n$ 的矩阵，<strong>对 $A$ 施行一次初等行变换，其结果相当于在 $A$ 的左边乘以相应的 $m$ 阶初等矩阵</strong>；对 $A$ 施行一次初等列变换，其结果相当于在 $A$ 的右边乘以相应的 $n$ 阶初等矩阵。</p><p><strong>定理 1.3</strong> ：设 $A$ 为 $n$ 阶方阵，那么下面命题等价：</p><ol><li>$A$ 是可逆矩阵；</li><li>线性方程组 $Ax=0$ 只有零解；</li><li>$A$ 可以经过有限次初等行变换化为单位矩阵；</li><li>$A$ 可以表示为有限个初等矩阵的乘积。</li></ol><p><strong>逆矩阵的求法（方法一）</strong>：</p><script type="math/tex; mode=display">\begin{align}\begin{bmatrix} A & \vdots   & E\end{bmatrix} &\sim  \begin{bmatrix} E & \vdots   & A^{-1} \end{bmatrix}\\\begin{bmatrix} A\\ \dots \\E\end{bmatrix} &\sim  \begin{bmatrix} E\\ \dots \\A^{-1} \end{bmatrix}\end{align}</script><p>对 $n \times 2n$ 矩阵 $\displaystyle \begin{bmatrix}A &amp; \vdots  &amp;B \end{bmatrix} $ 施行若干次初等行变化，当子块 $A$ 化为单位矩阵 $E$ 时，另一个子块 $B$ 就化为了 $A^{-1}B$ 。形式如下：</p><h3 id="1-5-3-矩阵的秩"><a href="#1-5-3-矩阵的秩" class="headerlink" title="1.5.3 矩阵的秩"></a>1.5.3 矩阵的秩</h3><p><strong>定义 1.10</strong> ：设 $A$ 为 $m\times n$ 矩阵， $B$ 是与 $A$ 等价的行阶梯矩阵。若矩阵 $B$ 的非零行的个数为 $r$ ，则称矩阵 $B$ 的<font color='red'>秩</font>为 $r$ ，矩阵 $A$ 的之也为 $r$ ，记作 $\displaystyle R(A) = R(B)  = r$ 。</p><p><strong>矩阵秩的性质</strong>如下：</p><ol><li><p>$\displaystyle R(A) =R(A^{T} )$ ；</p></li><li><p>$R(A)=0\iff A=O$ ；</p></li><li><p>$\displaystyle 0\le R(A_{m\times n} )\le \text{min} \left \{ m,n \right \} $ ；</p></li><li><p>若 $A\sim B$ ，则 $\displaystyle R(A) = R(B)$ ；</p></li><li><p>$\displaystyle R\begin{bmatrix}A &amp; O\\O &amp; B\end{bmatrix} = R(A) +R(B)$ ；</p></li><li><p>${\color{Red} \displaystyle \text{max}\left \{ R(A),R(B) \right \}  \le R(A,B)\le R(A)+R(B)} $ </p></li><li><p>$\displaystyle R(A\pm B)\le R(A)+R(B)$ ；</p><ul><li>证明：<script type="math/tex; mode=display"> \begin{align}\displaystyle \begin{bmatrix} A & O\\ O &B\end{bmatrix}\sim \displaystyle \begin{bmatrix} A & O\\ A &B\end{bmatrix}\sim \displaystyle \begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\end{align}</script> ​    所以<script type="math/tex; mode=display"> \displaystyle R(A)+R(B) = R\begin{bmatrix} A & A\\ A &A+B\end{bmatrix}\ge R(A+B)</script> ​    同理可证<script type="math/tex; mode=display"> \displaystyle R(A)+R(B)\ge R(A- B)</script> ​    </li></ul></li><li><p>若 $A$ 为 $n$ 阶方阵，则 $\displaystyle R(A)=n\Longleftrightarrow A 是可逆矩阵$ ；</p></li><li><p>$\displaystyle R(AB)\le\text{min} \left \{  R(A),R(B) \right \} $ （<strong>乘法矩阵的秩在减小，只有都是满秩才取等</strong>）；</p></li><li><p>若 $P,Q$ 可逆，则 $\displaystyle R(A) = R(PA)=R(AQ)=R(PAQ)$ （可逆矩阵不影响矩阵的秩，可逆矩阵一定是满秩）；</p></li><li><p>若 $A,B$ 均为 $n$ 阶方阵，则 $\displaystyle R(AB)\ge R(A)+R(B)-n$ ；</p><p>​    （ $\displaystyle R(A)+R(B)-n\le R(AB)\le \text{min}\left \{ R(A),R(B) \right \}  $ ，上式被称为<font color='red'>西尔维斯特不等式</font>）；</p></li><li><p>若 $\displaystyle A_{m\times n}B_{n\times l} =O$ ，则 $\displaystyle R(A)+R(B)\le n$ ；</p></li><li><script type="math/tex; mode=display">\begin{align}\displaystyle A_{m\times n} \text{行满秩}\Longleftrightarrow  R(A) & = n\Longleftrightarrow A的标准等价性\begin{bmatrix}I_{m} &O\end{bmatrix}\\\displaystyle A_{m\times n} \text{列满秩}\Longleftrightarrow  R(A) & = n\Longleftrightarrow A的标准等价性\begin{bmatrix}I_{n}  \\O\end{bmatrix}\end{align}</script></li><li><p><code>Frobenius</code>不等式： $\displaystyle R(ABC)\ge R(AB)+R(BC)-R(B)$ ；</p></li><li><p>$\displaystyle R(A_{m\times n} )=n\Longleftrightarrow \text{齐次方程组}  Ax=0 \text{只有零解}$ 。</p></li></ol><h2 id="1-6-线性方程组的解"><a href="#1-6-线性方程组的解" class="headerlink" title="1.6 线性方程组的解"></a>1.6 线性方程组的解</h2><p><strong>定理 1.4</strong> ：齐次线性方程组 $\displaystyle A_{m\times n}X=0$ 有非零解的<strong>充分必要</strong>条件是 $\displaystyle R(A) =r$ ，且有无穷多解，自由量为 $n-r$ 个。</p><p><strong>定理 1.5</strong> ：非齐次线性方程组 $\displaystyle A_{m\times n}X=b$ 有解的<strong>充分必要</strong>条件是 $\displaystyle R(A) = R(\widetilde{A} ) = r$ ，其中 $\displaystyle \widetilde{A} =[A,b]$ 为增广矩阵，且当</p><ol><li>$r=n$ 时有唯一解，称为<font color='red'>适定线性方程组</font>；</li><li>$r&lt;n$ 时有无穷多解，自由量为 $n-r$ 个，称为<strong>欠定线性方程组</strong>；</li></ol><p>由上述定理可知：当 $\displaystyle R(A) \ne R(\widetilde{A} )$ ，则线性方程组 $\displaystyle A_{m\times n}X=b$ 无解，称为<font color='red'>超定线性方程组</font>。</p><p>对于无界的线性方程，可求其近似解。</p><h1 id="二、行列式与线性方程组"><a href="#二、行列式与线性方程组" class="headerlink" title="二、行列式与线性方程组"></a>二、行列式与线性方程组</h1><h2 id="2-1-行列式的概念及性质"><a href="#2-1-行列式的概念及性质" class="headerlink" title="2.1 行列式的概念及性质"></a>2.1 行列式的概念及性质</h2><h3 id="2-1-1-二、三阶行列式"><a href="#2-1-1-二、三阶行列式" class="headerlink" title="2.1.1 二、三阶行列式"></a>2.1.1 二、三阶行列式</h3><p>考虑求二元线性方程组</p><script type="math/tex; mode=display">\left\{\begin{matrix} a_{11}x_{1}   & + &  a_{12}x_{2}  & = & b_{1} \\  a_{21}x_{1}  & + &  a_{22}x_{2}  & = & b_{2} \end{matrix}\right.</script><p>的解。当 $a_{1} a_{2}$ 时，由消元法得方程组得唯一解为</p><script type="math/tex; mode=display">\displaystyle \left\{\begin{matrix}\displaystyle  x_{1}  & = & {\large \frac{b_{1}a_{22} -b_{2} a_{12}  }{a_{11} a_{22} -a_{12} a_{21}} } \\\displaystyle  x_{2}  & = & {\large \frac{b_{2}a_{11} -b_{1} a_{21}  }{a_{11} a_{22} -a_{12} a_{21}}}  \end{matrix}\right.</script><p>为了便于记忆，引入记号 $\displaystyle D = \begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}$ ，他表示 $\displaystyle a_{11} a_{22} - a_{12} a_{21}$ ，称为<font color='red'>二阶行列式</font>，即</p><script type="math/tex; mode=display">D = \begin{vmatrix} a_{11}  &  a_{12}  & a_{13}  \\  a_{21}  &  a_{22}  &  a_{23} \\  a_{31}  &  a_{32}  & a_{33} \end{vmatrix}</script><p>称上式中得 $D$ 为<font color='red'>三阶行列式</font>。</p><h3 id="2-1-2-n-阶行列式"><a href="#2-1-2-n-阶行列式" class="headerlink" title="2.1.2 $n$ 阶行列式"></a>2.1.2 $n$ 阶行列式</h3><p><strong>定义 2.1</strong> ：由 $n^{2}$ 个元素 $a_{ij}(i,j=1,2,3,\dots ,n)$ 组成的记号：</p><script type="math/tex; mode=display">\begin{vmatrix} a_{11}  &  a_{12} & \dots  &  a_{1n}\\  a_{21} &  a_{22} & \dots  &  a_{2n}\\ \vdots  & \vdots  & \ddots  &\vdots  \\  a_{n1} &  a_{n2} & \dots  & a_{nn}\end{vmatrix}</script><p>称为<font color='red'> $n$ 阶行列式</font>，该行列式表示一个数，其中横排称为行，竖排称为列。一般地，行列式记作$\displaystyle D,D_{n} ,D_{n} =\left | a_{ij}  \right | ,\quad det(A)\text{或者}\left | A \right | $ 。</p><p><strong>定义  2.2</strong> ：在 $n$ 阶行列式</p><script type="math/tex; mode=display">D=\begin{vmatrix} a_{11}  &  a_{12} & \dots  &  a_{1n}\\  a_{21} &  a_{22} & \dots  &  a_{2n}\\ \vdots  & \vdots  & \ddots  &\vdots  \\  a_{n1} &  a_{n2} & \dots  & a_{nn}\end{vmatrix}</script><p>中划掉元素 $a_{ij}$ 所在的第 $i$ 行与第 $j$ 列所有元素后，剩下的 $(n-1)^{2}$ 个元素按原来的次序构成的 $n-1$ 阶的行列式称为元素 $a_{ij}$ 的<font color='red'>余子式</font>，记作 $\displaystyle M_{ij}$ ，并且称 $\displaystyle (-1)^{i+j}M_{ij} $ 为元素 $a_{ij}$ 的<font color='red'>代数余子式</font>，记作 $A_{ij}$ 。</p><p><strong>定义 2.3</strong> 当 $n=1$ 时，一阶行列式 $\displaystyle D_{1} =\left | a_{11}  \right | =a_{11}$ ，假设 $n-1$ 阶行列式已定义，则 $n$ 阶行列式可定义为：</p><script type="math/tex; mode=display">\displaystyle D = a_{11} A_{11} +a_{12} A_{12}+\dots +a_{1n} A_{1n} = \sum_{k=1}^{n} a_{1k} A_{1k}</script><p>其中 $\displaystyle A_{1k} $ 是元素 $a_{1k}$ 的代数余子式，且全为 $n-1$ 阶行列式，上式也称为 <strong>$n$ 阶行列式按第一行的展开定义</strong>。</p><h3 id="2-1-3-行列式的性质"><a href="#2-1-3-行列式的性质" class="headerlink" title="2.1.3 行列式的性质"></a>2.1.3 行列式的性质</h3><p><strong>性质 2.1</strong> ：行列式与其转置行列式相等，即</p><script type="math/tex; mode=display">\left | A \right |= \left | A^{T}  \right |</script><p><strong>性质 2.2</strong> ：行列式中某行（或列）元素的公因子可以提到行列式之外；</p><p><strong>推论 2.1</strong> ：对于 $n$ 阶矩阵 $A$ ，有 $\displaystyle \left | kA \right |  = k^{n} \left | A \right | $ ；</p><p><strong>推论 2.2</strong> ：<strong>某行（或列）元素全为零的行列式等于零</strong>；</p><p><strong>性质 2.3</strong> ：<strong>交换某两行（或列）的位置，行列式的值变号</strong>；</p><p><strong>推论 2.3</strong> ：如果行列式中有两行（或两列）元素相同，则行列式等于零；</p><p><strong>推论 2.4</strong> ：如果行列式中有两行（或两列）对应元素成比例，则行列式等于零；</p><p><strong>性质 2.4</strong> ：若行列式某一行（或列）的元素是两项之和，则该行列式可以写成两个行列式之和，即</p><p><strong>性质 2.5</strong> ：将某一行（或列）的任意 $k$ 倍加到另一行（或列）上去，行列式的值不变。</p><p><strong>定理 2.1（<font color='red'>行列式展开定理</font>）</strong> ： $n$ 阶行列式 $\displaystyle D_{n}  = \left | a_{ij}  \right | $ 等于它的任一行（列）的各元素与其对应的代数余子式乘积之和，即</p><script type="math/tex; mode=display">\displaystyle D_{n}  = \sum_{k=1}^{n} a_{ik} A_{ik} \quad (i = 1,2,\dots ,m)</script><p><strong>性质 2.6</strong> ：对于 $n$ 阶行列式 $\displaystyle D_{n} $ ，有</p><script type="math/tex; mode=display">\left\{\begin{matrix}\displaystyle \sum_{j=1}^{n}a_{ij}A_{kj} ,   &\text{当} i\ne k\text{时} \\ \displaystyle \sum_{i=1}^{n}a_{ij}A_{ik},  &\text{当}j\ne k\text{时}\end{matrix}\right.</script><p><strong>性质 2.7（<font color='red'>行列式乘积法则</font>）</strong> ： <script type="math/tex">\displaystyle \left | AB \right | =\left | A \right | \left | B \right |</script> ；</p><h2 id="2-2-行列式的计算"><a href="#2-2-行列式的计算" class="headerlink" title="2.2 行列式的计算"></a>2.2 行列式的计算</h2><p><em>暂时省略</em></p><h2 id="2-3-行列式的应用"><a href="#2-3-行列式的应用" class="headerlink" title="2.3 行列式的应用"></a>2.3 行列式的应用</h2><h3 id="2-3-1-逆矩阵的计算"><a href="#2-3-1-逆矩阵的计算" class="headerlink" title="2.3.1 逆矩阵的计算"></a>2.3.1 逆矩阵的计算</h3><p>（有关逆矩阵的计算，还有<a href="#1-5-2-初等矩阵">线性代换法</a>）</p><p><strong>定理 2.2</strong> ：矩阵 $A$ 的各个元素的代数余子式$A_{ij}$ 构成如下矩阵</p><script type="math/tex; mode=display">\displaystyle A^{*}  = \begin{bmatrix} A_{11}  & A_{21} & \dots  &A_{n1}\\ A_{12} & A_{22} & \dots  & A_{n2}\\ \vdots  & \vdots  & \ddots  &\vdots  \\ A_{1n} & A_{21} & \dots  &A_{nn}\end{bmatrix}</script><p>即 $\displaystyle A^{\ast } = (A_{ij})^{T} _{n\times n} $ ，称 $\displaystyle A^{\ast }$ 为矩阵 $A$ 的<font color='red'>伴随矩阵</font>，或记作 $\displaystyle \text{adj} A$ ，（也就是代数余子式矩阵的转置矩阵），且伴随矩阵满足下面关系式：</p><script type="math/tex; mode=display">\displaystyle AA^{\ast }  = A^{\ast } A = \left | A \right | E</script><p><strong>推论 2.5</strong> ：当 $\displaystyle \left | A \right | \ne 0$ 时，有 $\displaystyle \left | A^{\ast }  \right |  = \left | A \right | ^{n-1} $ ；（ $\displaystyle \left | A \right | \left | A^{*}  \right |  = \left | A \right | ^{n} $ ）</p><p><strong>定理 2.3</strong> ： $A$ 为可逆矩阵的<strong>充分必要</strong>条件为： $\displaystyle \left | A \right |\ne 0$ ，并且有以下关系</p><script type="math/tex; mode=display">\displaystyle  A^{-1}   = \frac{1}{\left | A \right | } A^{*}</script><p>当 $\displaystyle  \left | A \right | \ne 0$ 时，也称矩阵 $A$ 为<font color='red'>非奇异矩阵或非退化矩阵</font>；当 $\displaystyle  \left | A \right | = 0$ 时，称矩阵为<font color='red'>奇异矩阵或退化矩阵</font>。显然，可逆矩阵是非奇异矩阵。</p><p><strong>定理 2.4</strong> ：设 $\displaystyle A,B\in P^{n\times n} $ ，若 $\displaystyle AB = E_{n} $ ，则 $A$ 和 $B$ 都可逆，并且</p><script type="math/tex; mode=display">\displaystyle A^{-1} =B,B^{-1}  =A</script><h3 id="2-3-2-克莱默（Cramer）法则"><a href="#2-3-2-克莱默（Cramer）法则" class="headerlink" title="2.3.2 克莱默（Cramer）法则"></a>2.3.2 克莱默（<code>Cramer</code>）法则</h3><p><strong>定理 2.4（<code>Cramer</code>）</strong> ：对线性方程组，当系数行列式 $\displaystyle D\ne 0$ 时，该方程组有唯一解，其解为</p><p>（<em>暂时略</em>）</p><p><strong>推论 2.6</strong> ：齐次线性方程组 $\displaystyle Ax =0$ 有非零解的充分必要条件是 $\displaystyle\left | A \right | =0$ 。系数行列式 $\displaystyle\left | A \right | \ne 0$ 时，该方程只有一个零解。零解也被称为<strong>平凡解</strong>；不全为零的解被称为<strong>非零解</strong>。</p><h1 id="三、向量与向量空间"><a href="#三、向量与向量空间" class="headerlink" title="三、向量与向量空间"></a>三、向量与向量空间</h1><h2 id="3-1-向量及其运算"><a href="#3-1-向量及其运算" class="headerlink" title="3.1 向量及其运算"></a>3.1 向量及其运算</h2><h3 id="3-1-1-n-维向量"><a href="#3-1-1-n-维向量" class="headerlink" title="3.1.1 $n$ 维向量"></a>3.1.1 $n$ 维向量</h3><p><strong>定义 3.1</strong> ： $n$ 个有序的数 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{n} $ 构成的数组称为 <font color='red'>$n$ 维向量</font>。这 $n$ 个数成为该向量的 $n$ 个分量， $n$ 也称为该向量的长度， $n$ 维向量为</p><script type="math/tex; mode=display">\begin{align}a &= \begin{bmatrix}a_{1}   & a_{2}  &  \cdots &a_{n} \end{bmatrix}\\a &= \begin{bmatrix}a_{1}   \\ a_{2} \\  \cdots \\a_{n} \\\end{bmatrix}\end{align}</script><p>称其为<font color='red'>行向量</font>或<font color='red'>列向量</font>。如果没有指明是行向量还是列向量，均以列向量对待。</p><h3 id="3-1-2-向量的运算"><a href="#3-1-2-向量的运算" class="headerlink" title="3.1.2 向量的运算"></a>3.1.2 向量的运算</h3><p>向量加法和数乘称为<strong>向量的线性运算</strong>。向量的线性运算法则：</p><ol><li>$\displaystyle \alpha +\beta  = \beta+\alpha $ ；</li><li>$\displaystyle (\alpha +\beta )+\gamma =\alpha +(\beta +\gamma)$ ；</li><li>$\displaystyle  \alpha +O = \alpha $ ；</li><li>$\displaystyle  \alpha +(-\alpha ) =O$ ；</li><li>$\displaystyle  1\alpha =\alpha$ ；</li><li>$\displaystyle  (kl)\alpha =k\left ( l\alpha \right ) =l\left ( k\alpha \right ) $ ；</li><li>$\displaystyle  (k+l)\alpha =k\alpha  +l\alpha$ ；</li><li>$\displaystyle  k(\alpha +  \beta ) = k\alpha +k\beta $ ；</li></ol><h2 id="3-2-向量组的线性相关"><a href="#3-2-向量组的线性相关" class="headerlink" title="3.2 向量组的线性相关"></a>3.2 向量组的线性相关</h2><h3 id="3-2-1-向量组的线性表示"><a href="#3-2-1-向量组的线性表示" class="headerlink" title="3.2.1 向量组的线性表示"></a>3.2.1 向量组的线性表示</h3><p><strong>定义 3.2</strong> ：</p><ol><li>设 $n$ 维向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{s} $ ，对于任意一组实数 $\displaystyle k_{1} ,k_{2} ,\dots  ,k_{s} $ ，称 $\displaystyle k_{1}a_{1} +k_{2}a_{2} +\dots +k_{s}a_{s}$ 是向量组的一个<font color='red'>线性组合</font>，其中 $\displaystyle k_{1} ,k_{2} ,\dots  ,k_{s} $ 为组合系数。</li><li>设 $b$ 为 $n$ 维向量，若存在一组数 $\displaystyle \lambda _{1} ,\lambda _{2} ,\dots ,\lambda _{s} $ ，使得 $\displaystyle b = \lambda _{1}a_{1} +\lambda _{2}a_{2} +\dots +\lambda _{s}a_{s}$ ，则称向量 $b$ 可以由向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{s} $ <font color='red'>线性表示</font>。</li><li><p>易知，零向量可由任何一向量组线性表示</p><p><strong>$n$ 维向量组 $\displaystyle e_{1}  = \left [ 1,0,\dots ,0 \right ]^{T},e_{2}  = \left [ 0,1,\dots ,0 \right ] ^{T} ,\dots ,e_{n}  = \left [ 0,0,\dots ,1 \right ] ^{T} ,$ 为 $n$ 维<font color='red'>基本单位向量组</font></strong>。</p></li></ol><h3 id="3-2-2-向量组与矩阵及线性方程组间的关系"><a href="#3-2-2-向量组与矩阵及线性方程组间的关系" class="headerlink" title="3.2.2 向量组与矩阵及线性方程组间的关系"></a>3.2.2 向量组与矩阵及线性方程组间的关系</h3><ol><li><p>向量组与矩阵的关系</p><script type="math/tex; mode=display"> \displaystyle A = \begin{vmatrix}  a_{11}  & a_{12} & \dots  & a_{1n}\\  a_{21} & a_{22} & \dots  &a_{2n} \\  \vdots  & \vdots  &  &\vdots  \\  a_{m1} & a_{m2} & \dots  &a_{mn} \end{vmatrix}  = \begin{bmatrix} \beta _{1}  \\ \beta _{2} \\ \vdots  \\ \beta _{m} \end{bmatrix} =\begin{bmatrix} \alpha _{1}   & \alpha _{2} & \dots  &\alpha _{n} \end{bmatrix}</script></li><li><p>向量组与线性方程组的关系</p><p> （<em>暂时略</em>）</p></li></ol><h3 id="3-2-3-向量组的线性相关性定义及性质"><a href="#3-2-3-向量组的线性相关性定义及性质" class="headerlink" title="3.2.3 向量组的线性相关性定义及性质"></a>3.2.3 向量组的线性相关性定义及性质</h3><p><strong>定义 3.3</strong> ：设有 $n$ 维向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{m} $ ，如果存在<strong>不全为零</strong>的一组数 $\displaystyle k_{1},k_{2},\dots ,k_{m}$ ，使得</p><script type="math/tex; mode=display">\displaystyle k_{1}a_{1}+k_{2}a_{2}+\dots +k_{m}a_{m}=0</script><p>则称向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{m} $ <font color='red'>线性相关</font>；反之，称向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{m} $ <font color='red'>线性无关</font>。</p><p>根据 <code>定义 3.3</code>，我们能得到以下结论：</p><ol><li>包含零向量的向量组必定线性相关；</li><li>当向量组只有一个向量 $\displaystyle \alpha $ 时，若 $\displaystyle \alpha =0$ ，则线性相关；反之，则线性无关；</li><li>非零向量组 $\displaystyle a_{1},a_{2}  $ 线性相关的<strong>充分必要</strong>条件为 $\displaystyle a_{1} = ka_{2}  $ ，即向量 $\displaystyle a_{1}$ 与向量 $\displaystyle a_{2}$ 对应分量成比例。</li></ol><p><strong>定理 3.1</strong> ：向量组 $\displaystyle a_{1} ,a_{2} ,\dots  ,a_{m} $ 线性相关的<strong>充分必要</strong>条件为，至少存在一个向量 $a_{i}$ 可以用其余向量线性表示。</p><p><strong>定理 3.2</strong> ：设 $A$ 是 $m\times n$ 矩阵，则矩阵 $A$ 的列向量组线性相关（无关）的<strong>充分必要</strong>条件为齐次线性方程组 $Ax=0$ 有非零解（只有零解）</p><h2 id="3-3-向量组的秩与极大无关组"><a href="#3-3-向量组的秩与极大无关组" class="headerlink" title="3.3 向量组的秩与极大无关组"></a>3.3 向量组的秩与极大无关组</h2><p><strong>定义 3.4</strong> ：设有向量组Ⅰ：$\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 和Ⅱ：$\displaystyle \beta  _{1},\beta _{2},\cdots ,\beta _{s} $ 。若<strong>向量组Ⅰ中的每一个向量都能用向量组Ⅱ线性表示</strong>，则称<strong>向量组Ⅰ可由向量组Ⅱ线性表示</strong>。如果向量组Ⅰ与Ⅱ可以相互线性表示，则称<strong>向量组Ⅰ和Ⅱ等价</strong>。</p><p><strong>定义 3.5</strong> ：设有向量组：$\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ ，而 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{r}$ 是向量组Ⅰ中的 $r$ 个向量（$r\le s$），若满足：</p><ol><li>向量组 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{r} $ 线性无关；</li><li>向量组 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 中任 $r+1$ 个向量（如果向量组中有 $r+1$ 个向量）线性相关；</li></ol><p>则称向量组 $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{r} $ 是向量组Ⅰ $\displaystyle \alpha _{1},\alpha _{2},\cdots ,\alpha _{s} $ 的一个<font color='red'>最大线性无关向量组</font>，简称<font color='red'>极大无关组</font>，极大无关组的个数 <script type="math/tex">r</script> 称为向量组的秩，记作 $\displaystyle R(a_{1},a_{2},\cdots ,a_{s} ) = r$ 。</p><p>对于 $m\times n$ 阶矩阵 $A$ ， $A$ 的行（列）向量组的秩称为 $A$ 的<font color='red'>行（列）秩</font>。</p><hr><p><strong>定理 3.3</strong> ：阶梯形矩阵 $J$ 的行秩和列秩相等，恰等于 $J$ 的非零行数，并且 $J$ 的主元所在列构成列向量的一个极大无关组。</p><p><strong>定理 3.4</strong> ：矩阵的初等行（列）变换不改变矩阵的列（行）向量的线性相关性，从而不改变矩阵的列（行）秩。</p><p><strong>定理 3.5</strong> ：矩阵 $A$ 的秩等于 $A$ 的行秩，也等于 $A$ 的列秩。</p><p><strong>定理 3.6</strong> ：设 $A$ 是 $m\times n$ 阶矩阵，则</p><ul><li>矩阵 $A$ 的列向量组线性相关（无关）的<strong>充分必要</strong>条件为 $\displaystyle R(A)$ </li><li>矩阵 $A$ 的行向量组线性相关（无关）的<strong>充分必要</strong>条件为 $\displaystyle R(A)$ </li></ul><h2 id="3-4-向量空间"><a href="#3-4-向量空间" class="headerlink" title="3.4 向量空间"></a>3.4 向量空间</h2><h3 id="3-4-1-向量空间的定义"><a href="#3-4-1-向量空间的定义" class="headerlink" title="3.4.1 向量空间的定义"></a>3.4.1 向量空间的定义</h3><p><strong>定义 3.6</strong> ：设 $V$ 是非空 $n$ 维向量的集合。如果 $V$ 对向量的<strong>加法</strong>和<strong>数乘</strong>运算封闭，即：（1）若 $\displaystyle a,b\in V$ ，有 $\displaystyle a+b\in V$ ；（2）若 $\displaystyle a\in V\quad\lambda \in R(实数)$ ，有 $\displaystyle a\in V\quad\lambda \in R(实数)$ ；则称 $V$ 为一个<font color='red'>向量空间</font>。</p><p><strong>定义 3.7</strong> ：设 $V$ 与 $H$ 都是向量空间，如果 $\displaystyle H\subseteq V$ ，则称 $H$ 是 $V$ 的<font color='red'>子空间</font>。</p><p>特别地，向量空间 $V$ 中仅有零向量组成的集合是 $V$ 的一个子空间，称为<strong>零子空间</strong>。由任何 $n$ 维向量组成的向量空间 $V$ 都是 $\displaystyle R^{n} $ 的子空间。</p><p><strong>定义 3.8</strong> ：已知 $A$ 为 $n$ 阶<strong>方阵</strong>，称映射 $\displaystyle f:R^{n} \longrightarrow R^{n} ,x\longrightarrow  y,y =Ax$ 为 $\displaystyle R^{n} $ 上的线性变换。 $A$ 称为线性变换矩阵。</p><h3 id="3-4-2-向量的内积与正交矩阵"><a href="#3-4-2-向量的内积与正交矩阵" class="headerlink" title="3.4.2 向量的内积与正交矩阵"></a>3.4.2 向量的内积与正交矩阵</h3><p><strong>定义 3.9</strong> ：设 $n$ 维向量 $\displaystyle x = [x_{1},x_{2},\dots ,x_{n} ]^{T} ,y = [y_{1},y_{2},\dots ,y_{n} ]^{T} $ ，称</p><script type="math/tex; mode=display">\displaystyle \left \langle x,y \right \rangle  = x^{T} y=x_{1}y_{1} +x_{2}y_{2}+\dots +x_{n}y_{n}</script><p>为向量 $x,y$ 的<font color='red'>内积</font>。</p><p><strong>内积的性质</strong>：</p><ol><li>$\displaystyle \left \langle x,y \right \rangle  = \left \langle y,x \right \rangle $ ；</li><li>$\displaystyle \left \langle kx,y \right \rangle  = \left \langle x,ky \right \rangle =k \left \langle x,y \right \rangle$ ；</li><li>$\displaystyle \left \langle x+y,z \right \rangle  = \left \langle x,z \right \rangle +\left \langle y,z \right \rangle $ ；</li><li>$\displaystyle \left \langle x,x \right \rangle  \ge 0(\text{ 当且仅当}x=0\text{时取等} )$ ；</li></ol><p><strong>定义 3.10</strong> ：设 $n$ 维向量 $\displaystyle x = [x_{1},x_{2},\dots ,x_{n} ]^{T}$ ，称</p><script type="math/tex; mode=display">\left \| x \right \|  = \sqrt{x^{T} x}  = \sqrt{\left \langle x,x \right \rangle } =\sqrt{x_{1}^{2}+x_{2}^{2}+\dots +x_{n}^{2}}</script><p>为向量 $x$ 的<font color='red'>范数</font>。</p><p><strong>向量的范数的性质</strong>：</p><ol><li>非负性： $\displaystyle \left | x \right | \ge 0(当且仅当x=0时取等)$ ；</li><li>齐次性： $\displaystyle \left | kx \right | =k\left | x \right | $ ；</li><li>三角不等式： $\displaystyle \left | x+y \right | \le \left | x \right | +\left | y \right | $ ；</li><li>特别地，范数为 1 的向量被称为<font color='red'>单位向量</font>；称 $\displaystyle \frac{1}{\left | x \right | } x(x\ne 0)$ 为 $x$ 的单位向量，也称将向量$x$ 单位化，记 $\displaystyle x^{\circ}   =  \frac{1}{\left | x \right | } x$ 。</li></ol><p><strong>定义 3.11</strong> ：设 $x,y$ 是 $n$ 维非零向量，称</p><script type="math/tex; mode=display">\displaystyle \theta  = \arccos \frac{\left \langle x^{T} y \right \rangle }{\left \| x \right \|+\left \| y \right \|  }</script><p>为<font color='red'>向量 $x,y$ 的夹角</font>。特别地，当 $\displaystyle x^{T} y=0$ 时， <script type="math/tex">\displaystyle \theta  = \pm \frac{\pi }{2}</script> ，这时，称向量 $x$ 与 $y$ <font color='red'>正交（或垂直）</font>。显然，零向量与任何向量正交。</p><p>两两正交的向量组称为<font color='red'>正交向量组</font>。由单位向量构成的正交向量组称为标准（规范）正交向量组。</p><p><strong>定理 3.7</strong> ：不含零向量的正交向量组 $\displaystyle a_{1},a_{2} ,\dots ,a_{m}  $ 必定<strong>线性无关</strong>。</p><p>⭐<font color='red'>施密特（Schmidt）正交化方法</font>：</p><p>设向量组 $\displaystyle a_{1},a_{2} ,\dots ,a_{m}  $ 线性无关，令</p><script type="math/tex; mode=display">\begin{align}\displaystyle \beta _{1} & =a_{1} \\\displaystyle \beta _{2} & =a_{2} -\frac{\beta _{1}^{T}a_{2}}{\beta _{1}^{T} \beta _{1}}\beta _{1}\\\displaystyle \beta _{3} & =a_{3} -\frac{\beta _{1}^{T}a_{3}}{\beta _{1}^{T} \beta _{1}}\beta _{1}-\frac{\beta _{2}^{T}a_{3}}{\beta _{2}^{T} \beta _{2}}\beta _{2}\\\displaystyle &\dots \\\displaystyle \beta _{m} & =a_{m} -\sum_{j=1}^{m-1} \frac{\beta _{j}^{T}a_{m}}{\beta _{j}^{T} \beta _{j}}\beta _{j}\\\end{align}</script><p>则 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{m} $ 是与 $\displaystyle a_{1},a_{2} ,\dots ,a_{m}  $ 等价的正交向量组。</p><p><strong>定理 3.12</strong> ：设 $A$ 为 $n$ 阶方阵。若满足 $\displaystyle A^{T} A=E$ ，则称 $A$ 为正交矩阵。</p><p><strong>定理 3.8</strong> ： $n$ 阶方阵 $A$ 为正交矩阵的<strong>充分必要</strong>条件为$A$ 的列（行）向量组是标准正交组。</p><h2 id="3-5-基、维数与坐标"><a href="#3-5-基、维数与坐标" class="headerlink" title="3.5 基、维数与坐标"></a>3.5 基、维数与坐标</h2><h3 id="3-5-1-向量空间的基与维数"><a href="#3-5-1-向量空间的基与维数" class="headerlink" title="3.5.1 向量空间的基与维数"></a>3.5.1 向量空间的基与维数</h3><p><strong>定义 3.13</strong> ：设 $V$ 是向量空间，如果向量 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}  \in V$ ，满足</p><ol><li>$\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 线性无关；</li><li>$V$ 中的任一向量都可由 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 线性表示；</li></ol><p>则称向量组 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是向量空间 $V$ 的一组<font color='red'>基</font>， $r$ 称为向量空间 $V$ 的<font color='red'>维数</font>，记为 $\displaystyle \text{dim}V=r $ ，<strong>规定零向量构成的向量空间维数为零</strong>。</p><p>若 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是向量空间 $V$ 的<strong>两两正交</strong>的一组基，则称 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是向量空间 $V$ 的<strong>正交基</strong>。当 $\displaystyle a_{1},a_{2} ,\dots ,a_{r}$ 是单位向量时，称 <script type="math/tex">\displaystyle a_{1},a_{2} ,\dots ,a_{r}</script> 是向量空间 $V$ 的<font color='red'>标准正交基（或规范正交基）</font>。如 $\displaystyle e_{1} ,e_{2},\dots ,e_{n}$ 是向量空间 $R^{n}$ 的一组标准正交基。</p><h3 id="3-5-2-向量的坐标"><a href="#3-5-2-向量的坐标" class="headerlink" title="3.5.2 向量的坐标"></a>3.5.2 向量的坐标</h3><p><strong>定义 3.14</strong> ：设 $V$ 是 $n$ 维向量空间， $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 是 $V$ 的一组基，则 $V$ 中的任一向量 $x$ 可由$\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ <strong>唯一线性表示</strong>为 $\displaystyle x = x_{1} a_{1} +x_{2}a_{2}+\dots +x_{n}a_{n}$ ，数组 $\displaystyle x_{1} ,x_{2},\dots ,x_{n}$ 称为向量 $x$ 在基 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 下的<font color='red'>坐标</font>，记为 $\displaystyle [x_{1} ,x_{2},\dots ,x_{n}]^{T} $ 。</p><p>设 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 与 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{n} $ 是 $n$ 维向量空间 $V$ 的两组基，则 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 与 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{n} $ 等价，从而 $\displaystyle \beta _{j}  = k_{1j}a_{1} +k_{2j}a_{2} +\dots +k_{nj}a_{n}\quad (j = 1,2,\dots ,n)  $ ，即</p><script type="math/tex; mode=display">\displaystyle \left [ \beta _{1},\beta _{2},\dots ,\beta _{n}  \right ] =\left [ \alpha  _{1},\alpha_{2},\dots ,\alpha _{n}  \right ] \begin{bmatrix} k_{11}  & \dots  &  k_{1n}\\ \vdots  & \ddots  & \vdots \\  k_{n1} & \dots  & k_{nn}\end{bmatrix}=\left [ \alpha  _{1},\alpha_{2},\dots ,\alpha _{n}  \right ] K</script><p>称矩阵 $K$ 为由基 $\displaystyle a_{1} ,a_{2},\dots ,a_{n}$ 到基 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{n} $ 的<font color='red'>过渡矩阵</font>，并称上式为由基 <script type="math/tex">\displaystyle a_{1} ,a_{2},\dots ,a_{n}</script> 到基 $\displaystyle \beta _{1} ,\beta _{2} ,\dots  ,\beta _{n} $ 的<font color='red'>基变换公式</font>，<strong>过度矩阵 $K$ 是可逆的</strong>。🍁</p><h2 id="3-6-线性方程组解的结构"><a href="#3-6-线性方程组解的结构" class="headerlink" title="3.6 线性方程组解的结构"></a>3.6 线性方程组解的结构</h2><p><strong>定理 3.9</strong> ：（1）线性方程$\displaystyle Ax=b$ 有解的充分必要条件为 $\displaystyle R(A) = R(\widetilde{A} )$ ；（2）若 $\displaystyle R(A) = R(\widetilde{A} ) = r$ ，则 $\displaystyle Ax=b$ 当且仅当 $r = n$ 时，有<strong>唯一解</strong>。</p><h3 id="3-6-1-齐次方程方程组解的结构"><a href="#3-6-1-齐次方程方程组解的结构" class="headerlink" title="3.6.1 齐次方程方程组解的结构"></a>3.6.1 齐次方程方程组解的结构</h3><p><strong>性质 3.1</strong> ：设 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n} $ 是 $Ax=0$ 的解，则 $\displaystyle c_{1} \xi _{1} +c_{2}\xi _{2} +\dots +c_{n}\xi _{n} $ 也是 $Ax=0$ 的解，其中 $c_{i}$ 为任意常数。</p><p>证明：因为$\displaystyle A(c_{1} \xi _{1} +c_{2}\xi _{2} +\dots +c_{n}\xi _{n} ) = c_{1}A\xi _{1} +c_{2}A\xi _{2}+\dots +c_{n}A\xi _{n}=0$ ，所以</p><script type="math/tex; mode=display">\displaystyle c_{1} \xi _{1} +c_{2}\xi _{2} +\dots +c_{n}\xi _{n}</script><p>也是 $Ax=0$ 的解。</p><p>🔥由此性质可知，对齐次线性方程组 $Ax=0$ 的任意两个解$x,y$ ，有 $x+y$ 和 $\lambda x$ 仍然为齐次方程组的解，即 $Ax=0$ 的解集 $N(A)$ 为向量空间，称之为齐次线性方程组 $Ax=0$ 的<font color='red'>解空间</font>。</p><p>齐次线性方程组 $Ax=0$ 的解空间的一组基 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 也称为 $Ax=0$ 的一个<font color='red'>基础解系</font>。换言之，基础解系 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 是 $Ax=0$ 的解向量，且满足</p><ol><li>$\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 线性无关；</li><li>$Ax=0$ 的任一解均由 $\displaystyle \xi _{1} ,\xi _{2} ,\dots ,\xi _{n-r} $ 线性表示；</li></ol><p><strong>定理 3.10</strong> ：设 $n$ 元齐次线性防尘组 $\displaystyle A_{m\times n} x=0,R(A)=r\le n$ ，则 $Ax=0$ 的解空间的维数为 $n-r$ </p><p><strong>推论 3.2</strong> ：若 $\displaystyle A_{m\times n} B_{n\times s} =0$ ，则 $\displaystyle R(A)+R(B)\le n$ 。</p><h3 id="3-6-2-非齐次线性方程组解的结构"><a href="#3-6-2-非齐次线性方程组解的结构" class="headerlink" title="3.6.2 非齐次线性方程组解的结构"></a>3.6.2 非齐次线性方程组解的结构</h3><p><strong>性质 3.2</strong> ：设 $\displaystyle \eta _{1},\eta _{2},\dots ,\eta _{n} $ 为 $\displaystyle Ax=b$ 的解，且 $\displaystyle \eta  = c_{1}\eta _{1}+c_{2}\eta _{2}+\dots +c_{n}\eta _{n}  $ 。</p><ul><li>当 $\displaystyle c_{1} +c_{2}+\dots +c_{n}=0$ 时， $\eta $ 为 $\displaystyle Ax=0$ 的解；</li><li>当 $\displaystyle c_{1} +c_{2}+\dots +c_{n}=1$ 时， $\eta $ 为 $\displaystyle Ax=b$ 的解；</li><li>特别地， $\displaystyle \frac{1}{n}\sum_{k=1}^{n} \eta _{k}$ 为 $\displaystyle Ax=b$ 的解。</li></ul><p><strong>性质 3.3</strong> ：设 $\xi $ 为 $\displaystyle Ax=0$ 的解， $\eta $ 为 $\displaystyle Ax=b$ 的解，那么 $x = \xi +  \eta $  仍为 $\displaystyle Ax=b$ 的解。</p><h2 id="3-7-超定线性方程组的最小二乘解"><a href="#3-7-超定线性方程组的最小二乘解" class="headerlink" title="3.7 超定线性方程组的最小二乘解"></a>3.7 超定线性方程组的最小二乘解</h2><p>（<em>略</em>）</p><h1 id="四、相似矩阵与二次型"><a href="#四、相似矩阵与二次型" class="headerlink" title="四、相似矩阵与二次型"></a>四、相似矩阵与二次型</h1><h2 id="4-1-特征值与特征向量"><a href="#4-1-特征值与特征向量" class="headerlink" title="4.1 特征值与特征向量"></a>4.1 特征值与特征向量</h2><h3 id="4-1-1-定义与计算"><a href="#4-1-1-定义与计算" class="headerlink" title="4.1.1 定义与计算"></a>4.1.1 定义与计算</h3><p><strong>定义 4.1</strong> ：设 $\displaystyle A = (a_{ij} )$ 为 $n$ 阶方阵，如果存在数 $\lambda $ 和 $n$ 维<strong>非零列向量</strong> $a$ ，使得</p><script type="math/tex; mode=display">\displaystyle Aa = \lambda a</script><p>则称数 $\lambda $ 为矩阵 $A$ 的<font color='red'>特征值</font>，非零列向量 $a$ 称为矩阵 $A$ 的对应于特征值 $\lambda $ 的<font color='red'>特征向量</font>。</p><p>由上式可知， $a$ 是矩阵 $A$ 对应于特征值 $\lambda $ 的特征向量，则 $a$ 必定是 $n$ 元齐次线性方程组</p><script type="math/tex; mode=display">\displaystyle (\lambda E-A)x = 0</script><p>的非零解；反过来，齐次线性方程组的任一非零解，也一定是 <script type="math/tex">A</script> 对应于特征值 <script type="math/tex">\lambda</script> 的特征向量。由线性方程组解的理论可知，齐次线性方程组有非零解的充分必要条件是其系数矩阵的行列式 <script type="math/tex">\displaystyle \left | \lambda E-A \right |</script> 的值等于零，即</p><script type="math/tex; mode=display">\displaystyle \left | \lambda E-A \right |  = \begin{vmatrix} \lambda -a_{11}  & -a_{12} & \dots  & -a_{1n}\\ -a_{21} &\lambda-a_{22} & \cdots  &-_{2n}  \\\vdots  & \vdots  & \ddots  & \vdots \\ -a_{n1} & -a_{n2} & \cdots  &\lambda-a_{nn}\end{vmatrix}=0</script><p>设 <script type="math/tex">A</script> 为 <script type="math/tex">n</script> 阶矩阵，那么矩阵 <script type="math/tex">\displaystyle \lambda E-A</script> 称为 <script type="math/tex">A</script> 的<font color='red'>特征矩阵</font>，其行列式 <script type="math/tex">\displaystyle \left | \lambda E-A \right |</script> 是 <script type="math/tex">\displaystyle \lambda</script> 的一元 <script type="math/tex">n</script> 次多项式，称为 <script type="math/tex">A</script> 的<font color='red'>特征多项式</font>，方程 <script type="math/tex">\displaystyle \left | \lambda E-A \right | =0</script> 称为 <script type="math/tex">A</script> 的特征方程。</p><h3 id="4-1-2-特征值与特征向量的性质"><a href="#4-1-2-特征值与特征向量的性质" class="headerlink" title="4.1.2 特征值与特征向量的性质"></a>4.1.2 特征值与特征向量的性质</h3><p><strong>性质 4.1</strong> ：设 $\lambda $ 是 $n$ 阶矩阵 $A$ 的任一特征值， $a$ 为其对应的特征向量，则 $f(\lambda)$ 是矩阵多项式 $f(A)$ 的特征值，其对应的特征向量仍为 $a$ ，其中 $\displaystyle f(x) = a_{0} x^{m}+\dots + a_{m-1} x+a_{m} $ ，即为 $x$ 的 $m$ 次多项式。</p><p><strong>性质 4.2</strong> ：设 $\lambda $ 为 $n$ 阶矩阵$A$ 的任一非零特征值， $a$ 为其对应的特征向量，则 $A$ 的伴随矩阵 $\displaystyle A^{\ast }$ 的特征值为 $\displaystyle \frac{\left | A \right | }{\lambda } $ 。</p><p><strong>性质 4.3</strong> ：若矩阵 $A$ 可逆，则 $\displaystyle \frac{1 }{\lambda } $ 是 $A^{-1}$ 的特征值。</p><p><strong>性质 4.4</strong> ：设 $n$ 阶矩阵$\displaystyle A=(a_{ij} )$ 的 $n$ 个特征值为 $\displaystyle \lambda _{1} , \lambda _{2}, \dots , \lambda _{n}$ （重根按重数计算），则</p><ol><li>$\displaystyle \lambda _{1} +\lambda _{2}+\dots +\lambda _{n} = a_{1}+a_{2}+\dots +a_{n} $ ；</li><li>$\displaystyle \lambda _{1}\lambda _{2}\dots\lambda _{n} = \left | A \right | $ ；</li></ol><p><strong>推论 4.1</strong> ：设 <script type="math/tex">A</script> 为 $n$ 阶矩阵，则 $A$ 可逆的充分必要条件是 $A$ 的所有特征值均<strong>非零</strong>。</p><p> $n$ 阶方阵 $A$ 的<strong>主对角线</strong>上所有元素之和 $\displaystyle a_{11}+a_{22}+\dots +  a_{nn}$ 称为 $A$ 的<font color='red'>迹</font>，记作 $\displaystyle \text{tr}(A) $ ，即</p><script type="math/tex; mode=display">\displaystyle \text{tr}(A) =a_{11}+a_{22}+\dots +  a_{nn}</script><p><strong>定理 4.1</strong> ：若 $\displaystyle \lambda _{1} , \lambda _{2}, \dots , \lambda _{m}$ 是矩阵 $A$ 互不相同的特征值，  $\displaystyle a_{1} ,a_{2},\dots ,a_{m}$ 是对应的特征向量，则  $\displaystyle a_{1} ,a_{2},\dots ,a_{m}$ 线性无关。</p><p><strong>定理 4.2</strong> ：设 $\lambda $ 为 $n$ 阶矩阵 $A$ 的一个 $k$ 重特征值，对应于特征值 $\lambda $ 的线性无关的特征向量的最大个数为 $l$ ，则 $k\ge l$ 。</p><p><strong>推论 4.2</strong> ：设 $\displaystyle \lambda _{1} , \lambda _{2}, \dots , \lambda _{m}$ 是 $n$ 阶矩阵 $A$ 的 $m$ 个互不相同的特征值， $\displaystyle a_{i1},a_{i2},\cdots ,a_{ik_{i} }$ 是矩阵 $A$ 对应于特征值 $\displaystyle\lambda _{i} $ 的线性无关的特征向量，则向量组</p><script type="math/tex; mode=display">\displaystyle a_{11},\dots ,a_{1k_{1} },a_{21},\dots ,a_{2k_{2} },\cdots ,a_{m1},\dots ,a_{mk_{m} }</script><p>线性无关。</p><h2 id="4-2-相似矩阵"><a href="#4-2-相似矩阵" class="headerlink" title="4.2 相似矩阵"></a>4.2 相似矩阵</h2><h3 id="4-2-1-相似矩阵的定义与性质"><a href="#4-2-1-相似矩阵的定义与性质" class="headerlink" title="4.2.1 相似矩阵的定义与性质"></a>4.2.1 相似矩阵的定义与性质</h3><p><strong>定义 4.2</strong> ：设 $A,B$ 为 $n$ 阶矩阵，若存在 $n$ 阶可逆矩$P$ ，使得</p><script type="math/tex; mode=display">\displaystyle P^{-1} AP=B</script><p>则称 $A$ 与 $B$ <font color='red'>相似</font>，记作 $\displaystyle A\sim B$ 。相似是矩阵之间的一种等价关系，并且具有以下性质：</p><ol><li>自反性： 对任意 $n$ 阶矩阵 $A$ ，有 $\displaystyle A\sim A$ ；</li><li>对称性： 若 $\displaystyle A\sim B$ ，则 $\displaystyle B\sim A$ ；</li><li>传递性：若 $\displaystyle A\sim B,B\sim C$ ，则 $\displaystyle A\sim C$ 。</li><li></li></ol><p><strong>定理 4.3</strong> ：如果 $n$ 阶矩阵$A,B$ 相似，则$A$ 与 $B$ 有相同的特征多项式，从而有相同的特征值。</p><p><strong>注意：特征多项式相等是矩阵相似的必要条件，而不是充分条件</strong>。</p><p><strong>性质 4.5</strong> ：若 $A$ 与 $B$ 相似，则有以下结论：</p><ol><li>$A$ 与 $B$ 有相同的<strong>秩</strong>，即 $\displaystyle R(A)=R(B)$ ；</li><li>$A$ 与 $B$ 有相同的<strong>迹</strong>，即 $\displaystyle \text{tr} (A)=\text{tr}(B)$ ；</li><li>$A$ 与$B$ 有相同的<strong>行列式</strong>，即 $\displaystyle \left | A \right | =\left | B \right | $ ；</li><li>若 $\displaystyle A\sim B$ ，且矩阵 $A$ 可逆，则矩阵$B$ 也可逆，且 $\displaystyle A^{-1} \sim B^{-1} $ 。</li></ol><h3 id="4-2-2-矩阵对角化的条件"><a href="#4-2-2-矩阵对角化的条件" class="headerlink" title="4.2.2 矩阵对角化的条件"></a>4.2.2 矩阵对角化的条件</h3><p><strong>定义 4.3</strong> ：设$A$ 为 $n$ 阶矩阵，如果存在一个 $n$ 阶可逆矩阵 $P$ ，使得 $\displaystyle P^{-1}  AP$ 为对角矩阵，则称 $A$ <font color='red'>可对角化</font>。</p><p><strong>定理 4.4</strong> ： $n$ 阶矩阵 $A$ 可对角化的充分必要条件是 $A$ 有 $n$ 个线性无关的特征向量。</p><p><strong>推论 4.3</strong> ：如果 $n$ 阶矩阵 $A$ 的 $n$ 个特征值互不相同，则 $A$ 一定可以对角化。</p><p><strong>定理 4.5</strong> ： $n$ 阶矩阵 $A$ 可对角化的充分必要条件是对于 $A$ 的每个 $k$ 重特征值 $\lambda $ ，则有 $\displaystyle R(\lambda E-A) = n-k$ 。</p><h2 id="4-3-实对称矩阵的对角化"><a href="#4-3-实对称矩阵的对角化" class="headerlink" title="4.3 实对称矩阵的对角化"></a>4.3 实对称矩阵的对角化</h2><p><strong>定理 4.6</strong> ：实对称矩阵的特征值都为实数。</p><p><strong>定理 4.7</strong> ：<strong>实对称矩阵不同特征值所对应的特征向量必定正交</strong>。</p><p><strong>定理 4.8</strong> ：设 $A$ 为 $n$ 阶实对称矩阵，则存在正交矩阵 $Q$ ，使得</p><script type="math/tex; mode=display">\displaystyle Q^{T} AQ = Q^{-1} AQ =\begin{bmatrix} \lambda _{1}  &  &  & \\  &  \lambda _{2} &  & \\  &  & \ddots  & \\  &  &  & \lambda _{n}\end{bmatrix}</script><p>其中 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{n} $ 为 $A$ 的特征值。</p><p><strong>推论 4.4</strong> ：设 $A$ 为 $n$ 阶实对称矩阵， $\lambda$ 为 $A$ 的 $k$ 重特征值，则 $A$ 必有 $k$ 个对应于特征值 $\lambda$ 的线性无关的特征向量。</p><p>🔥🔥🔥对于实对称矩阵 $A$ ，求正交矩阵 $Q$ ，使 $\displaystyle Q^{T} AQ$ 为对角矩阵的步骤如下：</p><ol><li><p>求 <script type="math/tex">A</script> 的全部不同的特征值 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{s} $ ；</p></li><li><p>对每个特征值 $\displaystyle \lambda _{i}$ ，求出齐次线性方程组 $\displaystyle \left ( \lambda _{i}E-A \right ) x=0$ 的基础解系，将其正交化、单位化；</p></li><li><p>所得到的正交单位特征向量组构成的正交矩阵 $Q$ ，则</p><script type="math/tex; mode=display"> \displaystyle Q^{T} AQ = Q^{-1} AQ = \begin{bmatrix}  \lambda _{1}  &  &  & \\   &  \lambda _{2} &  & \\   &  & \ddots  & \\   &  &  & \lambda _{n} \end{bmatrix}</script></li></ol><h2 id="4-4-二次型及其标准形"><a href="#4-4-二次型及其标准形" class="headerlink" title="4.4 二次型及其标准形"></a>4.4 二次型及其标准形</h2><h3 id="4-4-1-二次型定义"><a href="#4-4-1-二次型定义" class="headerlink" title="4.4.1 二次型定义"></a>4.4.1 二次型定义</h3><p><strong>定义 4.4</strong> ： $n$ 个变量 $\displaystyle x_{1},x_{2},\cdots ,x_{n} $ 的二次齐次多项式</p><script type="math/tex; mode=display">\begin{align}\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )  = &a_{11}x_{1}^{2}+2a_{12}x_{1}x_{2}+\dots +2a_{1n}x_{1}x_{n}\\&+a_{22}x_{2}^{2}+\dots + 2a_{2n}x_{2}x_{n}\\&+\dots +a_{nn}x_{n}^{2}                 \end{align}</script><p>称为 $n$ 元<font color='red'>二次型</font>。 $a_{ij}$ 称为二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 的系数，当 $a_{ij}$ 为实数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>实二次型</strong>；当 $a_{ij}$ 为复数时，称 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} )$ 为<strong>复二次型</strong>。</p><p>二次型可以表示为</p><script type="math/tex; mode=display">\displaystyle f(x) =x^{T} Ax</script><p>其中 $\displaystyle A = A^{T} $ 为实对称矩阵，将上式称为二次型的矩阵形式，对称矩阵 $A$ 称为二次型的矩阵， $A$ 的秩称为<strong>二次型的秩</strong>。</p><p><strong>仅含平方项的二次型称为<font color='red'>标准形</font></strong>。很显然，二次型 $\displaystyle x^{T} Ax$ 为标准形的<strong>充分必要</strong>条件是 $A$ 为对角矩阵。研究二次型的目的之一，就是寻找一个线性变化将其化为标准形。</p><h3 id="4-4-2-矩阵的合同"><a href="#4-4-2-矩阵的合同" class="headerlink" title="4.4.2 矩阵的合同"></a>4.4.2 矩阵的合同</h3><p><strong>定义 4.5</strong> ：设 $A,B$ 为 $n$ 阶矩阵。如果存在可逆矩阵$C$ ，使 $\displaystyle C^{T} AC=B$ ，则称 $A$ 与 $B$ 是<font color='red'>合同的</font>，记作 $\displaystyle A\simeq B$ 。</p><p>矩阵的合同也是一种等价关系，它具有下面性质：</p><ol><li>自反性：对任意 $n$ 阶矩阵，有 $\displaystyle A\simeq A$ ；</li><li>对称性：若 $\displaystyle A\simeq B$ ，则$\displaystyle B\simeq A$ ；</li><li>传递性：若 $\displaystyle A\simeq B,B\simeq C$ ，则 $\displaystyle A\simeq C$ 。</li></ol><p><strong>定理 4.9</strong> ：设 $n$ 阶矩阵$A$ 与 $B$ 合同，且 $A$ 为对称矩阵，则 $B$ 也是对称矩阵，且</p><script type="math/tex; mode=display">\displaystyle R(A) = R(B)</script><h3 id="4-4-3-化二次型为标准形"><a href="#4-4-3-化二次型为标准形" class="headerlink" title="4.4.3 化二次型为标准形"></a>4.4.3 化二次型为标准形</h3><ol><li><p>正交变换法</p><p> ​    若 $Q$ 为正交矩阵，则称线性变换 $\displaystyle x = Qy$ 为<font color='red'>线性变换</font>。容易验证，正交变换保持向量的内积、长度和夹角不变，因而正交变换保持几何图形的大小和形状不变。</p><p> ​    <strong>定义 4.10</strong> ：对于任意 $n$ 元实二次型</p><script type="math/tex; mode=display"> \displaystyle f(x_{1},x_{2},\cdots ,x_{n} ) = x^{T} Ax</script><p> ​    总存在正交变换 $\displaystyle x = Qy$ ，使</p><script type="math/tex; mode=display"> \displaystyle f(x)\overset{x=Qy}{= } \lambda _{1}y_{1}^{2} +\lambda _{2}y_{2}^{2}+\dots +\lambda _{n}y_{n}^{2}</script><p> ​    其中 $\displaystyle \lambda _{1},\lambda _{2},\dots ,\lambda _{n} $ 为 $A$ 的全部特征值。</p></li><li><p>配方法</p><p> ​    利用公式 $\displaystyle (a\pm b)^{2} = a^{2}\pm 2ab+b^{2} $ 和 $\displaystyle (a-b)(a+b) = a^{2}-b^{2}$    将二次型配成标准形的方法，称为<strong>配方法</strong>。</p></li><li><p>初等变换法</p></li></ol><p><strong>定理 4.11</strong> ：任何实二次型 $\displaystyle f(x_{1},x_{2},\cdots ,x_{n} ) = x^{T} Ax$ 总可以经过适当的可逆线性变换化为规范形，而且规范形是唯一的。</p><p><strong>定义 4.6</strong> ：实二次型 $\displaystyle f(x) = x^{T} Ax$ 的标准形中正平方项的个数 $p$ 称为二次型 $f$ 的<font color='red'>正惯性指数</font>；负平方项的个数 $q$ 称为二次型 $f$ 的<font color='red'>负惯性指数</font>；它们的差 $p-q$ 称为二次型 $f$ 的<font color='red'>符号差</font>。</p><h2 id="4-5-正定二次型"><a href="#4-5-正定二次型" class="headerlink" title="4.5 正定二次型"></a>4.5 正定二次型</h2><p>在数学、物理、力学领域中都有广泛应用的实二次型———<font color='red'>正定二次型</font>。</p><p><strong>定义 4.7</strong> ：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax$ 为 $n$ 个变量的实二次型。</p><p>（1）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax >0\quad(<0)</script><p>则称 $f = x^{T} Ax$ 为<strong>正定（负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>正定（负定）矩阵</strong>。</p><p>（2）如果对任何非零向量 $x = (x_{1},x_{2},\dots ,x_{n} )$ ，都有</p><script type="math/tex; mode=display">\displaystyle f(x_{1},x_{2},\dots ,x_{n} )  = x^{T} Ax \ge 0\quad(\le 0)</script><p>则称 $f = x^{T} Ax$ 为<strong>半正定（半负定）二次型</strong>，并称二次型矩阵 $A$ 为<strong>半正定（半负定）矩阵</strong>。</p><p>（3）如果二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n} )$ 既不是半正定，也不是半负定的，就称 $f = x^{T} Ax$ 为不定的，矩阵 $A$ 称为<strong>不定矩阵</strong>。</p><hr><p><strong>定理 4.13</strong>：可逆的线性变换不改变二次型的正定性。</p><p><strong>推论 4.5</strong>：设 $n$ 阶实矩阵 $A$ 与 $B$ 合同，则 $A$ 正定的充分必要条件是 $B$ 也正定。</p><p><strong>定理 4.14</strong>：设 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 是 $n$ 元实二次型，则下面命题等价：</p><ol><li>$\displaystyle f = x^{T} Ax$ 是正定二次型，即矩阵 $A$ 是正定矩阵；</li><li>$A$ 的特征值均为正数；</li><li>$\displaystyle f = x^{T} Ax$ 的正惯性指数为 $n$ ；</li><li>$A$ 与单位矩阵 $E$ 合同；</li><li>存在可逆矩阵 $B$ ，使得 $\displaystyle A = B^{T} B$ 。</li></ol><p><strong>推论 4.6</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶正定矩阵，则：</p><ol><li>矩阵 $A$ 的主对角线元 $\displaystyle a_{ij}&gt; 0$ ；</li><li>矩阵 $A$ 的行列式 $\displaystyle \left | A \right | &gt; 0$ 。</li></ol><p><strong>定义 4.8</strong>：设 $\displaystyle A = (a_{ij} )$ 是 $n$ 阶方阵，依次取 $A$ 的前 $k$ 行与前 $k$ 列所构成的子式</p><script type="math/tex; mode=display">\Delta _{k}  = \begin{bmatrix} a_{11}  & a_{12} & \dots  &a_{1k}\\ a_{21} & a_{22} & \dots  &a_{2k} \\\vdots   & \cdots  & \ddots  &\vdots  \\ a_{k1} &  a_{k2} & \dots  & a_{kk}\end{bmatrix},\quad k = 1,2,\dots ,n</script><p>称为矩阵 $A$ 的 <strong>$k$ 阶顺序主子式</strong>。</p><p><strong>定理 4.1.5</strong>： $n$ 元实二次型 $\displaystyle f(x_{1},x_{2},\dots ,x_{n}) = x^{T} Ax$ 正定的充要条件是 $A$ 的 $n$ 个顺序主子式均大于零，该定理也称为<strong>霍尔维茨定理</strong>。</p><p><strong>推论 4.7</strong>：对于 $n$ 元实二次型 $\displaystyle f = x^{T} Ax$ ，则下面命题等价：</p><ol><li>$f$ 是负定二次型；</li><li>$f$ 的负惯性指数为 $n$ ；</li><li>$A$ 的特征值全为负数；</li><li>$A$ 合同于 $-E$ ；</li><li>$A$ 的奇数阶顺序主子式全为负数，偶数阶顺寻主子式全为正数。</li></ol><h1 id="五、线性空间与线性变换"><a href="#五、线性空间与线性变换" class="headerlink" title="五、线性空间与线性变换"></a>五、线性空间与线性变换</h1><h2 id="5-1-线性空间"><a href="#5-1-线性空间" class="headerlink" title="5.1 线性空间"></a>5.1 线性空间</h2><h3 id="5-1-1-线性变换"><a href="#5-1-1-线性变换" class="headerlink" title="5.1.1 线性变换"></a>5.1.1 线性变换</h3><p><strong>定义 5.1</strong>：设 $F$ 是一个包含数 0 和 1 的集合，如果  $F$ 中任意两个数的和、差、积、商都在 $F$ 中，则称 $F$ 是一个<strong><font color='red'>数域</font></strong>。</p><p>有理数集 $Q$ 、实数集 $R$、复数集 $C$ 都是数域，他们分别称为<strong>有理数域</strong>、<strong>实数域</strong>、<strong>复数域</strong>。</p><p>若集合 $V$ 中定义了某种运算， $V$ 中的任意元素进行运算所得到的结果均在 $V$ 中，则称这种运算是封闭的。</p><h3 id="5-1-2-线性空间"><a href="#5-1-2-线性空间" class="headerlink" title="5.1.2 线性空间"></a>5.1.2 线性空间</h3><p><strong>定义 5.2</strong>：设 $V$ 是一个非空集合。其元素用 $\displaystyle \alpha ,\beta, \gamma ,\delta ,\dots $ 表示，$F$ 是一个数域，其元素用 $\displaystyle k,l,m,n,\dots $ 表示。并且满足下面条件：</p><ol><li>在集合 $V$ 的元素之间定义了一种运算，叫做加法。即对于 $V$ 中任意两个元素 $\alpha$ 和 $\beta  $  ，在 $V$ 中都有唯一的元素 $\gamma $ 与之对应，称为 $\alpha$ 和 $\beta  $ 的和，记作 $\gamma  = \alpha +\beta $ 。</li><li>在数域 $F$ 的数与集合 $V$ 的元素之间定义了一种运算，叫做数量乘法，也就是说，对于 $F$ 任意一个数 $k$ 与 $V$ 中任一元素 $\alpha$ ，在 $V$ 中都有唯一的元素 $\delta $ 与之对应，$\delta  = k\alpha $ 称为 $k$ 与 $\alpha$ 的数量积。</li><li>$V$ 中定义的加法与数量乘法满足下列运算律：<ol><li>$\alpha +\beta  = \beta +\alpha $ ；</li><li>$(\alpha +\beta)+ \gamma  = \alpha +(\beta +\gamma )$ ；</li><li>在 $V$ 中有一个元素 <strong>0</strong> ，对 $V$ 中任一元素 $\alpha$ ，都有 $\alpha +0 = \alpha $ （具有这性质的元素称为零元素）；</li><li>对于 $V$ 中每一元素 $\alpha$ ，都有 $V$ 中元素 $\beta $ ，使 $\alpha +\beta =0$ ，称 $\beta $ 为 $\alpha$ 的负元素；</li><li>$k(\alpha +\beta ) = k\alpha +k\beta $ ；</li><li>$(k+l)\alpha  = k\alpha +l\alpha $ ；</li><li>$k(l\alpha ) = (kl)\alpha $ ；</li><li>$1\alpha  = \alpha $ ；</li></ol></li></ol><p>则称 $V$ 为数域 $F$ 上的<font color='red'><strong>线性空间（或向量空间）</strong></font>，简称 $V$ 的<strong>线性空间</strong>或<strong>向量空间</strong>。</p><p> $V$ 中所定义的加法以及数量乘法运算统称为 $V$ 的<strong>线性运算</strong>。 $V$ 中的元素也称为向量， $F$ 中的元素也称为<strong>数量</strong>或<strong>标量</strong>。当 $F$ 为实数域 $R$ 时，称 $V$ 为<strong>实线性空间</strong>；当 $F$ 为复数域  $C$ 时，称 $V$ 为<strong>复线性空间</strong>。</p><h3 id="5-1-3-线性空间的性质"><a href="#5-1-3-线性空间的性质" class="headerlink" title="5.1.3 线性空间的性质"></a>5.1.3 线性空间的性质</h3><p><strong>性质 5.1</strong>：零向量是唯一的。</p><p><strong>性质 5.2</strong>：向量空间 $V$ 中的每个向量的复向量是唯一的。</p><p><strong>性质 5.3</strong>：对向量空间 $V$ 中任一向量 $\alpha $ 与任一数 $k$ ，有 $0\alpha =0$ ；$k0=0$ ；$(-1)\alpha =\alpha $ 。</p><h3 id="5-1-4-线性子空间"><a href="#5-1-4-线性子空间" class="headerlink" title="5.1.4 线性子空间"></a>5.1.4 线性子空间</h3><p><strong>定义5.3</strong>：若 $W$ 为数域 $F$ 上的线性空间 $V$ 的非空子集，且 $W$ 满足如下条件：</p><ol><li>对任意的 $k\in F$ ，$a\in W$ ，则 $k\alpha \in W$ ；</li><li>对任意的 $\alpha ,\beta \in W$ ，则 $\alpha+\beta \in W$ ；</li></ol><p>则称 $W$ 为 $V$ 的<font color='red'>线性子空间</font>，简称<strong>子空间</strong>。换句话说，当且仅当 $W$ 对 $V$ 中的加法与数乘运算是封闭的，$W$ 是向量空间 $V$ 的子空间。</p><p>若 $W$ 是线性空间 $V$ 的子空间，由定义 <code>5.3</code> 不难得出，它也是线性空间。</p><h2 id="5-2-线性空间的基与向量坐标"><a href="#5-2-线性空间的基与向量坐标" class="headerlink" title="5.2 线性空间的基与向量坐标"></a>5.2 线性空间的基与向量坐标</h2><h3 id="5-2-1-基、维数、坐标"><a href="#5-2-1-基、维数、坐标" class="headerlink" title="5.2.1 基、维数、坐标"></a>5.2.1 基、维数、坐标</h3><p><strong>定义 5.4</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中的 $m$ 个向量， $k_{1} ,k_{2} ,\cdots ,k_{m} $ 是 $F$ 中的数，则称 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = \beta $ 为向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 的一个线性组合，或者 $\beta $ 可由向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 线性表示。</p><p><strong>定义 5.5</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ 是数域 $F$ 上的线性空间 $V$ 中向量，若存在 $F$ 中不全为零的数 $k_{1},k_{2},\dots ,k_{m}$ ，使 $k_{1}a_{1}+k_{2}a_{2}+\cdots +k_{m}a_{m} = 0$ ，则称向量组 $\displaystyle a_{1} ,a_{2} ,\dots, a_{m} $ <strong>线性相关</strong>；否则称向量组<strong>线性无关</strong>。</p><p><strong>定义 5.6</strong>：设 $V$ 是数域 $F$ 上的线性空间， $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $V$ 中 $n$ 个线性无关的向量，若 $V$ 中任一向量 $a$ 均可由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 线性表示，则称线性空间 $V$ 是 <strong>$n$ 维线性空间</strong>， $n$ 称为 $V$ 的<strong>维数</strong>，记作： $\text{dim} V = n$ ，而称 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 为 $V$ 的一组<strong>基</strong>。如果 $V$ 中有任意多个线性无关向量，则称 <script type="math/tex">V</script> 是<strong>无限维线性空间</strong>。</p><p><strong>定义 5.7</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 是 $n$ 维线性空间 $V$ 的一组基，$\beta \in V$ 且有</p><script type="math/tex; mode=display">\beta = x_{1}a_{1}+x_{2}a_{2} +\dots  +x_{n}a_{n}</script><p>则称 $(x_{1},x_{2},\dots ,x_{n} )^{T} $ 为 $\beta $ 在基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 下的坐标向量。</p><h3 id="5-2-2-基变换与坐标变换"><a href="#5-2-2-基变换与坐标变换" class="headerlink" title="5.2.2 基变换与坐标变换"></a>5.2.2 基变换与坐标变换</h3><p>设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，则 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 可由 $V$ 的基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 表示：</p><script type="math/tex; mode=display">\left\{\begin{matrix} \beta _{1}  & = & b_{11}a _{1}   & + & b_{21}a _{2} & + & \dots  & + & b_{n1}a _{n}\\ \beta _{2} & = & b_{12}a _{1} & + & b_{22}a _{2} & + & \dots  & + & b_{n2}a _{n}\\  &  & \vdots  &  &  &  &  &  & \\ \beta _{n} & = & b_{1n}a _{1}   & + & b_{2n}a _{2}   & + & \dots  & + &b_{nn}a _{n}  \end{matrix}\right.</script><p>或者写成矩阵形式</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) \begin{bmatrix} b_{11}  & b_{12}  &  \cdots &  b_{1n}\\ b_{21}  &  b_{22} &  \cdots  &  b_{2n}\\ \vdots  &  \vdots& \ddots  & \vdots\\  b_{n1} &  b_{n2} &  \cdots & b_{nn}\end{bmatrix}</script><p>若记 $B = (b_{ij} )_{n\times n} $ ，那么就可以简写为：</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>则称 $n$ 阶矩阵 $B$ 为由基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 到基 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 的<strong>过渡矩阵</strong>。</p><p>过渡矩阵有以下性质：</p><ol><li>过渡矩阵 $B$ 的第 $j$ 列恰为 $\beta _{j} $ 在基 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 下的坐标；</li><li>过渡矩阵 $B$ 可逆。事实上，由 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 线性无关，则 $A$ 的列向量组线性无关，故 $B$ 为可逆矩阵。</li></ol><p><strong>定理 5.1</strong>：设 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 与 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 为 $n$ 维线性空间 $V$ 的两组基，由 $\displaystyle a_{1} ,a_{2} ,\dots, a_{n} $ 到基 $\beta _{1},\beta _{2},\dots ,\beta _{n} $ 的过渡矩阵为 $B = (b_{ij} )_{n\times n} $ ，即</p><script type="math/tex; mode=display">\left ( \beta _{1},\beta _{2},\dots ,\beta _{n}  \right )  = \left ( \displaystyle a_{1} ,a_{2} ,\dots, a_{n}  \right ) B</script><p>若向量 $\eta $ 在这两组基下的坐标分别为 $x = (x_{1},x_{2},\dots ,x_{n} )^{T} $ 和 $y = (y_{1},y_{2},\dots ,y_{n} )^{T} $ ，那么</p><script type="math/tex; mode=display">\mathbf{x}  = \mathbf{Ay} \text{或者} \mathbf{y}  =\mathbf{ A^{-1}x }</script><p>上式被称为<strong>坐标变换公式</strong>。</p><h2 id="5-3-线性变换"><a href="#5-3-线性变换" class="headerlink" title="5.3 线性变换"></a>5.3 线性变换</h2><h3 id="5-3-1-映射"><a href="#5-3-1-映射" class="headerlink" title="5.3.1 映射"></a>5.3.1 映射</h3><p><strong>定义 5.8</strong>：设 $M$ 与 $N$ 是两个非空集合，如果有一个法则 $f$ ，使得对 $M$ 中的每个元素 $a$ 都有 $N$ 中唯一确定的 $b$ 与之对应，那么就称 $f$ 是 $M$ 到 $N$ 的一个<strong>映射</strong>，记作</p><script type="math/tex; mode=display">f:\mathbf{M} \to \mathbf{N}</script><p>并称 $b$ 为 $a$ 在 $f$ 下的<strong>像</strong>，而 $a$ 称为 $b$ 在映射 $f$ 下的一个<strong>原像</strong>，记作</p><script type="math/tex; mode=display">f:a\to b\quad \textbf{或} f(a) = b</script><p>集合 $M$ 称为映射 $f$ 的<strong>定义域</strong>。如果对于任意的 $\displaystyle a,b\in M$ ，都有 $f(a)\ne f(b)\quad (a\ne b)$ ，则称 $f$ 是<strong>单射</strong>；如果对于任意的 $b\in N,a\in M$ ，都有 $f(a)=b$ ，则称 $f$ 是<strong>满射</strong>；如果 $f$ 既是单射又是满射，则称 $f$ 是<strong>双射</strong>（或称为<strong>一一映射</strong>）。</p><h3 id="5-3-2-线性变换的定义"><a href="#5-3-2-线性变换的定义" class="headerlink" title="5.3.2 线性变换的定义"></a>5.3.2 线性变换的定义</h3><p><strong>定义 5.9</strong>：设数域 $F$ 上的线性空间 $V_{1} $ 和 $V_{2} $ 分别是 $n$ 和 $m$ 维的。 $T$ 是 $V_{1} $ 到 $V_{2} $$ 的一个映射，且满足：</p><ol><li>对任意的 $\alpha ,\beta \in V_{1} $ ，有 $T(\alpha +\beta )=T(\alpha )+T(\beta )$ ；</li><li>对任意的 $\alpha \in V,k\in F$ ，有 $T( k\alpha)=kT(\alpha )$ ；</li></ol><p>则称 $T$ 是从线性空间 $V_{1} $ 到 $V_{2} $ 的<strong>线性映射</strong>。若 $V_{2} =F$ ，则称该线性映射为<strong>线性函数</strong>；若 $V_{1} =V_{2} $ ，则称该线性映射为线性空间$V_{1}$ 上的线性变换，简称<strong>线性变换</strong>。</p><h3 id="5-3-3-线性变换的性质"><a href="#5-3-3-线性变换的性质" class="headerlink" title="5.3.3 线性变换的性质"></a>5.3.3 线性变换的性质</h3><p><strong>性质 5.5</strong>： $T(0) = 0$ 。</p><p><strong>性质 5.6</strong>： $T(-\alpha ) = -T(\alpha )$ 。</p><p><strong>性质 5.7</strong>：若 $\beta  = k_{1}\alpha _{1}+k_{2}\alpha _{2}+\dots +k_{m}\alpha _{m}  $ ，则</p><script type="math/tex; mode=display">T(\beta ) = k_{1}T\left ( \alpha_{1} \right )+k_{2}T\left ( \alpha _{2} \right ) +\dots +k_{m}T\left ( \alpha _{m}   \right )</script><p><strong>性质 5.8</strong>：若向量组 $\alpha _{1},\alpha _{2},\dots ,\alpha _{m}  $ 线性相关，则向量组 $T\left ( \alpha _{1}\right ),T\left ( \alpha _{2} \right ) ,\dots,T\left ( \alpha _{m}   \right )$ 也线性相关。</p><h2 id="5-4-线性变换的矩阵表示"><a href="#5-4-线性变换的矩阵表示" class="headerlink" title="5.4 线性变换的矩阵表示"></a>5.4 线性变换的矩阵表示</h2><h3 id="5-4-1-线性变换的矩阵"><a href="#5-4-1-线性变换的矩阵" class="headerlink" title="5.4.1 线性变换的矩阵"></a>5.4.1 线性变换的矩阵</h3><p>设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 是 $n$ 维线性空间 $V$ 的一组基，$T$ 是 $V$ 上的线性变换，那么对 $V$ 中的向量</p><script type="math/tex; mode=display">{\color{Red}  \xi =x_{1} \alpha _{1}+x_{2} \alpha _{2}+\dots +x_{n} \alpha _{n}}</script><p>由线性变换的性质，有</p><script type="math/tex; mode=display">{\color{blue} T\left ( \xi \right )  =x_{1} T\left ( \alpha _{1} \right ) +x_{2} T\left ( \alpha _{2} \right ) +\dots +x_{n} T\left ( \alpha _{n} \right ) }</script><p>因此，对于线性变换 $T$ ，如果知道 $T$ 关于基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ ，则 $V$ 中任一向量  $\xi $  的像 $T\left ( \xi  \right ) $ 就完全确定。</p><p>由于 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 的像 $T\left ( \alpha _{1} \right ) , T\left ( \alpha _{2} \right ),\dots ,T\left ( \alpha _{n} \right )$ 可由 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 线性表示，即有：</p><script type="math/tex; mode=display">\left\{\begin{matrix} T(\alpha _{1} ) & = & {\color{Violet} a_{11}} \alpha _{1} & + &  {\color{Violet} a_{21}} \alpha _{2}  & + & \dots  & + &  {\color{Violet} a_{n1}} \alpha _{n} \\  T(\alpha _{2} ) & = &  {\color{Violet} a_{12}} \alpha _{1}  & + &  {\color{Violet} a_{22}} \alpha _{2}  & + & \dots & + &  {\color{Violet} a_{n2}} \alpha _{n} \\  &  &  & \vdots  &  &  &  &  & \\  T(\alpha _{n} ) & = &  {\color{Violet} a_{1n}} \alpha _{1}  & + &  {\color{Violet} a_{2n}} \alpha _{2}  & + & \dots & + & {\color{Violet} a_{nn}} \alpha _{n} \end{matrix}\right.</script><p>若记</p><script type="math/tex; mode=display">\begin{align}T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} ) & = T(\alpha _{1})+T(\alpha _{2})+\dots +T(\alpha _{n})\\ \displaystyle & = (\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\begin{bmatrix}{\color{Violet}  a_{11}}   & {\color{Violet}  a_{12}} & \dots  & {\color{Violet}  a_{1n}}\\ {\color{Violet}  a_{121}} & {\color{Violet}  a_{22}} & \cdots  & {\color{Violet}  a_{2n}}\\ \vdots  & \vdots  &  \ddots &\vdots  \\ {\color{Violet}  a_{n1}} & {\color{Violet}  a_{n2}} & \dots  &{\color{Violet}  a_{nn}}\end{bmatrix}\end{align}</script><p>或者</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p><strong>定义 5.10</strong>：设 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 为 $n$ 维线性空间 $V$ 的一组基， $T$ 为 $V$ 的一个线性变换。若 $n$ 阶矩阵 $A$ 满足</p><script type="math/tex; mode=display">T(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )  =(\alpha _{1},\alpha _{2},\dots ,\alpha _{n} )\mathbf{A}</script><p>则称 $n$ 阶矩阵 $A$ 为线性变换 $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的<strong>表示矩阵</strong>。</p><p><strong>定理 5.2</strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换， $T$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，向量 $\xi$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{x} =(x_{1},x_{2},\dots ,x_{n})^{T} $ ， $T(\xi )$ 在基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标为 $\mathbf{y} =(y_{1},y_{2},\dots ,y_{n})^{T} $ ，则</p><script type="math/tex; mode=display">\mathbf{y = Ax}</script><h3 id="5-4-2-线性变换在不同矩阵基下矩阵的关系"><a href="#5-4-2-线性变换在不同矩阵基下矩阵的关系" class="headerlink" title="5.4.2 线性变换在不同矩阵基下矩阵的关系"></a>5.4.2 线性变换在不同矩阵基下矩阵的关系</h3><p><strong>定理 5.3</strong>：设  $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 和 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 是 $n$ 维线性空间 $V$ 的两组基， $V$ 上的线性变换 $T$ 在这两种基下的矩阵分别为 $A$ 和 $B$ ，且从基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 到基 $\beta _{1} ,\beta _{2} ,\dots ,\beta _{n} $ 的过渡矩阵为  $P$ ，那么</p><script type="math/tex; mode=display">\mathbf{B = P^{-1} AP}</script><h2 id="5-5-线性变换的特征值与特征向量"><a href="#5-5-线性变换的特征值与特征向量" class="headerlink" title="5.5 线性变换的特征值与特征向量"></a>5.5 线性变换的特征值与特征向量</h2><h3 id="5-5-1-特征值与特征向量"><a href="#5-5-1-特征值与特征向量" class="headerlink" title="5.5.1 特征值与特征向量"></a>5.5.1 特征值与特征向量</h3><p><strong>定义 5.11</strong>：设 $T$ 是数域 $F$ 上线性空间 $V$ 的线性变换，若存在数 $\lambda \in \mathbf{F} $ 和非零向量 $\alpha \in V$ ，使得</p><script type="math/tex; mode=display">T(\alpha ) = \lambda \alpha</script><p>则称 $ \lambda$ 为 $T$ 的一个特征值，而 $\alpha $ 称为 $T$ 属于特征值 $\lambda $ 的特征向量。</p><p><strong>定理 5.4</strong>：设 $T$ 是 $n$ 维线性空间 $V$ 上的线性变换，$T$ 在 $V$ 的基  $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则：</p><ol><li>$\lambda $ 是 $T$ 的特征值得充要条件是$\lambda $ 为 $A$ 的特征值；</li><li>$\alpha \in V$ 是 $T$ 的属于特征值 $\lambda $ 的特征向量的充要条件是 $\alpha $ 在基  $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的坐标是矩阵 $A$ 的属于特征值 $\lambda $ 的特征向量。</li></ol><h3 id="5-5-2-值域与核"><a href="#5-5-2-值域与核" class="headerlink" title="5.5.2 值域与核"></a>5.5.2 值域与核</h3><p><strong>定义 5.12</strong>：设 $T$ 是线性空间 $V$ 中的线性变换，$V$ 中所有元素在 $T$ 下的像所组成的集合。</p><script type="math/tex; mode=display">\left \{ \beta |\beta  = T(\alpha ) ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>值域</strong>，记作 $\text{Im} T\quad \text{或者} T(V)$ 。零向量的所有原像的集合：</p><script type="math/tex; mode=display">\left \{ \alpha | T(\alpha )=0 ,\alpha \in V\right \}</script><p>称为 $T$ 的<strong>核</strong>，记作 $\text{Ker} T\quad \text{或者} T^{-1} (V)$ 。</p><p>关于线性变换的值域与核有以下性质：</p><ol><li>线性变换 $T$ 的值域 $\text{Im} T$ 是 $V$ 的子空间；</li><li>线性变换 $T$ 的核 $\text{Ker} T$ 是 $V$ 的子空间。</li></ol><p><strong>定理5.5</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵 $A$ ，则</p><ol><li>$\text{Im} T$ 的维数等于向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的<strong>秩</strong>，也等于矩阵 $A$ 的秩；</li><li>$\text{Im} T$ 的基是向量组 $T(\alpha_{1}  ),T(\alpha_{2}  ),\dots ,T(\alpha_{n}  )$ 的一个极大无关组。</li></ol><p><strong>定理 5.6</strong>：设 $V$ 是 $n$ 维线性空间， $V$ 上的线性变换 $T$ 在 $V$ 的基 $\alpha _{1},\alpha _{2},\dots ,\alpha _{n}$ 下的矩阵为 $A$ ，则</p><ul><li>$T$ 的核 $\text{Ker} T$ 的维数等于 $n-R(A)$ ；</li><li>$V$ 中齐次线性方程组 $Ax = 0$ 的基础解系构成 $T$ 的核 $\text{Ker} T$的基。</li></ul><h1 id="😁说明😁"><a href="#😁说明😁" class="headerlink" title="😁说明😁"></a>😁说明😁</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>线性代数及应用（第二版）</p><ul><li>编著：高淑萍、杨威、张剑湖、马建荣</li><li>出版社：西安电子科技大学出版社</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 大学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数基础知识 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客使用MathJax公式并解决Markdown渲染冲突问题</title>
      <link href="/2023/04/28/Hexo/Trouble/%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/28/Hexo/Trouble/%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="利用MathJax来渲染LaTeX数学公式"><a href="#利用MathJax来渲染LaTeX数学公式" class="headerlink" title="利用MathJax来渲染LaTeX数学公式"></a>利用MathJax来渲染LaTeX数学公式</h1><p><code>hexo</code>主题<code>Next</code>中已经集成了对<code>mathjax</code>的支持。在<strong>主题配置文件</strong>中，找到下面配置片段：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启MathJax渲染</span></span><br><span class="line">  <span class="comment"># 是否再每一页进行MathJax渲染。</span></span><br><span class="line">  <span class="comment"># false:将会对在YAML front matters中添加 mathjax:true 的MD文件进行渲染</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>然后可以安装一个Mathjax的渲染引擎。在当前项目路径下，打开终端，并输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo<span class="literal">-renderer-marked</span> <span class="literal">--save</span> //如果之前按安装其他的渲染插件，先删除</span><br><span class="line">npm install hexo<span class="literal">-renderer-kramed</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>这样就能渲染出数学公式。例如下面效果：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//行内公式（或者叫内联公式）</span><br><span class="line"><span class="built_in">$</span>a <span class="keyword">\parallel</span> c,b <span class="keyword">\parallel</span> c <span class="keyword">\Rightarrow</span> a <span class="keyword">\parallel</span> b <span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">//多行公式（或者加公式块）</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;l&#125;  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\cdot</span> <span class="keyword">\mathbf</span>&#123;E&#125; =<span class="keyword">\cfrac</span>&#123;<span class="keyword">\rho</span>&#125;&#123;<span class="keyword">\varepsilon</span> <span class="built_in">_</span>0&#125;  <span class="keyword">\\</span>  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\cdot</span> <span class="keyword">\mathbf</span>&#123;B&#125; = 0 <span class="keyword">\\</span>  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\times</span>  <span class="keyword">\mathbf</span>&#123;E&#125; = -<span class="keyword">\cfrac</span>&#123;<span class="keyword">\partial</span> <span class="keyword">\mathbf</span>&#123;B&#125;&#125;&#123;<span class="keyword">\partial</span> t &#125;  <span class="keyword">\\</span>  </span><br><span class="line">  <span class="keyword">\nabla</span> <span class="keyword">\times</span>  <span class="keyword">\mathbf</span>&#123;B&#125; = <span class="keyword">\mu</span> <span class="built_in">_</span>0<span class="keyword">\mathbf</span>&#123;J&#125; + <span class="keyword">\mu</span> <span class="built_in">_</span>0<span class="keyword">\varepsilon</span><span class="built_in">_</span>0 <span class="keyword">\cfrac</span>&#123;<span class="keyword">\partial</span> <span class="keyword">\mathbf</span>&#123;E&#125;&#125;&#123;<span class="keyword">\partial</span> t &#125;   </span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125; </span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><ul><li><p>内联公式：$a \parallel c,b \parallel c \Rightarrow a \parallel b $</p></li><li><p>公式块</p><script type="math/tex; mode=display">  \begin{array}{l}    \nabla \cdot \mathbf{E} =\cfrac{\rho}{\varepsilon _0}  \\    \nabla \cdot \mathbf{B} = 0 \\    \nabla \times  \mathbf{E} = -\cfrac{\partial \mathbf{B}}{\partial t }  \\    \nabla \times  \mathbf{B} = \mu _0\mathbf{J} + \mu _0\varepsilon_0 \cfrac{\partial \mathbf{E}}{\partial t }   \end{array}</script></li></ul><h1 id="内联公式的不正常显示"><a href="#内联公式的不正常显示" class="headerlink" title="内联公式的不正常显示"></a>内联公式的不正常显示</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>例如下面的<code>Latex</code>语法：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>E<span class="built_in">_</span>&#123;1&#125;  = E<span class="built_in">_</span>&#123;2&#125; <span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>正确的显示应该是： $E_{1}  = E_{2} $ ，而<code>hexo</code>确把它渲染为：$E<em>{1}  = E</em>{2}$ 。</p><p>我们不难发现，本应该显示公式，但是却出现源码，并且部分变为斜体。原因是<code>hexo</code>先用<code>marked.js</code>渲染，然后再交给<code>MathJax</code>渲染。在<code>marked.js</code>渲染的时候下划线<code>_</code>是被替换掉，并且换成了<code>&lt;em&gt;</code>标签，即斜体字，另外LaTeX中的<code>\\</code>也会被转义成一个<code>\</code>，这样会导致<code>MathJax</code>渲染时不认为它是一个换行符了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过修改<code>Hexo</code>渲染的源码来解决。</p><ol><li><p>首先进入<code>[Blog-name]\node_modules\kramed\lib\rules\inline.js</code>文件内，找到下面代码并且替换掉。这样就能解决<strong>换行</strong>冲突的问题。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到下面代码，并且注释掉</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//将下面代码添加到刚刚注释的地方</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p><code>[Blog-name]\node_modules\kramed\lib\rules\inline.js</code>文件内，找到下面代码并且替换掉。这样就能解决<strong>斜体</strong>冲突的问题。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到下面代码，并且注释掉</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line"><span class="comment">//将下面代码添加到刚刚注释的地方</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>保存文件，并且重启项目，刷新网页。</p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl; hexo s</span><br><span class="line">hexo cl</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这种方法意在解决<code>Hexo</code>的数学公式渲染问题，因此不需要对<code>Markdown</code>文件进行修改，就能正确显示数学公式</p></blockquote><h1 id="内联公式的样式调整"><a href="#内联公式的样式调整" class="headerlink" title="内联公式的样式调整"></a>内联公式的样式调整</h1><p>在使用<code>Mathjax</code>公式时，内联公式的位置并不是垂直居中显示，并且还会偶尔出现横向滚动条。因此，为了改善数学公式的观看体验，下面将对上述问题进行解决。</p><p>首先来到<code>[hexo-project]\source\css\custom.css</code>文件（这是自定义的文件，如果没有就先创建）内，添加下面内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数学内联公式水平居中显示 */</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-class">.mathjax-overflow</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数学内联公式取消横向滚动条 */</span></span><br><span class="line"><span class="selector-class">.mathjax-overflow</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再到主题配置文件<code>_config.butterfly.yml</code>内，找到下面位置，并添加对上述<code>CSS</code>文件的引用：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/personal.css&quot;</span> <span class="string">media=&quot;defer&quot;</span> <span class="string">onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br></pre></td></tr></table></figure><p>然后重启项目并且刷新网页：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo s</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h1 id="文章配置说明"><a href="#文章配置说明" class="headerlink" title="文章配置说明"></a>文章配置说明</h1><h2 id="参考目录："><a href="#参考目录：" class="headerlink" title="参考目录："></a>参考目录：</h2><ul><li>文章引用<ol><li><a href="https://segmentfault.com/a/1190000007261752">Hexo下mathjax的转义问题</a></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
            <tag> MathJax </tag>
            
            <tag> 公式渲染 </tag>
            
            <tag> 渲染冲突 </tag>
            
            <tag> latex </tag>
            
            <tag> 数学公式 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础知识</title>
      <link href="/2023/04/26/Programming/C%E7%9F%A5%E8%AF%86%E5%BA%93/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/26/Programming/C%E7%9F%A5%E8%AF%86%E5%BA%93/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-认识C语言"><a href="#第一章-认识C语言" class="headerlink" title="第一章 认识C语言"></a>第一章 认识C语言</h1><p>C 语言是一种通用的、面向过程式的计算机程序设计语言。</p><h2 id="1-1-C语言的历史"><a href="#1-1-C语言的历史" class="headerlink" title="1.1 C语言的历史"></a>1.1 C语言的历史</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p><p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p><p>UNIX 操作系统，C 编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p><ul><li>易于学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以处理底层的活动。</li><li>它可以在多种计算机平台上编译。</li></ul><h2 id="1-2-C语言的作用"><a href="#1-2-C语言的作用" class="headerlink" title="1.2 C语言的作用"></a>1.2 C语言的作用</h2><p> 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：</p><ul><li>操作系统</li><li>语言编译器</li><li>汇编器</li><li>文本编辑器</li><li>打印机</li><li>网络驱动器</li><li>现代程序</li><li>数据库</li><li>语言解释器</li><li>实体工具</li></ul><h2 id="1-3-环境设置"><a href="#1-3-环境设置" class="headerlink" title="1.3 环境设置"></a>1.3 环境设置</h2><p>如果您想要设置 C 语言环境，您需要确保电脑上有以下两款可用的软件：文本编辑器和 C 编译器。</p><h2 id="1-4-算法"><a href="#1-4-算法" class="headerlink" title="1.4 算法"></a>1.4 算法</h2><p>程序 = 数据结构 + 算法</p><h1 id="第二章-C语言基础"><a href="#第二章-C语言基础" class="headerlink" title="第二章 C语言基础"></a>第二章 C语言基础</h1><h2 id="2-1-C-语言程序结构"><a href="#2-1-C-语言程序结构" class="headerlink" title="2.1 C 语言程序结构"></a>2.1 C 语言程序结构</h2><p>一个完整的 C 语言代码文件，至少包含两部分：头文件和主函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello , world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头文件：里面定义了 C 语言常用的常量，以及一些函数</li><li>主函数：是 C 语言代码文件的入口，主程序所运行的源文件必须包含主函数</li></ul><p>例如，下面完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预处理命令，（1）导入头文件；（2）宏定义；</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;XXX.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> datetype int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义函数区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><p>在代码中添加的标注行文字，从而帮助程序员更好的阅读代码。注释的内容将被编译器忽略，并不会在执行结果种体现出来。</p><p>在 C 语言中，主要有两种注释方式：单行注释和多行注释。</p><ol><li><p>单行注释</p><p> ​    语法如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我是注释君</span></span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>多行注释</p><p> ​    语法如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我是注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> ​    在限定符之间的所有内容均是注释。</p></li></ol><h2 id="2-3-头文件和宏定义"><a href="#2-3-头文件和宏定义" class="headerlink" title="2.3 头文件和宏定义"></a>2.3 头文件和宏定义</h2><h3 id="2-3-1-头文件"><a href="#2-3-1-头文件" class="headerlink" title="2.3.1 头文件"></a>2.3.1 头文件</h3><p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p><p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong> 头文件，它是编译器自带的头文件。</p><p>引用头文件有两种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#including<span class="string">&lt;file&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file&quot;</span></span></span><br></pre></td></tr></table></figure><p>上述两种引用头文件的方式用法不同。</p><ul><li>使用 &lt;&gt; ：程序会从标准头文件目录中，搜索对应的头文件。因此，一般引用系统头文件，采用这种方式</li><li>使用引号：程序先从当前目录中，搜索对应的头文件。因此，自定义的头文件会采用这种方式。</li></ul><h3 id="2-3-2-宏定义"><a href="#2-3-2-宏定义" class="headerlink" title="2.3.2 宏定义"></a>2.3.2 宏定义</h3><p>宏定义又称为宏替换、宏代换，简称“宏”，是C提供的三种预处理功能的其中一种。其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率。</p><p>​    #define 命令是C语言中的一个宏定义命令，它用来讲一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。该命令有两种格式：一种是简单的宏定义（不带参数的宏定义），另一种是带参数的宏定义。</p><p>​    基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;宏名/标识符&gt;</span> <span class="string">&lt;字符串&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;宏名&gt;</span>(<span class="string">&lt;参数表&gt;</span>) <span class="string">&lt;字符串&gt;</span></span></span><br></pre></td></tr></table></figure><p>​    无参的宏定义：</p><ul><li>宏名一般用大写，宏定义末尾<strong>不加分号</strong></li><li>可以用 #undef 命令终止宏定义的作用域</li><li>宏定义可以嵌套，&lt;内容&gt;中永远不要包含宏</li><li>宏替换在编译前进行，不分配内存，变量定义分配内存，函数调用在编译后程序运行时进行，并且分配内存</li><li>预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查</li><li>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义</li></ul><p>​    有参的宏定义：</p><ul><li>实参如果是表达式容易出问题</li><li>宏名和参数的括号间不能有空格</li><li>宏替换之作替换不做计算，不做表达式求解</li><li>宏的哑实结合不存在类型，也没有类型转换</li><li>宏展开不占用运行时间，只占用编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）</li></ul><h2 id="2-4-关键字和标识符"><a href="#2-4-关键字和标识符" class="headerlink" title="2.4 关键字和标识符"></a>2.4 关键字和标识符</h2><h3 id="2-4-1-关键字"><a href="#2-4-1-关键字" class="headerlink" title="2.4.1 关键字"></a>2.4.1 关键字</h3><p>关键字是 C 语言中已经被赋予特定含义的一些单词，开发程序时，不可以把这些保留字作为变量、函数、类、模块和其他对象的名称来使用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:left">说明</th><th style="text-align:center">关键字</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">auto</td><td style="text-align:left">声明自动变量</td><td style="text-align:center">int</td><td style="text-align:left">声明整型变量或函数</td></tr><tr><td style="text-align:center">break</td><td style="text-align:left">跳出当前循环</td><td style="text-align:center">long</td><td style="text-align:left">声明长整型变量或函数返回值类型</td></tr><tr><td style="text-align:center">case</td><td style="text-align:left">开关语句分支</td><td style="text-align:center">register</td><td style="text-align:left">声明寄存器变量</td></tr><tr><td style="text-align:center">char</td><td style="text-align:left">声明字符型变量或函数返回值类型</td><td style="text-align:center">return</td><td style="text-align:left">子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td style="text-align:center">const</td><td style="text-align:left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td><td style="text-align:center">short</td><td style="text-align:left">声明短整型变量或函数</td></tr><tr><td style="text-align:center">continue</td><td style="text-align:left">结束当前循环，开始下一轮循环</td><td style="text-align:center">signed</td><td style="text-align:left">声明有符号类型变量或函数</td></tr><tr><td style="text-align:center">default</td><td style="text-align:left">开关语句中的”其它”分支</td><td style="text-align:center">sizeof</td><td style="text-align:left">计算数据类型或变量长度（即所占字节数）</td></tr><tr><td style="text-align:center">do</td><td style="text-align:left">循环语句的循环体</td><td style="text-align:center">static</td><td style="text-align:left">声明静态变量</td></tr><tr><td style="text-align:center">double</td><td style="text-align:left">声明双精度浮点型变量或函数返回值类型</td><td style="text-align:center">struct</td><td style="text-align:left">声明结构体类型</td></tr><tr><td style="text-align:center">else</td><td style="text-align:left">条件语句否定分支（与 if 连用）</td><td style="text-align:center">switch</td><td style="text-align:left">用于开关语句</td></tr><tr><td style="text-align:center">enum</td><td style="text-align:left">声明枚举类型</td><td style="text-align:center">typedef</td><td style="text-align:left">用以给数据类型取别名</td></tr><tr><td style="text-align:center">extern</td><td style="text-align:left">声明变量或函数是在其它文件或本文件的其他位置定义</td><td style="text-align:center">unsigned</td><td style="text-align:left">声明无符号类型变量或函数</td></tr><tr><td style="text-align:center">float</td><td style="text-align:left">声明浮点型变量或函数返回值类型</td><td style="text-align:center">union</td><td style="text-align:left">声明共用体类型</td></tr><tr><td style="text-align:center">for</td><td style="text-align:left">一种循环语句</td><td style="text-align:center">void</td><td style="text-align:left">声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td style="text-align:center">goto</td><td style="text-align:left">无条件跳转语句</td><td style="text-align:center">volatile</td><td style="text-align:left">说明变量在程序执行中可被隐含地改变</td></tr><tr><td style="text-align:center">if</td><td style="text-align:left">条件语句</td><td style="text-align:center">while</td><td style="text-align:left">循环语句的循环条件</td></tr></tbody></table></div><p>C99 新增关键字：</p><div class="table-container"><table><thead><tr><th>_Bool</th><th>_Complex</th><th>_Imaginary</th><th>inline</th><th>restrict</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>C11 新增关键字：</p><div class="table-container"><table><thead><tr><th>_Alignas</th><th>_Alignof</th><th>_Atomic</th><th>_Generic</th><th>_Noreturn</th></tr></thead><tbody><tr><td>_Static_assert</td><td>_Thread_local</td><td></td><td></td></tr></tbody></table></div><h3 id="2-4-2-标识符"><a href="#2-4-2-标识符" class="headerlink" title="2.4.2 标识符"></a>2.4.2 标识符</h3><p>标识符：标识符简单理解为一个名字</p><p>​    C 语言的标识符命名规则如下：</p><ul><li>由字母、下划线和数字组成，并且不能以数字开</li><li>不能使用关键字</li></ul><h2 id="2-5-基础数据类型"><a href="#2-5-基础数据类型" class="headerlink" title="2.5 基础数据类型"></a>2.5 基础数据类型</h2><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>C 中的类型可分为以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">基本数据类型</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">枚举类型</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">void 类型</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">派生类型</td></tr></tbody></table></div><h3 id="2-5-1-整型"><a href="#2-5-1-整型" class="headerlink" title="2.5.1 整型"></a>2.5.1 整型</h3><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储大小</th><th style="text-align:center">值范围</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1 字节</td><td style="text-align:center">-128 到 127 或 0 到 255</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">1 字节</td><td style="text-align:center">0 到 255</td></tr><tr><td style="text-align:center">signed char</td><td style="text-align:center">1 字节</td><td style="text-align:center">-128 到 127</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">2 或 4 字节</td><td style="text-align:center">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td style="text-align:center">unsigned int</td><td style="text-align:center">2 或 4 字节</td><td style="text-align:center">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2 字节</td><td style="text-align:center">-32,768 到 32,767</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">2 字节</td><td style="text-align:center">0 到 65,535</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4 字节</td><td style="text-align:center">-2,147,483,648 到 2,147,483,647</td></tr><tr><td style="text-align:center">unsigned long</td><td style="text-align:center">4 字节</td><td style="text-align:center">0 到 4,294,967,295</td></tr></tbody></table></div><blockquote><p>注意：各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</p></blockquote><p>为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 <strong>sizeof</strong> 运算符。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-2-浮点型"><a href="#2-5-2-浮点型" class="headerlink" title="2.5.2 浮点型"></a>2.5.2 浮点型</h3><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储大小</th><th style="text-align:center">值范围</th><th style="text-align:center">精度</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4 字节</td><td style="text-align:center">1.2E-38 到 3.4E+38</td><td style="text-align:center">6 位有效位</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8 字节</td><td style="text-align:center">2.3E-308 到 1.7E+308</td><td style="text-align:center">15 位有效位</td></tr><tr><td style="text-align:center">long double</td><td style="text-align:center">16 字节</td><td style="text-align:center">3.4E-4932 到 1.1E+4932</td><td style="text-align:center">19 位有效位</td></tr></tbody></table></div><h3 id="2-5-3类型转换"><a href="#2-5-3类型转换" class="headerlink" title="2.5.3类型转换"></a>2.5.3类型转换</h3><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。C 语言中有两种类型转换：</p><ul><li><p><strong>隐式类型转换：</strong>隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d = i + f; <span class="comment">// 隐式将int类型转换为double类型</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>显式类型转换：</strong>显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)d; <span class="comment">// 显式将double类型转换为int类型</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-6-运算符"><a href="#2-6-运算符" class="headerlink" title="2.6 运算符"></a>2.6 运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。</p><h3 id="2-6-1-算术运算符"><a href="#2-6-1-算术运算符" class="headerlink" title="2.6.1 算术运算符"></a>2.6.1 算术运算符</h3><p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">把两个操作数相加</td><td style="text-align:left">A + B 将得到 30</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">从第一个操作数中减去第二个操作数</td><td style="text-align:left">A - B 将得到 -10</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">把两个操作数相乘</td><td style="text-align:left">A * B 将得到 200</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">分子除以分母</td><td style="text-align:left">B / A 将得到 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取模运算符，整除后的余数</td><td style="text-align:left">B % A 将得到 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增运算符，整数值增加 1</td><td style="text-align:left">A++ 将得到 11</td></tr><tr><td style="text-align:left">—</td><td style="text-align:left">自减运算符，整数值减少 1</td><td style="text-align:left">A— 将得到 9</td></tr></tbody></table></div><h3 id="2-6-2-关系运算符"><a href="#2-6-2-关系运算符" class="headerlink" title="2.6.2 关系运算符"></a>2.6.2 关系运算符</h3><p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td style="text-align:left">(A == B) 为假。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td style="text-align:left">(A != B) 为真。</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &gt; B) 为假。</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &lt; B) 为真。</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &gt;= B) 为假。</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:left">(A &lt;= B) 为真。</td></tr></tbody></table></div><h3 id="2-6-3-逻辑运算符"><a href="#2-6-3-逻辑运算符" class="headerlink" title="2.6.3 逻辑运算符"></a>2.6.3 逻辑运算符</h3><p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td style="text-align:left">(A &amp;&amp; B) 为假。</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td style="text-align:left">(A&#124;B) 为真。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td style="text-align:left">!(A &amp;&amp; B) 为真。</td></tr></tbody></table></div><h3 id="2-6-4-位运算符"><a href="#2-6-4-位运算符" class="headerlink" title="2.6.4 位运算符"></a>2.6.4 位运算符</h3><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">p</th><th style="text-align:left">q</th><th style="text-align:left">p &amp; q</th><th style="text-align:left">p&#124;q</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">1</td><td style="text-align:left">1</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:left">按位与操作，按二进制位进行”与”运算。</td><td style="text-align:left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td style="text-align:center">$\vert$</td><td style="text-align:left">按位或运算符，按二进制位进行”或”运算。</td><td style="text-align:left">(A$\vert$B) 将得到 61，即为 0011 1101</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">异或运算符，按二进制位进行”异或”运算。</td><td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td style="text-align:center">~</td><td style="text-align:left">取反运算符，按二进制位进行”取反”运算。</td><td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:left">二进制左移运算符。</td><td style="text-align:left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:left">二进制右移运算符。</td><td style="text-align:left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table></div><h3 id="1-6-5-赋值运算符"><a href="#1-6-5-赋值运算符" class="headerlink" title="1.6.5 赋值运算符"></a>1.6.5 赋值运算符</h3><p>下表列出了 C 语言支持的赋值运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td style="text-align:left">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td style="text-align:left">C += A 相当于 C = C + A</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td style="text-align:left">C -= A 相当于 C = C - A</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td style="text-align:left">C <em>= A 相当于 C = C </em> A</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td style="text-align:left">C /= A 相当于 C = C / A</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td style="text-align:left">C %= A 相当于 C = C % A</td></tr><tr><td style="text-align:left">&lt;&lt;=</td><td style="text-align:left">左移且赋值运算符</td><td style="text-align:left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:left">&gt;&gt;=</td><td style="text-align:left">右移且赋值运算符</td><td style="text-align:left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:left">&amp;=</td><td style="text-align:left">按位与且赋值运算符</td><td style="text-align:left">C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td style="text-align:left">^=</td><td style="text-align:left">按位异或且赋值运算符</td><td style="text-align:left">C ^= 2 等同于 C = C ^ 2</td></tr><tr><td style="text-align:left">&#124;=</td><td style="text-align:left">按位或且赋值运算符</td><td style="text-align:left">C &#124;= 2 等同于 C = C $\vert$ 2</td></tr></tbody></table></div><h3 id="1-6-6-杂项运算符"><a href="#1-6-6-杂项运算符" class="headerlink" title="1.6.6 杂项运算符"></a>1.6.6 杂项运算符</h3><p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 <strong>? :</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">sizeof()</td><td style="text-align:left">返回变量的大小。</td><td style="text-align:left">sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:left">返回变量的地址。</td><td style="text-align:left">&a; 将给出变量的实际地址。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">指向一个变量。</td><td style="text-align:left">*a; 将指向一个变量。</td></tr><tr><td style="text-align:center">? :</td><td style="text-align:left">条件表达式</td><td style="text-align:left">如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table></div><h3 id="1-6-7-运算优先级"><a href="#1-6-7-运算优先级" class="headerlink" title="1.6.7 运算优先级"></a>1.6.7 运算优先级</h3><p>下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">运算符</th><th style="text-align:left">结合性</th></tr></thead><tbody><tr><td style="text-align:left">后缀</td><td style="text-align:left">() [] -&gt; . ++ - -</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">一元</td><td style="text-align:left">+ - ! ~ ++ - - (type)  * &amp;  sizeof</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">乘除</td><td style="text-align:left">* / %</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">加减</td><td style="text-align:left">+ -</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">&lt;&lt; &gt;&gt;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">&lt; &lt;= &gt; &gt;=</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">相等</td><td style="text-align:left">== !=</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位与 AND</td><td style="text-align:left">&amp;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位异或 XOR</td><td style="text-align:left">^</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">位或 OR</td><td style="text-align:left">&#124;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">逻辑与 AND</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">逻辑或 OR</td><td style="text-align:left">&#124;&#124;</td><td style="text-align:left">从左到右</td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">?:</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">赋值</td><td style="text-align:left">=  +=   -=   *=   /=   %=  &gt;&gt;=   &lt;&lt;=   &amp;=   ^=  &#124;=</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">逗号</td><td style="text-align:left">,</td><td style="text-align:left">从左到右</td></tr></tbody></table></div><h2 id="1-7-变量与常量"><a href="#1-7-变量与常量" class="headerlink" title="1.7 变量与常量"></a>1.7 变量与常量</h2><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p><p>变量的名称可以由字母、数字和下划线字符组成。</p><h3 id="1-7-1-变量定义"><a href="#1-7-1-变量定义" class="headerlink" title="1.7.1 变量定义"></a>1.7.1 变量定义</h3><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure><h3 id="1-7-2-变量声明"><a href="#1-7-2-变量声明" class="headerlink" title="1.7.2 变量声明"></a>1.7.2 变量声明</h3><p>变量的声明有两种情况：</p><ol><li>需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li><li>不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。</li><li>除非有extern关键字，否则都是变量的定义。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明，不是定义</span><br><span class="line">int i; //声明，也是定义</span><br></pre></td></tr></table></figure><h3 id="1-7-3-常量"><a href="#1-7-3-常量" class="headerlink" title="1.7.3 常量"></a>1.7.3 常量</h3><p>在 C 中，有两种简单的定义常量的方式：</p><ol><li>使用 <strong>#define</strong> 预处理器。</li><li>使用 <strong>const</strong> 关键字。</li></ol><p>下面是使用 #define 预处理器定义常量的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define identifier value</span><br></pre></td></tr></table></figure><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const type variable = value;</span><br></pre></td></tr></table></figure><h2 id="1-8-输入和输出"><a href="#1-8-输入和输出" class="headerlink" title="1.8 输入和输出"></a>1.8 输入和输出</h2><p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。</p><p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。</p><h3 id="1-8-1-scanf-和-printf-函数"><a href="#1-8-1-scanf-和-printf-函数" class="headerlink" title="1.8.1 scanf() 和 printf() 函数"></a>1.8.1 scanf() 和 printf() 函数</h3><p><code>int scanf(const char \*format, ...)</code>函数从标准输入流 <code>stdin</code> 读取输入，并根据提供的 <code>format</code> 来浏览输入。</p><p><code>int printf(const char \*format, ...)</code> 函数把输出写入到标准输出流 <code>stdout</code> ，并根据提供的格式产生输出。</p><p><code>format</code> 可以是一个简单的常量字符串，但是您可以分别指定 <code>%s、%d、%c、%f</code>等来输出或读取字符串、整数、字符或浮点数。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nYou entered: %s %d &quot;</span>, str, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-2-getchar-和-putchar-函数"><a href="#1-8-2-getchar-和-putchar-函数" class="headerlink" title="1.8.2 getchar() 和 putchar() 函数"></a>1.8.2 getchar() 和 putchar() 函数</h3><p><strong><code>int getchar(void)</code></strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p><p><strong><code>int putchar(int c)</code></strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p><h3 id="1-8-3-gets-和-puts-函数"><a href="#1-8-3-gets-和-puts-函数" class="headerlink" title="1.8.3 gets() 和 puts() 函数"></a>1.8.3 gets() 和 puts() 函数</h3><p><strong><code>char \*gets(char \*s)</code></strong> 函数从 <strong><code>stdin</code></strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p><p><strong><code>int puts(const char \*s)</code></strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong><code>stdout</code></strong>。</p><h1 id="第三章-流程控制语句"><a href="#第三章-流程控制语句" class="headerlink" title="第三章 流程控制语句"></a>第三章 流程控制语句</h1><h2 id="3-1-顺序结构"><a href="#3-1-顺序结构" class="headerlink" title="3.1 顺序结构"></a>3.1 顺序结构</h2><h2 id="3-2-选择结构"><a href="#3-2-选择结构" class="headerlink" title="3.2 选择结构"></a>3.2 选择结构</h2><p>选择结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。</p><h3 id="3-2-1-if-语句"><a href="#3-2-1-if-语句" class="headerlink" title="3.2.1 if 语句"></a>3.2.1 if 语句</h3><p>单个 if 的语句，当表达式1为真时，执行代码块1。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if…else 语句：当表达式1为真时，执行代码块1；反之，执行代码块2。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环之间可以相互嵌套</p></blockquote><h3 id="3-2-2-switch-语句"><a href="#3-2-2-switch-语句" class="headerlink" title="3.2.2 switch 语句"></a>3.2.2 switch 语句</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(value)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="number">&#x27;B</span><span class="number">&#x27;</span>:a = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入的值 value 为 A 时，“a = 0”代码，其余同理。</p><h3 id="3-2-3-三元运算符"><a href="#3-2-3-三元运算符" class="headerlink" title="3.2.3 三元运算符"></a>3.2.3 三元运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&gt;b? max = a: max = b;<span class="comment">//如果a&gt;b为真，则执行max = a;反之，则执行max = b;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-循环结构"><a href="#3-3-循环结构" class="headerlink" title="3.3 循环结构"></a>3.3 循环结构</h2><h3 id="3-3-1-while-循环"><a href="#3-3-1-while-循环" class="headerlink" title="3.3.1 while 循环"></a>3.3.1 while 循环</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)</span><br><span class="line">&#123;</span><br><span class="line">    xxx;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-do-while-循环"><a href="#3-3-2-do-while-循环" class="headerlink" title="3.3.2 do-while 循环"></a>3.3.2 do-while 循环</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (循环条件);</span><br></pre></td></tr></table></figure><p>与 while 的区别是，该循环是：先执行，后判断；而 while 是：先判断，后执行。</p><h3 id="3-3-3-for-循环"><a href="#3-3-3-for-循环" class="headerlink" title="3.3.3 for 循环"></a>3.3.3 for 循环</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-循环控制语句"><a href="#3-3-4-循环控制语句" class="headerlink" title="3.3.4 循环控制语句"></a>3.3.4 循环控制语句</h3><div class="table-container"><table><thead><tr><th style="text-align:left">控制语句</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.runoob.com/cprogramming/c-break-statement.html">break 语句</a></td><td style="text-align:left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cprogramming/c-continue-statement.html">continue 语句</a></td><td style="text-align:left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td></tr><tr><td style="text-align:left"><a href="https://www.runoob.com/cprogramming/c-goto-statement.html">goto 语句</a></td><td style="text-align:left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr></tbody></table></div><h1 id="第四章-复杂数据类型"><a href="#第四章-复杂数据类型" class="headerlink" title="第四章 复杂数据类型"></a>第四章 复杂数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p><p>数组中的元素的地址是连续的。</p><h3 id="4-1-1-声明数组"><a href="#4-1-1-声明数组" class="headerlink" title="4.1.1 声明数组"></a>4.1.1 声明数组</h3><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型名 变量名[常量表达式]</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>定义数组时，需指明数组长度</li><li>中括号 [ ] 里为常量，不能为变量</li></ul><h3 id="4-1-2-初始化数组"><a href="#4-1-2-初始化数组" class="headerlink" title="4.1.2 初始化数组"></a>4.1.2 初始化数组</h3><p>在声明时进行初始化。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全部赋值</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以部分赋值，未赋值的默认为0</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>还可以对数组中的单个元素进行赋值。例如;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">num[<span class="number">6</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-访问数组元素"><a href="#4-1-3-访问数组元素" class="headerlink" title="4.1.3 访问数组元素"></a>4.1.3 访问数组元素</h3><p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名[下标]</span></span><br><span class="line"><span class="comment">//下标的范围0-max</span></span><br><span class="line">num[<span class="number">0</span>];</span><br><span class="line">num[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="4-1-4-二维数组"><a href="#4-1-4-二维数组" class="headerlink" title="4.1.4 二维数组"></a>4.1.4 二维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型名 变量名[常量表达式][常量表达式]</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//数组名[下标][下标]</span></span><br><span class="line"><span class="comment">//下标的范围0-max</span></span><br><span class="line">num[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">num[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    &#123;<span class="number">12</span>,<span class="number">32</span>,<span class="number">23</span>,<span class="number">321</span>&#125;</span><br><span class="line">    &#123;<span class="number">23</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">32</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">321</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">32</span>,<span class="number">12</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-字符数组-字符串"><a href="#4-2-字符数组-字符串" class="headerlink" title="4.2 字符数组-字符串"></a>4.2 字符数组-字符串</h2><p>在 C 语言中，<strong>字符串</strong>实际上是使用空字符 <strong>\0</strong> 结尾的一维字符数组。因此，<strong>\0</strong> 是用于标记字符串的结束。</p><p><img src="https://raw.githubusercontent.com/YuiLexi/Imageshack/main/E-books/Programming/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BA%93/C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E6%A8%A1%E5%9E%8B.png" alt="C/C++ 中的字符串表示"></p><h3 id="4-2-1-字符数组的声明和初始化"><a href="#4-2-1-字符数组的声明和初始化" class="headerlink" title="4.2.1 字符数组的声明和初始化"></a>4.2.1 字符数组的声明和初始化</h3><p>语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;!&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-字符数组的输出"><a href="#4-2-2-字符数组的输出" class="headerlink" title="4.2.2 字符数组的输出"></a>4.2.2 字符数组的输出</h3><p>使用 printf() 函数，对字符数组进行输出。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[] = &#123;<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,c);</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>输出的字符中不包含结束符’\0’</li><li>如果数组长度大于字符串的实际长度，也只输出遇到’\0’</li><li>如果一个字符数组中包含一个以上的’\0’，则遇到第一个时输出就结束</li><li>可以用<strong>scanf_s</strong>输入一个字符串</li></ul><h3 id="4-2-2-操作字符数组"><a href="#4-2-2-操作字符数组" class="headerlink" title="4.2.2 操作字符数组"></a>4.2.2 操作字符数组</h3><p>C 中有大量操作字符串的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数 &amp; 目的</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table></div><h2 id="4-3-结构体"><a href="#4-3-结构体" class="headerlink" title="4.3 结构体"></a>4.3 结构体</h2><p><strong>结构</strong>是 C 编程中一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p><h3 id="4-3-1-结构体的定义"><a href="#4-3-1-结构体的定义" class="headerlink" title="4.3.1 结构体的定义"></a>4.3.1 结构体的定义</h3><p>结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Struct 结构体名</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">结构体成员列表;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-结构体变量初始化"><a href="#4-3-2-结构体变量初始化" class="headerlink" title="4.3.2 结构体变量初始化"></a>4.3.2 结构体变量初始化</h3><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。例如，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语言&quot;</span>, <span class="string">&quot;RUNOOB&quot;</span>, <span class="string">&quot;编程语言&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-访问结构体成员"><a href="#4-3-3-访问结构体成员" class="headerlink" title="4.3.3 访问结构体成员"></a>4.3.3 访问结构体成员</h3><p>为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> str[];</span><br><span class="line">&#125;Tom = &#123;<span class="number">9</span>,<span class="number">10.56</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line"><span class="keyword">struct</span> Student *pt;</span><br><span class="line">pt = &amp;Tom</span><br><span class="line"><span class="comment">//方法一：结构体变量名.结构体成员</span></span><br><span class="line">Tom.str;</span><br><span class="line"><span class="comment">//方法二：（*结构体指针变量).结构体成员</span></span><br><span class="line">(*pt).str;</span><br><span class="line"><span class="comment">//方法三：结构体指针变量-&gt;结构体成员</span></span><br><span class="line">pt-&gt;str</span><br></pre></td></tr></table></figure><h3 id="4-3-4-结构作为函数参数"><a href="#4-3-4-结构作为函数参数" class="headerlink" title="4.3.4 结构作为函数参数"></a>4.3.4 结构作为函数参数</h3><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：</p><h2 id="4-4-共用体"><a href="#4-4-共用体" class="headerlink" title="4.4 共用体"></a>4.4 共用体</h2><p><strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。</p><h3 id="4-4-1-定义共用体"><a href="#4-4-1-定义共用体" class="headerlink" title="4.4.1 定义共用体"></a>4.4.1 定义共用体</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure><h3 id="4-4-2-访问共用体成员"><a href="#4-4-2-访问共用体成员" class="headerlink" title="4.4.2 访问共用体成员"></a>4.4.2 访问共用体成员</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.element</span><br></pre></td></tr></table></figure><h3 id="4-4-3-共用体类型的特点"><a href="#4-4-3-共用体类型的特点" class="headerlink" title="4.4.3 共用体类型的特点"></a>4.4.3 共用体类型的特点</h3><ol><li>同一段内存能存放不不同类型成员，但是在每一瞬间只能存放某一种类型成员</li><li>可以进行初始化，但是初始化表中只能有一个常量</li><li>共用体变量起作用的成员是最后一次被赋值的成员，每一次赋值后，原有变量存储单元中的值就被取代</li><li>共用体变量的地址和它各成员的地址都是同一地址</li><li>不能对共用体变量名赋值也不能引用变量名来获取一个值</li><li>C99允许共用体变量作为函数参数</li></ol><h2 id="4-5-枚举"><a href="#4-5-枚举" class="headerlink" title="4.5 枚举"></a>4.5 枚举</h2><h1 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h1><p>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。</p><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p><h2 id="5-1-函数的使用"><a href="#5-1-函数的使用" class="headerlink" title="5.1 函数的使用"></a>5.1 函数的使用</h2><h3 id="5-1-1-定义函数"><a href="#5-1-1-定义函数" class="headerlink" title="5.1.1 定义函数"></a>5.1.1 定义函数</h3><p>C 语言中的函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类型名 函数名(参数)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">函数体</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><h3 id="5-1-2-函数声明"><a href="#5-1-2-函数声明" class="headerlink" title="5.1.2 函数声明"></a>5.1.2 函数声明</h3><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>函数声明包括以下几个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span>;</span><br></pre></td></tr></table></figure><p>针对上面定义的函数 max()，以下是函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br></pre></td></tr></table></figure><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p><h3 id="5-1-3-调用函数"><a href="#5-1-3-调用函数" class="headerlink" title="5.1.3 调用函数"></a>5.1.3 调用函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数列表);</span><br></pre></td></tr></table></figure><h2 id="5-2-参数传递"><a href="#5-2-参数传递" class="headerlink" title="5.2 参数传递"></a>5.2 参数传递</h2><ul><li>形式参数：定义函数时括号里面的参数</li><li>实际参数：调用函数时括号里面的参数</li></ul><h3 id="5-2-1-传值调用"><a href="#5-2-1-传值调用" class="headerlink" title="5.2.1 传值调用"></a>5.2.1 传值调用</h3><p>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</p><p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p><h3 id="5-2-2-引用调用"><a href="#5-2-2-引用调用" class="headerlink" title="5.2.2 引用调用"></a>5.2.2 引用调用</h3><p>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p><h2 id="5-3-函数的递归"><a href="#5-3-函数的递归" class="headerlink" title="5.3 函数的递归"></a>5.3 函数的递归</h2><p>在调用函数的过程中又出现<strong>直接或间接调用该函数本身</strong>，称为<font color='red'>函数的递归</font>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">name</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y,z;</span><br><span class="line">    z = name(y);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，打印任意乘法表。具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> <span class="title function_">chengfabiao</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要打印的乘法表的阶数：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">chengfabiao(number);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chengfabiao</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">chengfabiao(n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d X %d = %d ,  &quot;</span>, n, i, n * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第六章-指针"><a href="#第六章-指针" class="headerlink" title="第六章 指针"></a>第六章 指针</h1><p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 <strong>&amp;</strong> 运算符访问的地址，它表示了在内存中的一个地址。</p><p><strong>指针也就是内存地址，指针变量是用来存放内存地址的变量</strong>。</p><h2 id="6-1-指针变量"><a href="#6-1-指针变量" class="headerlink" title="6.1 指针变量"></a>6.1 指针变量</h2><h3 id="6-1-1-指针变量的定义"><a href="#6-1-1-指针变量的定义" class="headerlink" title="6.1.1 指针变量的定义"></a>6.1.1 指针变量的定义</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var_name;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-指针的使用"><a href="#6-1-2-指针的使用" class="headerlink" title="6.1.2 指针的使用"></a>6.1.2 指针的使用</h3><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 <strong>*</strong> 来返回位于操作数所指定地址的变量的值。例如，下面代码;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//定义整型变量 a</span></span><br><span class="line"><span class="type">int</span>* ap;<span class="comment">//定义整型指针变量 ap</span></span><br><span class="line">ap = &amp;a;<span class="comment">//让指针 ap 指向 a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的地址是：%d\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的地址是：%d\n&quot;</span>, ap);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的值是：%d\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a的值是：%d\n&quot;</span>, *ap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-NULL-指针"><a href="#6-2-NULL-指针" class="headerlink" title="6.2 NULL 指针"></a>6.2 NULL 指针</h2><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><h2 id="6-3-指针详解"><a href="#6-3-指针详解" class="headerlink" title="6.3 指针详解"></a>6.3 指针详解</h2><h3 id="6-3-1-指针的算数运算"><a href="#6-3-1-指针的算数运算" class="headerlink" title="6.3.1 指针的算数运算"></a>6.3.1 指针的算数运算</h3><p> 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、—、+、- 。</p><p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr++;</span><br></pre></td></tr></table></figure><p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p><p>我们概括一下：</p><ul><li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li><li>指针的每一次递减，它都会指向前一个元素的存储单元。</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</li></ul><h3 id="6-3-2-指针数组"><a href="#6-3-2-指针数组" class="headerlink" title="6.3.2 指针数组"></a>6.3.2 指针数组</h3><h3 id="6-3-3-多重指针"><a href="#6-3-3-多重指针" class="headerlink" title="6.3.3 多重指针"></a>6.3.3 多重指针</h3><h2 id="6-4-通过指针引用数组"><a href="#6-4-通过指针引用数组" class="headerlink" title="6.4 通过指针引用数组"></a>6.4 通过指针引用数组</h2><h3 id="6-4-1-数组元素的指针"><a href="#6-4-1-数组元素的指针" class="headerlink" title="6.4.1 数组元素的指针"></a>6.4.1 数组元素的指针</h3><p><strong>所谓数组元素的指针就是数组元素的地址</strong>。</p><p>引用数组元素可以用下标法，也可用指针法。使用指针法能使目标程序质量高（占内存少，运算快）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><p>注意：数组名不代表整个数组，只代表数组首元素的我地址。</p><h3 id="6-4-2-在引用数组元素时的指针运算"><a href="#6-4-2-在引用数组元素时的指针运算" class="headerlink" title="6.4.2 在引用数组元素时的指针运算"></a>6.4.2 在引用数组元素时的指针运算</h3><p>在指针以指向一个数组元素时，可以对指针进行一下运算：</p><ul><li>p + 1;</li><li>p - 1;</li><li>p++,++p;</li><li>p—,—p;</li></ul><h3 id="6-4-3-指针引用数组元素"><a href="#6-4-3-指针引用数组元素" class="headerlink" title="6.4.3 指针引用数组元素"></a>6.4.3 指针引用数组元素</h3><ol><li><p>下标法</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">b = a[<span class="number">4</span>];<span class="comment">//b == 5</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>指针法</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">p = &amp;a[<span class="number">0</span>];<span class="comment">//或者 p=a; 将数组a的初地址赋给p指针</span></span><br><span class="line">b = *(p+<span class="number">4</span>);<span class="comment">//b==5</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="第七章-动态内存和链表"><a href="#第七章-动态内存和链表" class="headerlink" title="第七章 动态内存和链表"></a>第七章 动态内存和链表</h1><h2 id="7-1-建立动态内存的方式"><a href="#7-1-建立动态内存的方式" class="headerlink" title="7.1 建立动态内存的方式"></a>7.1 建立动态内存的方式</h2><h3 id="7-1-1-开辟动态存储区-malloc-函数"><a href="#7-1-1-开辟动态存储区-malloc-函数" class="headerlink" title="7.1.1 开辟动态存储区 malloc() 函数"></a>7.1.1 开辟动态存储区 malloc() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>在内存的动态存储区中分配一个长度为 size 的连续空间。</li><li>函数返回值为内存第一个字节的地址</li><li>未能成功执行（例如：内存空间不足），则返回NULL</li></ul><h3 id="7-1-2-开辟动态存储区-calloc-函数"><a href="#7-1-2-开辟动态存储区-calloc-函数" class="headerlink" title="7.1.2 开辟动态存储区 calloc() 函数"></a>7.1.2 开辟动态存储区 calloc() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>在内存的动态存储区中分配 n个长度为size的连续空间。</li><li>函数返回值为内存第一个字节的地址</li><li>未能成功执行（例如：内存空间不足），则返回NULL</li></ul><h3 id="7-1-3-重新分配动态存储区-realloc-函数"><a href="#7-1-3-重新分配动态存储区-realloc-函数" class="headerlink" title="7.1.3 重新分配动态存储区 realloc() 函数"></a>7.1.3 重新分配动态存储区 realloc() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *p,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>能够重新分配 malloc 或 calloc 函数开辟的动态空间</li><li>realloch 函数将 p 所指向的动态空间的大小改变为 size 。</li><li>p 的值不变</li><li>未能成功执行，则返回NULL</li></ul><h3 id="7-1-4-释放动态存储区-free-函数"><a href="#7-1-4-释放动态存储区-free-函数" class="headerlink" title="7.1.4 释放动态存储区 free() 函数"></a>7.1.4 释放动态存储区 free() 函数</h3><p>基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">free</span>（<span class="type">void</span> *p;</span><br></pre></td></tr></table></figure><h2 id="7-2-链表"><a href="#7-2-链表" class="headerlink" title="7.2 链表"></a>7.2 链表</h2><h3 id="7-2-1-静态链表"><a href="#7-2-1-静态链表" class="headerlink" title="7.2.1 静态链表"></a>7.2.1 静态链表</h3><p>建立简单的静态链表。具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 6</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">&#125;component;</span><br><span class="line"><span class="comment">//将结构体数组中所有分量链接到备用链表中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserveArr</span><span class="params">(component *<span class="built_in">array</span>)</span>;</span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initArr</span><span class="params">(component *<span class="built_in">array</span>)</span>;</span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="type">int</span> body)</span>;</span><br><span class="line"><span class="comment">//从备用链表上摘下空闲节点的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallocArr</span><span class="params">(component * <span class="built_in">array</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    component <span class="built_in">array</span>[maxSize];</span><br><span class="line">    <span class="type">int</span> body = initArr(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;静态链表为：\n&quot;</span>);</span><br><span class="line">    displayArr(<span class="built_in">array</span>, body);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建备用链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserveArr</span><span class="params">(component *<span class="built_in">array</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i].cur = i + <span class="number">1</span>;<span class="comment">//将每个数组分量链接到一起</span></span><br><span class="line">        <span class="built_in">array</span>[i].data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[maxSize - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">//链表最后一个结点的游标值为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提取分配空间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallocArr</span><span class="params">(component * <span class="built_in">array</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//若备用链表非空，则返回分配的结点下标，否则返回 0（当分配最后一个结点时，该结点的游标值为 0）</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">array</span>[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>].cur) &#123;</span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>].cur = <span class="built_in">array</span>[i].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化静态链表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">initArr</span><span class="params">(component *<span class="built_in">array</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tempBody = <span class="number">0</span>, body = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    reserveArr(<span class="built_in">array</span>);</span><br><span class="line">    body = mallocArr(<span class="built_in">array</span>);</span><br><span class="line">    <span class="comment">//建立首元结点</span></span><br><span class="line">    <span class="built_in">array</span>[body].data = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">array</span>[body].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//声明一个变量，把它当指针使，指向链表的最后的一个结点，当前和首元结点重合</span></span><br><span class="line">    tempBody = body;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = mallocArr(<span class="built_in">array</span>); <span class="comment">//从备用链表中拿出空闲的分量</span></span><br><span class="line">        <span class="built_in">array</span>[j].data = i;      <span class="comment">//初始化新得到的空间结点</span></span><br><span class="line">        <span class="built_in">array</span>[tempBody].cur = j; <span class="comment">//将新得到的结点链接到数据链表的尾部</span></span><br><span class="line">        tempBody = j;             <span class="comment">//将指向链表最后一个结点的指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[tempBody].cur = <span class="number">0</span>;<span class="comment">//新的链表最后一个结点的指针设置为0</span></span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">displayArr</span><span class="params">(component * <span class="built_in">array</span>, <span class="type">int</span> body)</span> &#123;</span><br><span class="line">    <span class="type">int</span> tempBody = body;<span class="comment">//tempBody准备做遍历使用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">array</span>[tempBody].cur) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">array</span>[tempBody].data, <span class="built_in">array</span>[tempBody].cur);</span><br><span class="line">        tempBody = <span class="built_in">array</span>[tempBody].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, <span class="built_in">array</span>[tempBody].data, <span class="built_in">array</span>[tempBody].cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-动态链表"><a href="#7-2-2-动态链表" class="headerlink" title="7.2.2 动态链表"></a>7.2.2 动态链表</h3><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span>* <span class="title">Bp</span>;</span></span><br><span class="line">&#125;Books;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Books* <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Books * fbp)</span>;</span><br><span class="line">Books* p;</span><br><span class="line">p = init(<span class="number">10</span>);</span><br><span class="line">print(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 生成对应结点数链表</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;链表的结点数&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;返回表头指针&lt;/returns&gt;</span></span><br><span class="line">Books* <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">Books* fBp = <span class="literal">NULL</span>;</span><br><span class="line">Books* tmp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">fBp = (Books*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Books));</span><br><span class="line"></span><br><span class="line">tmp = fBp;</span><br><span class="line"><span class="keyword">for</span> (a = <span class="number">0</span>; a &lt; n; a++)</span><br><span class="line">&#123;</span><br><span class="line">(*tmp).id = a;</span><br><span class="line">(*tmp).Bp = (Books*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Books));</span><br><span class="line">tmp = (*tmp).Bp;</span><br><span class="line">(*tmp).Bp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fBp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 将链表的内容输出出来（正序和倒序）</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;fbp&quot;&gt;指向表头的指针&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Books* fbp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*fbp).Bp == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*fbp).id);</span><br><span class="line">print((*fbp).Bp);</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;, (*fbp).id);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八章-对文件的输入输出"><a href="#第八章-对文件的输入输出" class="headerlink" title="第八章 对文件的输入输出"></a>第八章 对文件的输入输出</h1><h2 id="8-1-C文件的有关知识"><a href="#8-1-C文件的有关知识" class="headerlink" title="8.1 C文件的有关知识"></a>8.1 C文件的有关知识</h2><h3 id="8-1-1-什么是文件"><a href="#8-1-1-什么是文件" class="headerlink" title="8.1.1 什么是文件"></a>8.1.1 什么是文件</h3><p>程序文件</p><p>数据文件</p><h3 id="8-1-2-文件类型指针"><a href="#8-1-2-文件类型指针" class="headerlink" title="8.1.2 文件类型指针"></a>8.1.2 文件类型指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE f1;</span><br><span class="line">FILE * f1;</span><br></pre></td></tr></table></figure><h2 id="8-2-打开与关闭文件"><a href="#8-2-打开与关闭文件" class="headerlink" title="8.2 打开与关闭文件"></a>8.2 打开与关闭文件</h2><div class="table-container"><table><thead><tr><th style="text-align:center">mode</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">以只读方式打开文件，该文件必须存在</td></tr><tr><td style="text-align:center">r+</td><td style="text-align:center">以可读写方式打开文件，该文件必须存在</td></tr><tr><td style="text-align:center">rb+</td><td style="text-align:center">读写打开一个二进制文件，允许读数据</td></tr><tr><td style="text-align:center">rw+</td><td style="text-align:center">读写打开一个文本文件，允许读和写</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件</td></tr><tr><td style="text-align:center">w+</td><td style="text-align:center">打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF符保留）</td></tr><tr><td style="text-align:center">a+</td><td style="text-align:center">以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的EOF符不保留）</td></tr><tr><td style="text-align:center">wb</td><td style="text-align:center">只写打开或新建一个二进制文件；只允许写数据</td></tr><tr><td style="text-align:center">wb+</td><td style="text-align:center">读写打开或建立一个二进制文件，允许读和写</td></tr><tr><td style="text-align:center">ab+</td><td style="text-align:center">读写打开一个二进制文件，允许读或在文件末追加数据</td></tr></tbody></table></div><h3 id="8-2-1-用fopen函数打开数据文件"><a href="#8-2-1-用fopen函数打开数据文件" class="headerlink" title="8.2.1 用fopen函数打开数据文件"></a>8.2.1 用fopen函数打开数据文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;文件名&quot;</span>,<span class="string">&quot;操作文件方式&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="8-2-2-用fclose函数关闭数据文件"><a href="#8-2-2-用fclose函数关闭数据文件" class="headerlink" title="8.2.2 用fclose函数关闭数据文件"></a>8.2.2 用fclose函数关闭数据文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(文件指针);</span><br></pre></td></tr></table></figure><h2 id="8-3-顺序读写数据文件"><a href="#8-3-顺序读写数据文件" class="headerlink" title="8.3 顺序读写数据文件"></a>8.3 顺序读写数据文件</h2><h3 id="8-3-1-向文件读写字符"><a href="#8-3-1-向文件读写字符" class="headerlink" title="8.3.1 向文件读写字符"></a>8.3.1 向文件读写字符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">调用形式</th><th style="text-align:center">功能</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">getc()</td><td style="text-align:center">getc(fp)</td><td style="text-align:center">从fp所指向的输入文件中读取一个字符</td><td style="text-align:center">返回值是读取的字符，如果发生错误则返回<strong>EOF = -1</strong></td></tr><tr><td style="text-align:center">fputc()</td><td style="text-align:center">fputc(ch,fp)</td><td style="text-align:center">字符ch 写入到 fp 所指向的输出流中</td><td style="text-align:center">如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF = -1</strong></td></tr></tbody></table></div><h3 id="8-3-2-向文件读写字符串"><a href="#8-3-2-向文件读写字符串" class="headerlink" title="8.3.2 向文件读写字符串"></a>8.3.2 向文件读写字符串</h3><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">调用形式</th><th style="text-align:center">功能</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">gets()</td><td style="text-align:center">gets(str,n,fp)</td><td style="text-align:center">从 fp 所指向的输入流中读取 n - 1 个字符</td><td style="text-align:center">返回值是地址str，如果发生错误则返回<strong>NULL</strong></td></tr><tr><td style="text-align:center">fputs()</td><td style="text-align:center">fputs(str,fp)</td><td style="text-align:center">字符串 <strong>s</strong> 写入到 fp 所指向的输出流中</td><td style="text-align:center">如果写入成功，它会返回0，如果发生错误，则会返回 <strong>非0值</strong></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> C语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> C语言基础 </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础语法</title>
      <link href="/2023/04/26/Programming/Csharp%E7%9F%A5%E8%AF%86%E5%BA%93/Csharp%E5%9F%BA%E7%A1%80/Csharp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/26/Programming/Csharp%E7%9F%A5%E8%AF%86%E5%BA%93/Csharp%E5%9F%BA%E7%A1%80/Csharp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>此文章是C#基础语法部分，涵盖了注释、变量类型、基础数据类型、运算符、流程控制语句、复杂数据类型、方法、面向对象程序设计等内容。</p><p>C#系列教程：</p><ol><li><a href="https://blog.yuilexi.cn/2023/04/26/Programming/Csharp知识库/Csharp基础/Csharp基础语法/">C#基础语法 | 🪐 星空鸟 🪐 (yuilexi.cn)</a>⬅️当前的位置°꒰๑’ꀾ’๑꒱°</li><li><a href="https://blog.yuilexi.cn/2023/04/30/Programming/Csharp知识库/Csharp基础/Csharp高级语法/">C#高级语法 | 🪐星空鸟🪐 (yuilexi.cn)</a></li></ol></blockquote><h1 id="一、认识-C"><a href="#一、认识-C" class="headerlink" title="一、认识 C"></a>一、认识 C</h1><h2 id="1-1-什么是-NET？"><a href="#1-1-什么是-NET？" class="headerlink" title="1.1 什么是 .NET？"></a>1.1 什么是 .NET？</h2><p>.NET 是由 Microsoft 创建的开源开发人员平台，用于生成许多不同类型的应用程序。使用 .NET，可以使用多种语言、编辑器和库来构建 Web、移动、桌面、游戏和 IoT 等。<a href="https://learn.microsoft.com/zh-cn/dotnet/">.NET 文档 | Microsoft Learn</a>。</p><ul><li><p>编程语言</p><p> 可以使用 C#、F# 或 Visual Basic 编写 .NET 应用。<a href="https://dotnet.microsoft.com/zh-cn/languages">了解.NET 编程语言</a>。</p><ul><li>C# 是一种简单、现代、面向对象和类型安全的编程语言。</li><li><p>F# 是一种编程语言，利用它可轻松编写简洁、可靠且性能出色的代码。</p></li><li><p>Visual Basic 是一种易于使用的语言，简单语法便于生成类型安全、面向对象的应用。</p></li></ul></li><li><p>跨平台</p><p> 无论是使用 C#、F# 还是 Visual Basic，代码都会在任何兼容的操作系统上本机运行。可以使用 .NET 生成多种类型的应用。有些是跨平台的，有些则针对特定的一组操作系统和设备。</p></li><li><p>一致的 API</p><p> .NET 提供一组标准的基类库和 API，这些库和 API 对所有 .NET 应用程序都是通用的。每个应用模型还可以公开特定于其运行的操作系统或它提供的功能的其他 API。例如，ASP.NET 是跨平台 Web 框架，它提供用于生成在 Linux 或 Windows 上运行的 Web 应用的其他 API。</p></li><li><p>库</p><p> 为了扩展功能，Microsoft 和其他公司维护着一个正常的 .NET 软件包生态系统。<a href="https://nuget.org/">NuGet</a>是专为包含了 100,000 多个包的 .NET 构建的包管理器。</p></li><li><p>应用程序模型</p><p> 可以使用 .NET 生成多种类型的应用。为了帮助你更快地生成应用，应用模型基于基础库构建。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Web</th><th>为 Windows、Linux、macOS、Docker 构建 Web 应用和服务。</th></tr></thead><tbody><tr><td style="text-align:center">手机</td><td>使用单一代码库生成适用于 iOS、Android 和 Windows 等的本机移动应用。</td></tr><tr><td style="text-align:center">桌面</td><td>创建适用于 Windows 和 macOS 的本机应用，或使用 Web 技术生成随时随地运行的应用。</td></tr><tr><td style="text-align:center">微服务</td><td>创建可在 Docker 容器上运行的可独立部署的微服务。</td></tr><tr><td style="text-align:center">云</td><td>使用现有云服务，或创建和部署自己的云服务。</td></tr><tr><td style="text-align:center">机器学习</td><td>为应用添加视觉算法、语音处理、预测模型等。</td></tr><tr><td style="text-align:center">游戏开发</td><td>为最热门的台式机、手机和控制台开发 2D 和 3D 游戏。</td></tr><tr><td style="text-align:center">物联网</td><td>使用 Raspberry Pi 和其他单板计算机的本机支持创建 IoT 应用。</td></tr></tbody></table></div><h2 id="1-2-什么是-C-？"><a href="#1-2-什么是-C-？" class="headerlink" title="1.2 什么是 C#？"></a>1.2 什么是 C#？</h2><p>一种编程语言，可以开发基于.NET 平台的应用。</p><h2 id="1-3-NET-两种交互模式"><a href="#1-3-NET-两种交互模式" class="headerlink" title="1.3 .NET 两种交互模式"></a>1.3 .NET 两种交互模式</h2><ul><li>C/S：客户端（Client）/服务器（Server） 模式（需安装客户端软件）</li><li>B/S：浏览器（Browser）/服务器 模式（只需要浏览器）</li></ul><h2 id="1-4-开发工具"><a href="#1-4-开发工具" class="headerlink" title="1.4 开发工具"></a>1.4 开发工具</h2><ul><li><a href="https://visualstudio.microsoft.com/">Visual Studio</a></li></ul><h1 id="二、C-语法基础"><a href="#二、C-语法基础" class="headerlink" title="二、C#语法基础"></a>二、C#语法基础</h1><h2 id="2-1-C-程序一般结构"><a href="#2-1-C-程序一般结构" class="headerlink" title="2.1 C#程序一般结构"></a>2.1 C#程序一般结构</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System; <span class="comment">//调用命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//项目开始的地方</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="comment">//构造命名空间，作用：区别相同名称但是作用不同的类</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">YourNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构造类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">YourClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//字段</span></span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        <span class="comment">//方法或函数</span></span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> YourStruct</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义接口</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IYourInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义委托类型</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">YourDelegate</span>()</span>;</span><br><span class="line">    <span class="comment">//枚举类型变量</span></span><br><span class="line">    <span class="built_in">enum</span> YourEnum</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子命名空间</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">YourNestedNamespace</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> YourStruct</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>代码中出现的所有标点都是英文半角；</li><li>在 C# 代码中，每行代码的结束，都以<strong>分号</strong>结束。</li></ol><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><ol><li><p>单行注释</p><p> 一般放在<strong>代码语句</strong>的后面，或者放在<strong>代码块</strong>的前面。基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a;<span class="comment">//定义变量a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义变量 b，c</span></span><br><span class="line"><span class="built_in">int</span> b;</span><br><span class="line"><span class="built_in">int</span> c;</span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><p> 基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Console.WriteLine();</span></span><br><span class="line"><span class="comment">Console.ReadKey();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>文本注释</p><p> 多用来解释类或方法的功能及参数。基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>text</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-基本数据类型"><a href="#2-3-基本数据类型" class="headerlink" title="2.3 基本数据类型"></a>2.3 基本数据类型</h2><p>在 C# 中，变量分为以下几种类型：</p><ul><li>值类型</li><li>引用类型</li><li>指针类型</li></ul><h3 id="2-3-1-值类型"><a href="#2-3-1-值类型" class="headerlink" title="2.3.1 值类型"></a>2.3.1 值类型</h3><p> 它们是从类 <code>System.ValueType</code> 中派生的。值类型变量可以直接分配给一个值，即当前变量所在地址里的数据就是当前变量的值。值类型直接包含数据。</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th>描述</th><th>范围</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">sbyte</td><td>8 位有符号整数类型</td><td>-128 到 127</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">short</td><td>16 位有符号整数类型</td><td>-32,768 到 32,767</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>int</strong></td><td>32 位有符号整数类型</td><td>-2,147,483,648 到 2,147,483,647</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td>64 位有符号整数类型</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td style="text-align:center">0L</td></tr><tr><td style="text-align:center">byte</td><td>8 位无符号整数</td><td>0 到 255</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ushort</td><td>16 位无符号整数类型</td><td>0 到 65,535</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">uint</td><td>32 位无符号整数类型</td><td>0 到 4,294,967,295</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ulong</td><td>64 位无符号整数类型</td><td>0 到 18,446,744,073,709,551,615</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">float</td><td>32 位单精度浮点型</td><td>-3.4 x 1038 到 + 3.4 x 1038</td><td style="text-align:center">0.0F</td></tr><tr><td style="text-align:center">double</td><td>64 位双精度浮点型</td><td>(+/-)5.0 x 10-324 到 (+/-)1.7 x 10308</td><td style="text-align:center">0.0D</td></tr><tr><td style="text-align:center">decimal</td><td>128 位精确的十进制值，28-29 有效位数</td><td>(-7.9 x 1028 到 7.9 x 1028) / 100 到 28</td><td style="text-align:center">0.0M</td></tr><tr><td style="text-align:center">char</td><td>16 位 Unicode 字符</td><td>U +0000 到 U +ffff</td><td style="text-align:center">‘\0’</td></tr><tr><td style="text-align:center">bool</td><td>布尔值</td><td>true 或 false</td><td style="text-align:center">False</td></tr></tbody></table></div><blockquote><p>字符不可为空，字符只能存一个字符。</p></blockquote><p>如需得到一个类型或一个变量在特定平台上的准确字节大小，可以使用 <code>sizeof()</code> 方法。下面举例获取任何机器上 <code>int</code> 类型的字节大小：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataTypeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="keyword">sizeof</span>(<span class="built_in">int</span>));<span class="comment">//</span></span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值类型还包括<a href="#4-3-枚举">枚举</a>和结构体。</p><h3 id="2-3-1-引用类型"><a href="#2-3-1-引用类型" class="headerlink" title="2.3.1 引用类型"></a>2.3.1 引用类型</h3><p>引用类型变量不包含存储在变量中的实际数据，但它们包含对变量的引用（地址）。换句话说，<strong>它们实际存储的是一个地址（栈区）</strong>，并指向变量的实际值所在的内存空间（堆区）。内置的引用类型有：<code>object</code>、<code>dynamic</code>和<code>string</code>。</p><ul><li><p>对象（Object）类型</p><p> <strong>对象</strong>：是所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><ul><li>当一个值类型转换为对象类型时，则被称为<strong>装箱</strong>；</li><li>当一个对象类型转换为值类型时，则被称为<strong>拆箱</strong>。</li></ul></li><li><p>动态（Dynamic）类型</p><p> 任何类型的值可以存储在动态数据类型变量中。这些变量的类型检查是在运行时发生的。声明动态类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dynamic &lt;variable_name&gt; = value;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> d = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字符串（String）类型</p><p> <strong>字符串（String）类型</strong>：允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。</p></li></ul><h3 id="2-3-3-指针类型"><a href="#2-3-3-指针类型" class="headerlink" title="2.3.3 指针类型"></a>2.3.3 指针类型</h3><p>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。声明指针类型的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type* name;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="built_in">char</span>* cp;</span><br><span class="line"><span class="built_in">int</span>* ip;</span><br></pre></td></tr></table></figure><blockquote><p>指针具体的使用，请参照<a href="">不安全代码</a></p></blockquote><h3 id="2-3-4-数据类型的转换"><a href="#2-3-4-数据类型的转换" class="headerlink" title="2.3.4 数据类型的转换"></a>2.3.4 数据类型的转换</h3><p>数据类型的转换有两种：<strong>隐式类型转换</strong>和<strong>显式类型转换</strong>。前者是自动进行，而后者是强制进行。</p><ul><li><p>隐式类型转换</p><p> 需要满足的条件是：两种兼容类型；目标类型等级高于源类型。例如：int 和 double 兼容（都是数字类型），而 double &gt; int 。</p></li><li><p>显式类型转换</p><ul><li><p>兼容类型</p><p> 高阶转换成低阶，可能会造成数据丢失。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> num = <span class="number">521.1314</span>;</span><br><span class="line"><span class="built_in">int</span> num_1;</span><br><span class="line">num_1 = (<span class="built_in">int</span>)num;<span class="comment">//此时 num_1 的值为 521</span></span><br></pre></td></tr></table></figure><blockquote><p> 注意：浮点型向整型转换时，会直接<strong>舍弃</strong>小数部分</p></blockquote></li><li><p>不兼容类型/Convert 类型转换</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">double</span> num;</span><br><span class="line">num = Convert.ToDouble(str);</span><br></pre></td></tr></table></figure><blockquote><p>转换的内容必须合理，比如 <code>14A</code> 中的 <code>A</code>不能转换成数字。</p></blockquote></li></ul></li><li><p><code>Convert</code>类型转换对应的所有方法如下：</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">ToBoolean</td><td style="text-align:left">如果可能的话，把类型转换为布尔型。</td></tr><tr><td style="text-align:center">ToByte</td><td style="text-align:left">如果可能的话，把类型转换为字节类型。</td></tr><tr><td style="text-align:center">ToChar</td><td style="text-align:left">如果可能的话，把类型转换为单个 Unicode 字符类型。</td></tr><tr><td style="text-align:center">ToDateTime</td><td style="text-align:left">如果可能的话，把类型（整数或字符串类型）转换为 日期-时间 结构。</td></tr><tr><td style="text-align:center">ToDecimal</td><td style="text-align:left">如果可能的话，把浮点型或整数类型转换为十进制类型。</td></tr><tr><td style="text-align:center">ToDouble</td><td style="text-align:left">如果可能的话，把类型转换为双精度浮点型。</td></tr><tr><td style="text-align:center">ToInt16</td><td style="text-align:left">如果可能的话，把类型转换为 16 位整数类型。</td></tr><tr><td style="text-align:center">ToInt32</td><td style="text-align:left">如果可能的话，把类型转换为 32 位整数类型。</td></tr><tr><td style="text-align:center">ToInt64</td><td style="text-align:left">如果可能的话，把类型转换为 64 位整数类型。</td></tr><tr><td style="text-align:center">ToSbyte</td><td style="text-align:left">如果可能的话，把类型转换为有符号字节类型。</td></tr><tr><td style="text-align:center">ToSingle</td><td style="text-align:left">如果可能的话，把类型转换为小浮点数类型。</td></tr><tr><td style="text-align:center">ToString</td><td style="text-align:left">如果可能的话，把类型转换为字符串类型。</td></tr><tr><td style="text-align:center">ToType</td><td style="text-align:left">如果可能的话，把类型转换为指定类型。</td></tr><tr><td style="text-align:center">ToUInt16</td><td style="text-align:left">如果可能的话，把类型转换为 16 位无符号整数类型。</td></tr><tr><td style="text-align:center">ToUInt32</td><td style="text-align:left">如果可能的话，把类型转换为 32 位无符号整数类型。</td></tr><tr><td style="text-align:center">ToUInt64</td><td style="text-align:left">如果可能的话，把类型转换为 64 位无符号整数类型。</td></tr></tbody></table></div><h2 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。分类如下：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="2-4-1-算数运算符"><a href="#2-4-1-算数运算符" class="headerlink" title="2.4.1 算数运算符"></a>2.4.1 算数运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">加</th><th style="text-align:center">减</th><th style="text-align:center">乘</th><th style="text-align:center">除</th><th style="text-align:center">取余</th><th style="text-align:center">自增</th><th style="text-align:center">自减</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">-</td><td style="text-align:center">*</td><td style="text-align:center">/</td><td style="text-align:center">%</td><td style="text-align:center">++</td><td style="text-align:center">—</td></tr></tbody></table></div><p>自增和自减有两种，前置和后置。分别对应如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i;</span><br><span class="line">i++;</span><br><span class="line">++i;</span><br></pre></td></tr></table></figure><p>二者的区别是：</p><ul><li><code>++i</code>：表示取<code>i</code>的地址，增加它的内容，然后把值放在寄存器中（<strong>先加后用</strong>）</li><li><code>i++</code>：表示取<code>i</code>的地址，把它的值装入寄存器，然后增加内存中的 a 的值（<strong>先用后加</strong>）</li></ul><p><strong>而前置自增 (<code>++i</code>) 通常要比后置自增 (<code>i++</code>) 效率更高</strong>。理由如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置++</span></span><br><span class="line">Age&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++i</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line"><span class="keyword">const</span> Age <span class="keyword">operator</span>++(<span class="built_in">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Age tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);  <span class="comment">//利用前置++</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>前置直接对源数据进行加 1 操作；而后置需要先创建一个临时变量，源数据保存一个副本后，再加 1</li><li>时间上来看：后置的语句更多，占用的时间更多</li><li>空间上来看：后置需要创建临时变量（用完释放），因此占用的内存更多</li></ul><h3 id="2-4-2-关系运算符"><a href="#2-4-2-关系运算符" class="headerlink" title="2.4.2 关系运算符"></a>2.4.2 关系运算符</h3><p>下表显示了 C# 支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td style="text-align:center">(A == B) 不为真。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td style="text-align:center">(A != B) 为真。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &gt; B) 不为真。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &lt; B) 为真。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &gt;= B) 不为真。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td style="text-align:center">(A &lt;= B) 为真。</td></tr></tbody></table></div><h3 id="2-4-3-逻辑运算符"><a href="#2-4-3-逻辑运算符" class="headerlink" title="2.4.3 逻辑运算符"></a>2.4.3 逻辑运算符</h3><p>下表显示了 C# 支持的所有逻辑运算符。假设变量 A 为布尔值 true，变量 B 为布尔值 false，则：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td style="text-align:center">(A &amp;&amp; B) 为假。</td></tr><tr><td style="text-align:center">&#124;&#124;</td><td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td style="text-align:center">(A&#124;&#124; B) 为真。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td style="text-align:center">!(A &amp;&amp; B) 为真。</td></tr></tbody></table></div><h3 id="2-4-4-位运算符"><a href="#2-4-4-位运算符" class="headerlink" title="2.4.4 位运算符"></a>2.4.4 位运算符</h3><p>位逻辑运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">p</th><th style="text-align:center">q</th><th style="text-align:center">p &amp; q</th><th style="text-align:center">p&#124; q</th><th style="text-align:center">p ^ q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>以及位操作符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td style="text-align:left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td style="text-align:left">(A &#124;B) 将得到 61，即为 0011 1101</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td style="text-align:center">~</td><td style="text-align:left">二进制补码运算符是一元运算符，具有”翻转”位效果。</td><td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td style="text-align:left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td style="text-align:left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table></div><h3 id="2-4-5-赋值运算符"><a href="#2-4-5-赋值运算符" class="headerlink" title="2.4.5 赋值运算符"></a>2.4.5 赋值运算符</h3><p>下表列出了 C# 支持的赋值运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td style="text-align:center">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td style="text-align:center">+=</td><td style="text-align:left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td style="text-align:center">C += A 相当于 C = C + A</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td style="text-align:center">C -= A 相当于 C = C - A</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td style="text-align:center">C _= A 相当于 C = C _ A</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td style="text-align:center">C /= A 相当于 C = C / A</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td style="text-align:center">C %= A 相当于 C = C % A</td></tr><tr><td style="text-align:center">&lt;&lt;=</td><td style="text-align:left">左移且赋值运算符</td><td style="text-align:center">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td style="text-align:center">&gt;&gt;=</td><td style="text-align:left">右移且赋值运算符</td><td style="text-align:center">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td style="text-align:center">&amp;=</td><td style="text-align:left">按位与且赋值运算符</td><td style="text-align:center">C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td style="text-align:center">^=</td><td style="text-align:left">按位异或且赋值运算符</td><td style="text-align:center">C ^= 2 等同于 C = C ^ 2</td></tr><tr><td style="text-align:center">&#124;=</td><td style="text-align:left">按位或且赋值运算符</td><td style="text-align:center">C&#124;= 2 等同于 C = C \</td><td>2</td></tr></tbody></table></div><h3 id="2-4-6-其他运算符"><a href="#2-4-6-其他运算符" class="headerlink" title="2.4.6 其他运算符"></a>2.4.6 其他运算符</h3><p>下表列出了 C# 支持的其他一些重要的运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:center">sizeof()</td><td style="text-align:left">返回数据类型的大小。</td><td style="text-align:left">sizeof(int)，将返回 4.</td></tr><tr><td style="text-align:center">typeof()</td><td style="text-align:left">返回变量的类型。</td><td style="text-align:left">typeof(StreamReader);</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:left">返回变量的地址。</td><td style="text-align:left">&a; 将得到变量的实际地址。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">变量的指针。</td><td style="text-align:left">*a; 将指向一个变量。</td></tr><tr><td style="text-align:center">? :</td><td style="text-align:left">条件表达式</td><td style="text-align:left">如果条件为真 ? 则为 X : 否则为 Y</td></tr><tr><td style="text-align:center">is</td><td style="text-align:left">判断当前对象是否为 XXX 类型</td><td style="text-align:left">返回 ture 或 false</td></tr><tr><td style="text-align:center">as</td><td style="text-align:left">强制转换，即使转换失败也不会抛出异常。</td><td style="text-align:left">转换成功，返回转换后的对象；反之，返回 NULL</td></tr></tbody></table></div><h3 id="2-4-7-lambda-运算符"><a href="#2-4-7-lambda-运算符" class="headerlink" title="2.4.7 lambda 运算符"></a>2.4.7 lambda 运算符</h3><p>在 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-expressions">lambda 表达式</a>中，lambda 运算符 <code>=&gt;</code> 将左侧的输入参数与右侧的 lambda 主体分开。</p><p>使用 Lambda 表达式来创建匿名函数。 使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/lambda-operator">lambda 声明运算符<code>=&gt;</code></a> 从其主体中分离 lambda 参数列表。 Lambda 表达式可采用以下任意一种形式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(input-parameters) =&gt; expression;</span><br><span class="line">(input-parameters) =&gt; &#123; &lt;sequence-of-statements&gt; &#125;;</span><br></pre></td></tr></table></figure><p>若要创建 Lambda 表达式，需要在 Lambda 运算符左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; greet = (name) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> greeting = <span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br><span class="line">    Console.WriteLine(greeting);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure><h2 id="2-5-特殊字符"><a href="#2-5-特殊字符" class="headerlink" title="2.5 特殊字符"></a>2.5 特殊字符</h2><h3 id="2-5-1-转义字符"><a href="#2-5-1-转义字符" class="headerlink" title="2.5.1 转义字符"></a>2.5.1 转义字符</h3><p><code>\\</code> + <code>特殊字符</code> = <code>具有特殊意义的字符</code>。例如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">转义符</th><th style="text-align:center">字符名</th></tr></thead><tbody><tr><td style="text-align:center">\\’</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center">\\”</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:center">\\\</td><td style="text-align:center">反斜杠</td></tr><tr><td style="text-align:center">\\0</td><td style="text-align:center">空字符</td></tr><tr><td style="text-align:center">\\a</td><td style="text-align:center">感叹号</td></tr><tr><td style="text-align:center">\\b</td><td style="text-align:center">退格</td></tr><tr><td style="text-align:center">\\f</td><td style="text-align:center">换页</td></tr><tr><td style="text-align:center">\\n</td><td style="text-align:center">新行</td></tr><tr><td style="text-align:center">\\r</td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center">\\t</td><td style="text-align:center">水平 tab</td></tr><tr><td style="text-align:center">\\v</td><td style="text-align:center">垂直 tab</td></tr></tbody></table></div><h3 id="2-5-2-符"><a href="#2-5-2-符" class="headerlink" title="2.5.2 @ 符"></a>2.5.2 @ 符</h3><ol><li>取消字符串中转义字符的转义作用。用在字符串前时，字符串里面的转义字符不转义。将字符串按照原格式输出。</li></ol><h3 id="2-5-3-符"><a href="#2-5-3-符" class="headerlink" title="2.5.3 + 符"></a>2.5.3 + 符</h3><ul><li><p>当<code>+</code>两边至少有一边为字符串时，作用为拼接字符串的作用</p><p> 具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;AAAAA&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;XXXXX@xx.com&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> address = <span class="string">&quot;SSSSS&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> salary = <span class="number">10000</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁了，邮箱是：&quot;</span> + email + <span class="string">&quot;,住在&quot;</span> + address + <span class="string">&quot;,每月的收入是&quot;</span> + salary + <span class="string">&quot;日元&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>数字相加</p><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> num_2 = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> num_3 = num_1 + num_2;</span><br><span class="line">Console.WriteLine(num_3);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-4-占位符"><a href="#2-5-4-占位符" class="headerlink" title="2.5.4 占位符"></a>2.5.4 占位符</h3><p>用在字符串内，增强代码的可读性。具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> c = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;第一个数字是：&quot;</span> + a + <span class="string">&quot;，第二个数字是：&quot;</span> + b + <span class="string">&quot;，第三个数字是：&quot;</span> + c);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;第一个数字是：&#123;0&#125;，第二个数字是：&#123;1&#125;，第三个数字是：&#123;2&#125;&quot;</span>,a,b,c);</span><br></pre></td></tr></table></figure><p>使用注意：</p><ul><li>挖几个坑，就要填几个坑。如果多填，不报错但没效果；如果少填，就会异常（语法没错误，只不过在程序运行期间，由于某些原因出现问题，使程序不在正常的运行）</li><li>输出顺序{0}，{1}，{2}… 对应 a, b, c, ….</li></ul><p>还可以使用 <code>$</code> 修饰字符串，然后使用占位符。例如下面的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> c = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;第一个数字是：<span class="subst">&#123;a&#125;</span>，第二个数字是：<span class="subst">&#123;b&#125;</span>，第三个数字是：<span class="subst">&#123;c&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-6-可空类型-💖💖💖"><a href="#2-6-可空类型-💖💖💖" class="headerlink" title="2.6 可空类型 💖💖💖"></a>2.6 可空类型 💖💖💖</h2><p>在 C# 中，值类型例如 int 的默认值是 0 ，同时也不能进 <code>a = null</code> 的赋值操作。一般情况下所有 <code>if( a != null)</code> 永远为真。</p><p>C# 提供了一个特殊的数据类型，<code>nullable</code> 类型（<strong>可空类型</strong>），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p><p><code>?</code> 单问号用于对 <code>int、double、bool</code>等无法直接赋值为 <code>null</code> 的数据类型进行 <code>null</code> 的赋值</p><h3 id="2-6-1-定义可空类型"><a href="#2-6-1-定义可空类型" class="headerlink" title="2.6.1 定义可空类型"></a>2.6.1 定义可空类型</h3><p>语法如下：声明一个 <code>nullable</code> 类型（可空类型）的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data_type&gt;? &lt;variable_name&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? i = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-null-合并运算符（-）"><a href="#2-6-2-null-合并运算符（-）" class="headerlink" title="2.6.2 null 合并运算符（ ?? ）"></a>2.6.2 null 合并运算符（ ?? ）</h3><p><code>null</code>合并运算符用于定义<strong>可空类型</strong>和<strong>引用类型</strong>的默认值。<strong>null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 null</strong>。下面的实例演示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NullablesAtShow</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//定义可空类型</span></span><br><span class="line">          <span class="built_in">double</span>? num1 = <span class="literal">null</span>;</span><br><span class="line">          <span class="built_in">double</span>? num2 = <span class="number">3.14157</span>;</span><br><span class="line">          <span class="built_in">double</span> num3;</span><br><span class="line">          <span class="comment">//如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值</span></span><br><span class="line">          num3 = num1 ?? <span class="number">5.34</span>;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);</span><br><span class="line">          num3 = num2 ?? <span class="number">5.34</span>;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);</span><br><span class="line">          Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果左操作数的值不为 <code>null</code>，则 null 合并运算符 <code>??</code> 返回该值；否则，它会计算右操作数并返回其结果。 如果左操作数的计算结果为非 null，则 <code>??</code> 运算符不会计算其右操作数。 </p><p>仅当左操作数的计算结果为 <code>null</code> 时，Null 合并赋值运算符 <code>??=</code> 才会将其右操作数的值赋值给其左操作数。 如果左操作数的计算结果为非 null，则 <code>??=</code> 运算符不会计算其右操作数。</p><h1 id="三、流程控制语句"><a href="#三、流程控制语句" class="headerlink" title="三、流程控制语句"></a>三、流程控制语句</h1><h2 id="3-1-选择结构"><a href="#3-1-选择结构" class="headerlink" title="3.1 选择结构"></a>3.1 选择结构</h2><h3 id="3-1-1-单-if-语句"><a href="#3-1-1-单-if-语句" class="headerlink" title="3.1.1 单 if 语句"></a>3.1.1 单 if 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(逻辑表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 如果逻辑表达式为真将执行的语句 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-if-else-语句"><a href="#3-1-2-if-else-语句" class="headerlink" title="3.1.2 if/else 语句"></a>3.1.2 if/else 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 如果布尔表达式为真将执行的语句 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 如果布尔表达式为假将执行的语句 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-switch-语句"><a href="#3-1-3-switch-语句" class="headerlink" title="3.1.3 switch 语句"></a>3.1.3 switch 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression:</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression:</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="literal">default</span> : <span class="comment">/* 默认执行（除了上面情况之外） */</span></span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>语句必须遵循下面的规则：</p><ul><li><code>case</code> 的<code>constant-expression</code>必须与<code>switch</code>中的变量具有相同的数据类型，且必须是一个常量。</li><li>当遇到<code>break</code>语句时，<code>switch</code>终止，控制流将跳转到 <code>switch</code> 语句后的下一行。</li><li>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 <code>case</code> 语句中有处理语句，则必须包含<code>break</code>或其他跳转语句。</li></ul><h3 id="3-1-4-三目运算符"><a href="#3-1-4-三目运算符" class="headerlink" title="3.1.4 三目运算符"></a>3.1.4 三目运算符</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑表达式 ? Exp2 : Exp3</span><br></pre></td></tr></table></figure><p>请注意，冒号的使用和位置。 <code>?</code> 表达式的值是由<strong>逻辑表达式</strong>决定的。</p><ul><li>如果逻辑表达式为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值</li><li>如果逻辑表达式为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值</li></ul><h2 id="3-2-循环结构"><a href="#3-2-循环结构" class="headerlink" title="3.2 循环结构"></a>3.2 循环结构</h2><h3 id="3-2-1-while-语句"><a href="#3-2-1-while-语句" class="headerlink" title="3.2.1 while 语句"></a>3.2.1 while 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(逻辑表达式/循环条件)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行判断，满足判断条件后再循环。</p><h3 id="3-2-2-do-while-语句"><a href="#3-2-2-do-while-语句" class="headerlink" title="3.2.2 do-while 语句"></a>3.2.2 do-while 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(逻辑表达式/循环条件);</span><br></pre></td></tr></table></figure><p>先进行循环，然后判断是否继续循环。</p><h3 id="3-2-3-for-语句"><a href="#3-2-3-for-语句" class="headerlink" title="3.2.3 for 语句"></a>3.2.3 for 语句</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式1一般为声明循环变量</span></span><br><span class="line"><span class="comment">//循环条件</span></span><br><span class="line"><span class="comment">//改变循环条件</span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-循环控制语句"><a href="#3-2-4-循环控制语句" class="headerlink" title="3.2.4 循环控制语句"></a>3.2.4 循环控制语句</h3><ol><li><code>break</code>：跳出当前循环，如果有循环的嵌套，那么只会跳出<strong>一层</strong>循环</li><li><code>continue</code>：立即结束<strong>本次</strong>循环，然后判断循环条件，如果成立，则进入下一次循环，否则退出循环</li></ol><h1 id="四、复杂数据类型"><a href="#四、复杂数据类型" class="headerlink" title="四、复杂数据类型"></a>四、复杂数据类型</h1><h2 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h2><p>字符串是引用类型。在 C# 中，您可以使用<strong>字符数组</strong>来表示字符串。但是，更常见的做法是使用 <code>string</code> 关键字来声明一个字符串变量。</p><h3 id="4-1-1-创建-String-对象"><a href="#4-1-1-创建-String-对象" class="headerlink" title="4.1.1 创建 String 对象"></a>4.1.1 创建 String 对象</h3><p>您可以使用以下方法之一来创建 string 对象：</p><ul><li>通过给 <code>String</code> 变量指定一个字符串</li><li>通过使用 <code>String</code> 类构造函数</li><li>通过使用字符串串联运算符（ + ）</li><li>通过检索属性或调用一个返回字符串的方法</li><li>通过<strong>格式化方法</strong>来转换一个值或对象为它的字符串表示形式</li></ul><p>具体代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StringApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//字符串，字符串连接</span></span><br><span class="line">            <span class="built_in">string</span> fname, lname;</span><br><span class="line">            fname = <span class="string">&quot;Rowan&quot;</span>;</span><br><span class="line">            lname = <span class="string">&quot;Atkinson&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span> fullname = fname + lname;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Full Name: &#123;0&#125;&quot;</span>, fullname);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过使用 string 构造函数</span></span><br><span class="line">            <span class="built_in">string</span> greetings = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Greetings: &#123;0&#125;&quot;</span>, greetings);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法返回字符串</span></span><br><span class="line">            <span class="built_in">string</span>[] sarray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;From&quot;</span>, <span class="string">&quot;Tutorials&quot;</span>, <span class="string">&quot;Point&quot;</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> message = String.Join(<span class="string">&quot; &quot;</span>, sarray);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于转化值的格式化方法</span></span><br><span class="line">            DateTime waiting = <span class="keyword">new</span> DateTime(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">58</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> chat = String.Format(<span class="string">&quot;Message sent at &#123;0:t&#125; on &#123;0:D&#125;&quot;</span>,</span><br><span class="line">            waiting);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, chat);</span><br><span class="line">            Console.ReadKey() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2-String-类的属性"><a href="#4-1-2-String-类的属性" class="headerlink" title="4.1.2 String 类的属性"></a>4.1.2 String 类的属性</h3><p><code>String</code> 类有以下两个常用属性：</p><div class="table-container"><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Chars</td><td style="text-align:left">在当前 _String_ 对象中获取 _Char_ 对象的指定位置。</td></tr><tr><td style="text-align:center">Length</td><td style="text-align:left">在当前的 _String_ 对象中获取字符数。</td></tr></tbody></table></div><h3 id="4-1-3-String-类的方法"><a href="#4-1-3-String-类的方法" class="headerlink" title="4.1.3 String 类的方法"></a>4.1.3 String 类的方法</h3><p>具体可以参考：<a href="https://www.runoob.com/csharp/csharp-string.html">C# 字符串（String） | 菜鸟教程 (runoob.com)</a>。</p><h2 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h2><p>数组是一个引用类型。数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。</p><h3 id="4-2-1-声明数组"><a href="#4-2-1-声明数组" class="headerlink" title="4.2.1 声明数组"></a>4.2.1 声明数组</h3><p>在 C# 中声明一个数组，您可以使用下面的语法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datatype[] arrayName;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="built_in">int</span>[] id;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>datatype</code>用于指定被存储在数组中的元素的类型</li><li><code>[ ]</code>指定数组的秩（维度）。秩指定数组的大小</li><li><code>arrayName</code> 指定数组的名称</li></ul><h3 id="4-2-2-初始化数组"><a href="#4-2-2-初始化数组" class="headerlink" title="4.2.2 初始化数组"></a>4.2.2 初始化数组</h3><p>声明一个数组不会在内存中初始化数组。当初始化数组变量时，您可以赋值给数组。数组是一个引用类型，所以您需要使用 <strong>new</strong> 关键字来创建数组的实例。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="4-2-3-赋值给数组"><a href="#4-2-3-赋值给数组" class="headerlink" title="4.2.3 赋值给数组"></a>4.2.3 赋值给数组</h3><p>您可以通过使用索引号赋值给一个单独的数组元素，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">balance[<span class="number">0</span>] = <span class="number">4500.0</span>;</span><br></pre></td></tr></table></figure><p>您可以在声明数组的同时给数组赋值，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>您也可以创建并初始化一个数组，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>在上述情况下，你也可以省略数组的大小，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure><p>您也可以赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] score = marks;</span><br></pre></td></tr></table></figure><p>当您创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0。</p><h3 id="4-2-4-访问数组元素"><a href="#4-2-4-访问数组元素" class="headerlink" title="4.2.4 访问数组元素"></a>4.2.4 访问数组元素</h3><p>元素是通过带索引的数组名称来访问的。这是通过把元素的索引放置在数组名称后的方括号中来实现的。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure><h2 id="4-3-枚举"><a href="#4-3-枚举" class="headerlink" title="4.3 枚举"></a>4.3 枚举</h2><p>枚举是值类型。enum：枚举的关键字，声明枚举的关键字。具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line">[<span class="meta">public</span>] <span class="built_in">enum</span> 枚举名</span><br><span class="line">&#123;</span><br><span class="line">    值<span class="number">1</span>,</span><br><span class="line">    值<span class="number">2</span>,</span><br><span class="line">    值<span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> Gender</span><br><span class="line">&#123;</span><br><span class="line">    男,</span><br><span class="line">    女</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Gender gender = Gender.男;</span><br></pre></td></tr></table></figure><h2 id="4-4-结构体"><a href="#4-4-结构体" class="headerlink" title="4.4 结构体"></a>4.4 结构体</h2><p>在 C# 中，结构体是<strong>值类型</strong>数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<code>struct</code>关键字用于创建结构体。结构体是用来代表一个记录。</p><h3 id="4-4-1-构造结构体"><a href="#4-4-1-构造结构体" class="headerlink" title="4.4.1 构造结构体"></a>4.4.1 构造结构体</h3><p>具体语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">public</span>] <span class="keyword">struct</span> 结构名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> 成员;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-C-结构的特点"><a href="#4-4-2-C-结构的特点" class="headerlink" title="4.4.2 C# 结构的特点"></a>4.4.2 C# 结构的特点</h3><p>在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：</p><ul><li>结构可带有方法、字段、索引、属性、运算符方法和事件。</li><li>结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。</li><li>与类不同，结构不能继承其他的结构或类。</li><li>结构不能作为其他结构或类的基础结构。</li><li>结构可实现一个或多个接口。</li><li>结构成员不能指定为 abstract、virtual 或 protected。</li><li>当您使用 <strong>New</strong> 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。</li><li>如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。</li></ul><h1 id="五、函数-方法"><a href="#五、函数-方法" class="headerlink" title="五、函数/方法"></a>五、函数/方法</h1><p>一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。</p><h2 id="5-1-定义方法"><a href="#5-1-定义方法" class="headerlink" title="5.1 定义方法"></a>5.1 定义方法</h2><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] [<span class="keyword">static</span>] 返回值类型 方法名([形式参数列表])</span><br><span class="line">&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-调用方法"><a href="#5-2-调用方法" class="headerlink" title="5.2 调用方法"></a>5.2 调用方法</h2><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名.方法名([实际参数列表]);<span class="comment">//当方法和主函数在同一类下，则不用添加类名</span></span><br><span class="line">对象.方法名([实际参数列表]);</span><br></pre></td></tr></table></figure><h2 id="5-3-函数的递归"><a href="#5-3-函数的递归" class="headerlink" title="5.3 函数的递归"></a>5.3 函数的递归</h2><p>一个方法可以自我调用。这就是所谓的 <strong>递归</strong>。</p><blockquote><p>应当在工程中，避免使用递归方法。因为递归方法</p></blockquote><h2 id="5-4-参数传递与-💗高级参数💗"><a href="#5-4-参数传递与-💗高级参数💗" class="headerlink" title="5.4 参数传递与 💗高级参数💗"></a>5.4 参数传递与 💗<code>高级参数</code>💗</h2><div class="table-container"><table><thead><tr><th style="text-align:center">方式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">值参数</td><td style="text-align:left">这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td></tr><tr><td style="text-align:center">引用参数</td><td style="text-align:left">这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</td></tr><tr><td style="text-align:center">输出参数</td><td style="text-align:left">这种方式可以返回多个值。</td></tr></tbody></table></div><h3 id="5-4-1-按值传递参数"><a href="#5-4-1-按值传递参数" class="headerlink" title="5.4.1 按值传递参数"></a>5.4.1 按值传递参数</h3><p>这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。</p><p>实际参数的值会复制给形参，实参和形参使用的是两个不同内存中的值。所以，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Add10</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a = a+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a,b,c;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = Add10(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把实际参数 a 传入到函数 Add10(a) 中去，在该函数中，对形式参数 a 进行赋值计算，但是形参 a 改变没有影响实参 a ，它们两个使用不同的内存空间。</p><h3 id="5-4-2-按引用传递参数——ref"><a href="#5-4-2-按引用传递参数——ref" class="headerlink" title="5.4.2 按引用传递参数——ref"></a>5.4.2 按引用传递参数——ref</h3><p>引用参数是一个对变量的<strong>内存位置的引用</strong>。当按引用传递参数时，与值参数不同的是，它不会为这些参数创建一个新的存储位置。引用参数表示与提供给方法的实际参数具有相同的内存位置。在 C# 中，使用 <code>ref</code> 关键字声明引用参数。</p><p>在以下示例中，<code>p</code>和<code>x</code>指的是相同的存储器位置：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span> (<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> p</span>)</span> &#123;</span><br><span class="line">       p = p + <span class="number">1</span>;             <span class="comment">// Increment p by 1</span></span><br><span class="line">       Console.WriteLine (p); <span class="comment">// Write p to screen</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">8</span>;</span><br><span class="line">        myMethod (<span class="keyword">ref</span> x);      <span class="comment">// Ask myMethod to deal directly with x</span></span><br><span class="line">        Console.WriteLine (x); <span class="comment">// x is now 9</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-3-按输出传递参数——out"><a href="#5-4-3-按输出传递参数——out" class="headerlink" title="5.4.3 按输出传递参数——out"></a>5.4.3 按输出传递参数——out</h3><p>return 语句可用于只从函数中返回一个值。但是，可以使用 <strong>输出参数</strong> 来从函数中返回两个或多个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。</p><p>out 参数就像一个<code>ref</code>参数，但是它:</p><ul><li>在进入函数之前不需要赋值</li><li><strong>必须在它出来的函数之前赋值</strong></li><li>out 修饰符用于从方法获取多个返回值。</li></ul><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToWords</span> (<span class="params"><span class="built_in">string</span> name, <span class="keyword">out</span> <span class="built_in">string</span> firstNames, <span class="keyword">out</span> <span class="built_in">string</span> lastName</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//out参数要求在方法的内部必须为其赋值</span></span><br><span class="line">       <span class="built_in">int</span> i = name.LastIndexOf (<span class="string">&quot; &quot;</span>);</span><br><span class="line">       firstNames = name.Substring (<span class="number">0</span>, i);</span><br><span class="line">       lastName = name.Substring (i + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> a, b;</span><br><span class="line">        ToWords(<span class="string">&quot;this is a test&quot;</span>, <span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line">        Console.WriteLine (a);</span><br><span class="line">        Console.WriteLine (b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4-params-修饰符"><a href="#5-4-4-params-修饰符" class="headerlink" title="5.4.4 params 修饰符"></a>5.4.4 params 修饰符</h3><p>将实参列表中跟可变参数数组类型一致的元素都当作数组的元素去处理。<code>params</code>参数修饰符用于方法的<strong>最后一个参数</strong>，以便该方法接受任意数量的特定类型的参数。</p><p>参数类型必须声明为数组。</p><p>例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span> (<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] ints</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ints.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          sum += ints[i]; <span class="comment">// Increase sum by ints[i]</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = Sum (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        Console.WriteLine (total); <span class="comment">// 10</span></span><br><span class="line">        <span class="built_in">int</span> total = Sum (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>，<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine (total); <span class="comment">// 15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-5-命名参数"><a href="#5-4-5-命名参数" class="headerlink" title="5.4.5 命名参数"></a>5.4.5 命名参数</h3><p>我们可以通过名称识别参数，参考 Python 的位置参数。例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span> (<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine (x + <span class="string">&quot;, &quot;</span> + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   myMethod (x:<span class="number">1</span>, y:<span class="number">2</span>); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、面向对象——类"><a href="#六、面向对象——类" class="headerlink" title="六、面向对象——类"></a>六、面向对象——类</h1><h2 id="6-1-类的成员"><a href="#6-1-类的成员" class="headerlink" title="6.1 类的成员"></a>6.1 类的成员</h2><p>C#中，类有三个成员：</p><ul><li>字段<ul><li>静态</li><li>非静态</li></ul></li><li>属性<ul><li>静态</li><li>非静态</li></ul></li><li>方法/函数<ul><li>构造方法</li><li>自定义方法</li><li>析构函数</li></ul></li></ul><p>一般格式如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">public</span>] [<span class="keyword">static</span>] <span class="keyword">class</span> <span class="title">ClassName</span>[&lt;泛型&gt;] [:<span class="title">Father</span>]</span><br><span class="line">&#123;</span><br><span class="line">    [字段];</span><br><span class="line">    [属性];</span><br><span class="line">    [方法];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>类名命名规则符合 Pascal 规范。每个单词的首字母都要大写，其余字母小写。比如：MyFirstClass</li><li>静态类和动态类有区别，成员也有就静态和动态的区别，默认为私有、动态类。（这里在随后进行详细说明）</li><li>如果要访问类的成员，你要使用点（.）运算符。</li><li>点运算符链接了对象（或类）的名称和成员的名称。</li></ol><h3 id="6-1-1-字段"><a href="#6-1-1-字段" class="headerlink" title="6.1.1 字段"></a>6.1.1 字段</h3><p>字段是在类或结构中直接声明的任意类型的变量。 字段是其包含类型的成员。</p><p>字段(field) 用来存储数值或对象的真正实体</p><p>注意：</p><ul><li><p>命名规则：</p><ul><li>Camel。骆驼命名规范。变量名中首单词的首字母要小写，其余单词的首字母要大写。</li><li>类的字段一般以<strong>下划线</strong>开头。</li></ul></li></ul><h3 id="6-1-2-属性"><a href="#6-1-2-属性" class="headerlink" title="6.1.2 属性"></a>6.1.2 属性</h3><p>属性从外部看起来像字段，但在内部它们包含逻辑。一个属性被声明为一个字段，但是添加了一个 get / set 块。</p><p>以下是如何实现 CurrentPrice 作为属性：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">decimal</span> _currentPrice;       <span class="comment">// The private &quot;backing&quot; field、</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">decimal</span> CurrentPrice <span class="comment">// The public property</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> _currentPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">          _currentPrice = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性的作用：保护字段，对字段的赋值、取值进行限定</p><ul><li>当给属性赋值时，会执行 set 方法</li><li>当给属性输出时，会执行 get 方法</li></ul><p>注意：</p><ul><li>命名规则符合 Pascal 规范。</li></ul><h3 id="6-1-3-构造方法"><a href="#6-1-3-构造方法" class="headerlink" title="6.1.3 构造方法"></a>6.1.3 构造方法</h3><p>作用：帮助我们给初始化对象（给每个属性依次赋值）</p><p>构造函数是一种特殊的方法；当在实例化类的时候，自动执行函数里面的内容（参考 python 的_<strong>_init__</strong>构造方法）</p><ol><li>构造方法没有返回值，连 void 也不能写</li><li>构造方法的名称必须跟类名一致</li><li>构造方法可以重载</li><li>每写好一个类，就会自带一个无参数的构造方法，<strong>当写了一个构造函数后，默认的无参构造方法就会消失</strong>。</li></ol><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stuident</span>()<span class="comment">//必须是public</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        xxxxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-4-💎this💎-关键字"><a href="#6-1-4-💎this💎-关键字" class="headerlink" title="6.1.4 💎this💎 关键字"></a>6.1.4 💎this💎 关键字</h3><p>this 是 C#中的保留字，</p><ol><li><p>作用 1 ：</p><ul><li>它允许一个对象指向它自己，即 this 表示当前正在被操作的对象本身。</li><li>在方法内部，this 引用可以用于指向任何当前执行的对象。</li><li><p>经常地，this 引用用于区分构造函数的参数和它们相对应的同名的实例变量。</p><p>例如，当一个类有三个字段，实例化后的对象有<code>number、name、owner</code>三个属性。我们在初始化时，可以使用以下方法：</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Money</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> _number;</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">string</span> _owner;</span><br><span class="line">    <span class="function">Public <span class="title">Money</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _number = a;</span><br><span class="line">        _name = b;</span><br><span class="line">        _owner = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Money instance = <span class="keyword">new</span> Money(<span class="number">1</span>,<span class="string">&quot;w&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br></pre></td></tr></table></figure><p> 但是上述方法存在一些问题：为了让类的字段和初始化时传入类的参数做区别，特别的将变量的名称写成不一样的，这样降低了程序代码的可读性。因此可以使用 this 关键字对当前对象进行引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Money</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> _number;</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="built_in">string</span> _owner;</span><br><span class="line">    <span class="function">Public <span class="title">Money</span>(<span class="params"><span class="built_in">int</span> number, <span class="built_in">string</span> name, <span class="built_in">string</span> owner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._number = number;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 等号前面指的是当前操作对象的某一个类成员，后者是传入到类的参数。因此将二者进行了区分。</p></li><li><p>作用 2 ：</p><p> 构造函数重载时，将重载的构造函数的参数传递给其他构造函数，并且使其初始化类。 例如，下面的 Person 类有三个构造方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">this</span>关键字测试</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> _id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> _gender;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name, <span class="built_in">int</span> gender, <span class="built_in">int</span> age</span>)：</span></span><br><span class="line">        &#123;</span><br><span class="line">            _id = id;</span><br><span class="line">            _name = name;</span><br><span class="line">            _gender = gender;</span><br><span class="line">            _age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">int</span> gender</span>) : <span class="title">this</span>(<span class="params">id, <span class="string">&quot;www&quot;</span>, gender, <span class="number">20</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//_id = id;</span></span><br><span class="line">            <span class="comment">//_gender = gender;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">        &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">            Person person1 = <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 首先，当我们 new 创建类的实例化对象时，会调用类的构造函数对类进行初始化。当有多个构造函数时，<strong>会根据传入的参数列表自动选择对应的构造函数</strong>。但是，我们不希望在每个构造函数中，都写一遍初始化语句。因此，我们可以使用 this 关键字，将当前选择的构造函数中已经接收到的参数列表，传给另一个构造函数，<u>多余的参数不用写，缺省的参数要补上</u>。然后<strong>先执行接收 this 传递的参数列表的构造函数，再执行 new 时自动选择的构造函数</strong>。</p></li></ol><h3 id="6-1-5-析构函数"><a href="#6-1-5-析构函数" class="headerlink" title="6.1.5 析构函数"></a>6.1.5 析构函数</h3><ul><li>当程序结束的时候或者类不在被调用的时候，析构函数才运行</li><li>该函数可以帮助我们释放资源</li><li>GC Garbage Collection 垃圾回收，因此，在实际开发中，析构函数并不常用</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Student()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是析构函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-类的构造和实例化"><a href="#6-2-类的构造和实例化" class="headerlink" title="6.2 类的构造和实例化"></a>6.2 类的构造和实例化</h2><h3 id="6-2-1-类的构造"><a href="#6-2-1-类的构造" class="headerlink" title="6.2.1 类的构造"></a>6.2.1 类的构造</h3><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">public</span>] [<span class="keyword">static</span>] <span class="keyword">class</span> <span class="title">ClassName</span>[&lt;泛型&gt;] [:<span class="title">Father</span>]</span><br><span class="line">&#123;</span><br><span class="line">    [字段];</span><br><span class="line">    [属性];</span><br><span class="line">    [方法];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-2-类的实例化"><a href="#6-2-2-类的实例化" class="headerlink" title="6.2.2 类的实例化"></a>6.2.2 类的实例化</h3><p>基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如有个类：Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的实例化</span></span><br><span class="line">Student zhangsan = <span class="keyword">new</span> Student([参数列表]);</span><br></pre></td></tr></table></figure><p>实例化的对象是：zhangsan，该对象的类型为：Student。括号里面是传入到类中的可选参数。</p><p><code>new</code>针对类实例化的作用：</p><ol><li>在内存中开辟一块<strong>新的空间</strong>（堆区）</li><li>调用类的构造方法</li><li><strong>所有的构造方法执行完毕，对象才会被创建</strong></li></ol><blockquote><p><code>new</code>还有其他的一些用法，比如创建变量等，具体功能根据实际代码而定。</p></blockquote><h2 id="6-3-封装"><a href="#6-3-封装" class="headerlink" title="6.3 封装"></a>6.3 封装</h2><p><strong>封装</strong> 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。</p><p>抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</p><p>C# 封装根据具体的需要，设置使用者的访问权限，并通过 <strong>访问修饰符</strong> 来实现。</p><p>一个 <strong>访问修饰符</strong> 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:left">所有对象都可以访问</td></tr><tr><td style="text-align:center">protected internal</td><td style="text-align:left">访问限于当前程序集或派生自包含类的类型</td></tr><tr><td style="text-align:center">internal</td><td style="text-align:left">同一个程序集的对象可以访问</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:left">只有该类对象及其子类对象可以访问</td></tr><tr><td style="text-align:center">private（默认）</td><td style="text-align:left">对象本身在对象内部可以访问</td></tr></tbody></table></div><ul><li>Public 访问修饰符：允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</li><li>Protected Internal 访问修饰符：允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。</li><li>Internal 访问修饰符：允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。换句话说，带有 internal 访问修饰符的任何成员，可以被定义在该成员所定义的<strong>应用程序内</strong>的任何类或方法访问。</li><li>Protected 访问修饰符：允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。</li><li>Private 访问修饰符：允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</li></ul><p>类比理解：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如说：一个人 A 为父类，他的儿子 B，妻子 C，私生子 D（注：D 不在他家里）</span><br><span class="line"></span><br><span class="line">如果我们给 A 的事情增加修饰符：</span><br><span class="line"></span><br><span class="line">public 事件，地球人都知道，全公开</span><br><span class="line">protected internal 事件，A，B，C，D 都知道,其它人不知道</span><br><span class="line">internal 事件，A，B，C 知道（A 家里人都知道，私生子 D 不知道）</span><br><span class="line">protected 事件，A，B，D 知道（A 和他的所有儿子知道，妻子 C 不知道）</span><br><span class="line">private 事件，只有 A 知道（隐私？心事？）</span><br></pre></td></tr></table></figure><h2 id="6-4-继承"><a href="#6-4-继承" class="headerlink" title="6.4 继承"></a>6.4 继承</h2><p>继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。</p><p>当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的 <strong>基类</strong>，这个新的类被称为<strong>派生类</strong>。</p><p>我们可能会在一些类中写重复的成员，我们可以将这些重复的成员，单独的封装到一个类中，作为这些类的<strong>父类</strong>（基类），那么，这些类就叫做<strong>父类</strong>的<strong>子类</strong>（派生类）。</p><p>类可以从另一个类继承以扩展或定制原始类。继承一个类会重用该类中的功能。类只能从一个类继承。</p><h3 id="6-4-1-继承的语法"><a href="#6-4-1-继承的语法" class="headerlink" title="6.4.1 继承的语法"></a>6.4.1 继承的语法</h3><p>继承的格式如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    xxxxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>子类可以从父类中继承：字段、属性、方法</p></li><li><p>子类不能继承父类的<strong>私有</strong>的字段、属性、方法</p></li><li><p>父类不能从子类中调用成员</p></li><li><p><strong>子类没有继承父类的构造函数，子类会默认的调用父类的无参构造方法</strong></p><ol><li><p>子类用 new 实例化时，首先会默认的调用父类的无参构造方法，这一过程是为了创建父类的实例化对象，让子类能使用父类中的成员</p></li><li><p>然后父类的无参构造函数执行完，才会执行自己的构造方法。</p></li><li><p>父类会默认地自带一个无参构造方法，但是<strong>父类中存在有参的构造函数时，默认的无参构造函数就会消失</strong>，这时候创建子类时，会报错。</p></li><li><p>因此，在定义含有<strong>有参构造函数</strong>的父类时，一般需手动定义一个无参的构造函数，以便于让子类调用。</p></li></ol></li><li><p>在子类中显示调用父类的构造函数，使用关键字：base</p><p> 使用此方法一般不用手动构造无参的构造函数，因为子类这时会直接调用父类对应的构造方法（如果父类有有参构造方法，而子类 base 的是父类的无参构造方法，那么还是需要手动在父类中创建无参构造方法），而子类中，一旦含有不使用 base 的构造方法，那么父类就必须存在无参构造方法。</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span> (<span class="params"><span class="built_in">string</span> name , <span class="built_in">int</span> age , <span class="built_in">char</span> gender</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name ,<span class="built_in">int</span> age , <span class="built_in">char</span> gender</span>) : <span class="title">base</span> (<span class="params">name , age , gender</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>继承的单根性：一个子类只能有一个父类</li><li>继承的传递性：子类能继续被继承</li></ol><h3 id="6-4-2-里氏转换"><a href="#6-4-2-里氏转换" class="headerlink" title="6.4.2 里氏转换"></a>6.4.2 里氏转换</h3><ol><li>子类可以赋值给父类：如果有一个地方需要父类作为参数，我们可以给一个子类代替父类</li><li>如果父类对象参数中装的是子类对象，那么可以将这个父类对象强转为子类对象</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PersonSay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是父类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StudentSay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TeacherSay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我是老师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//里氏转换</span></span><br><span class="line">        <span class="comment">//子类赋值给父类</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">/*或者*/</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        Person p = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在父类p中装的是子类对象s，那么可以将这个父类对象强转为子类对象</span></span><br><span class="line">        Student ss = (Student)p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-3-is-与-as-关键字"><a href="#6-4-3-is-与-as-关键字" class="headerlink" title="6.4.3 is 与 as 关键字"></a>6.4.3 is 与 as 关键字</h3><ul><li><p><strong><code>is</code></strong>：表示类型转换，如果能够转换成功，则返回一个 ture，如果转换失败，则返回一个 false</p><p> 例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略上述 6.4.2 的代码</span></span><br><span class="line"><span class="keyword">if</span>（p <span class="keyword">is</span> teacher）</span><br><span class="line">&#123;</span><br><span class="line">    Teacher ss = (Teacher)p;</span><br><span class="line">    ss.TeacherSay();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是:转换失败</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong><code>as</code></strong>：表示类型转换，如果能够转换成功，则返回<strong>对应的对象</strong>，否则返回一个 null</p><p> 例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略上述 6.4.2 的代码</span></span><br><span class="line"><span class="keyword">if</span>（p <span class="keyword">is</span> teacher）</span><br><span class="line">&#123;</span><br><span class="line">    Teacher ss = (Teacher)p;</span><br><span class="line">    ss.TeacherSay();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果是:转换失败</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-4-4-装箱与拆箱"><a href="#6-4-4-装箱与拆箱" class="headerlink" title="6.4.4 装箱与拆箱"></a>6.4.4 装箱与拆箱</h3><p><strong>对象（Object）类型</strong> 是 C# 通用类型系统中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。</p><p>当一个值类型转换为对象类型（引用类型）时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型（引用类型）转换为值类型时，则被称为 <strong>拆箱</strong>。能否装箱或拆箱，要看两种类型之间有无继承关系，有继承关系，就能发生装箱和拆箱。</p><blockquote><p>注意：装箱过程存在类型的转换，因此在程序运行时，需要更多的时间。</p></blockquote><h2 id="6-5-多态"><a href="#6-5-多态" class="headerlink" title="6.5 多态"></a>6.5 多态</h2><p>这里先通过一个例子，来展示父类对象变量装载的是子类对象时，父类、子类同名方法的调用问题。例如下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 多态之虚方法</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//父类对象</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> _name;<span class="comment">//字段</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">        &#125;<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;<span class="comment">//属性</span></span><br><span class="line">        <span class="comment">//父类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是人类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">China</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用父类的构造方法进行实例化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">China</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line">        <span class="comment">//子类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Japanese</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Japanese</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Korea</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Korea</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">American</span> : <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">American</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">        &#123;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建子类对象</span></span><br><span class="line">            China ch1 = <span class="keyword">new</span> China(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">            Japanese j1 = <span class="keyword">new</span> Japanese(<span class="string">&quot;日本&quot;</span>);</span><br><span class="line">            Korea k = <span class="keyword">new</span> Korea(<span class="string">&quot;韩国&quot;</span>);</span><br><span class="line">            American a = <span class="keyword">new</span> American(<span class="string">&quot;美国人&quot;</span>);</span><br><span class="line">            <span class="comment">//创建父类对象数组，并把子类对象装载进去</span></span><br><span class="line">            Person[] person = &#123; ch1, j1, k, a &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                person[i].SayHello();</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是人类</span><br><span class="line">我是人类</span><br><span class="line">我是人类</span><br><span class="line">我是人类</span><br></pre></td></tr></table></figure><p>表明：如果父类和子类中有相同的方法时，那么根据当前操作的对象的类型，执行相应的方法。子类变量会执行子类的方法，父类变量执行父类的方法。</p><p>首先我们理解，<code>Person[] person = &#123; ch1, j1, k, a &#125;</code> 变量类型是<code>Person</code>，但是父类变量中装载的子类对象。</p><p>我们将 for 循环中，添加下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person[i] <span class="keyword">is</span> China)</span><br><span class="line">&#123;</span><br><span class="line">    ((China)person[i]).SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (person[i] <span class="keyword">is</span> Japanese)</span><br><span class="line">&#123;</span><br><span class="line">    ((Japanese)person[i]).SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (person[i] <span class="keyword">is</span> Korea)</span><br><span class="line">&#123;</span><br><span class="line">    ((Korea)person[i]).SayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (person[i] <span class="keyword">is</span> American)</span><br><span class="line">&#123;</span><br><span class="line">    ((American)person[i]).SayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我是中国人</span><br><span class="line">我是人类</span><br><span class="line">我是日本人</span><br><span class="line">我是人类</span><br><span class="line">我是韩国人</span><br><span class="line">我是人类</span><br><span class="line">我是美国人人</span><br><span class="line">我是人类</span><br></pre></td></tr></table></figure><p>表明：如果父类和子类中有相同的方法时，那么根据当前操作的对象的类型，执行相应的方法。子类变量会执行子类的方法，父类变量执行父类的方法。</p><hr><p>多态的直接定义：让一个类能够表现出多种类型的状态（类型）。实现多态的 3 种手段：</p><ol><li>虚方法</li><li>抽象类</li><li>接口</li></ol><p><strong>静态多态性</strong>：在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</p><ul><li>函数重载</li><li>运算符重载</li></ul><p><strong>动态多态性</strong>：使用关键字 <strong><code>abstract</code></strong> 创建<strong>抽象类</strong>，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><p>下面是有关抽象类的一些规则：</p><ul><li>您不能创建一个抽象类的实例，因此抽象类必须被继承才能实例化</li><li>您不能在一个抽象类外部声明一个抽象方法，即抽象方法只能写在抽象类中</li><li>通过在类定义前面放置关键字 <strong><code>sealed</code></strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong><code>sealed</code></strong> 时，它不能被继承。抽象类不能被声明为 <code>sealed</code>。</li></ul><h3 id="6-5-1-虚方法"><a href="#6-5-1-虚方法" class="headerlink" title="6.5.1 虚方法"></a>6.5.1 虚方法</h3><p>抽象方法是需要子类去实现的。<strong>虚方法是已经实现了的，可以被子类覆盖，也可以不覆盖，取决于需求</strong>。</p><p>虚方法可以有实现体，若一个实例方法的声明中含有 <code>virtual</code> 修饰符，则称该方法为虚方法。使用了 <code>virtual</code> 修饰符后，不允许再有 <code>static</code>、<code>abstract</code> 或者 <code>override</code> 修饰符。</p><p><strong>父类的虚方法，可以在子类中重写</strong>（<code>override</code>），此时，再在父类对象中执行该方法，就会只执行对应子类对象的重写的方法。</p><p>例如，将上面的 Person 父类的 <code>SayHello()</code> 方法写为：添加修饰符 <code>virtual</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是人类&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把每个子类里面的 <code>SayHello()</code> 方法写为：添加修饰符 <code>override</code> ：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;人&quot;</span>, <span class="keyword">this</span>.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行多态的代码，就会得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是中国人</span><br><span class="line">我是日本人</span><br><span class="line">我是韩国人</span><br><span class="line">我是美国人</span><br></pre></td></tr></table></figure><p>表明：父类变量里装载的是子类对象，在把父类方法定义为虚方法，并且子类进行重写后，再调用父类对象的方法时，只会执行相应的子类对象的方法。</p><p>如果想不仅能执行子类中重写的方法，还能同时执行父类中的虚方法，我么可以在<strong>子类中重写的方法中调用父类的虚方法</strong>。基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public override void FunctionName()</span><br><span class="line">&#123;</span><br><span class="line">    base.FunctionName();</span><br><span class="line">    [方法体;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总结：当父类变量里装载的是子类对象。在父类中定义虚方法，并在子类中重写这个方法，那么调用父类变量的方法时，就会只执行子类中重写的方法；如果子类没有重写，那么还是会调用自身的方法。</p><h3 id="6-5-2-抽象类"><a href="#6-5-2-抽象类" class="headerlink" title="6.5.2 抽象类"></a>6.5.2 抽象类</h3><p>例如，狗狗会叫，猫猫也会叫，但是狗狗不能作为猫猫的父类，猫猫也不能作为狗狗的父类，因此需要抽象出一个类：动物（<code>animal</code>）。与狗狗类和猫猫类不同的是，动物类不能直接实例化出一个对象，因为范围太大，不确定是狗狗还是猫猫还是其他等，而狗狗类就能实例化出对象（具体的某个狗狗）。</p><p>当父类中的方法不知道怎么去实现的时候，可以把父类定义为抽象类，将方法写成抽象方法。使用 <code>abstract</code> 修饰。</p><p>我们可以写下面代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 抽象类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">            animal.Bark();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//空实现的函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;狗狗会汪汪汪&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;猫猫会喵喵喵&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">狗狗会汪汪汪</span><br></pre></td></tr></table></figure><p>因此，我们知道，当一个抽象父类变量装载子类对象时，调用的方法均是子类的方法。</p><p>抽象类有以下性质：</p><ol><li>抽象类不允许创建该类实例对象，但可以创建该类的子类对象</li><li>抽象方法只能存在于抽象类中</li><li>抽象类包含一般方法和抽象方法<ol><li>一般方法：有方法体</li><li>抽象方法：不允许存在方法体</li></ol></li></ol><h3 id="6-5-3-接口"><a href="#6-5-3-接口" class="headerlink" title="6.5.3 接口"></a>6.5.3 接口</h3><p>接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分。</p><p>接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。接口使得实现接口的类或结构在形式上保持一致。</p><p>抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。</p><p>接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。</p><p>接口的特点：</p><ul><li>接口命名一般在开头加上大写字母 “I”</li><li>接口中的方法，不允许写方法体，并且继承该接口的类中，必须实现该方法的方法体</li><li>接口成员不允许使用访问修饰符</li></ul><h3 id="6-6-部分类和密封类"><a href="#6-6-部分类和密封类" class="headerlink" title="6.6 部分类和密封类"></a>6.6 部分类和密封类</h3><h3 id="6-6-1-部分类"><a href="#6-6-1-部分类" class="headerlink" title="6.6.1 部分类"></a>6.6.1 部分类</h3><p>在同一个命名空间下，不允许创建两个名字相同的类，但是可以创建部分类。部分类使用 <code>partial</code> 关键字修饰，同一类的部分类的名字是相同的，基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分类其实本质上是一个类，只不过将一个类里面的内容分开描述，部分类之间互通的。</p><h3 id="6-6-2-密封类"><a href="#6-6-2-密封类" class="headerlink" title="6.6.2 密封类"></a>6.6.2 密封类</h3><p>当我们创建一个类，但是不想让这个类被继承，可以使用 <code>sealed</code> 关键字修饰，表示不能被继承的密封类。基本语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>开发工具：<a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio 2022 专业版</a></li><li>.NET Framework ：4.7.2</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><details class="folding-tag" ><summary> 更新日志 </summary>              <div class='content'>              <div class="timeline orange"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>更新日志</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-12</p></div></div><div class='timeline-item-content'><ol><li>在<a href="#2-6-可空类型-💖💖💖">2.6 可空类型 💖💖💖</a>中，添加了 <code>??=</code> 的用法</li><li>添加<a href="#2-4-7-lambda-运算符">2.4.7 lambda 运算符</a> 目录，并向其添加了<code>=&gt;</code> 运算符的用法</li><li>在<a href="#2-5-4-占位符">2.5.4 占位符</a>中，添加了 <code>$符</code> 的用法</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-5-10</p></div></div><div class='timeline-item-content'><ol><li>添加了文章 <strong>前言</strong> 部分</li></ol></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> Unity3D </category>
          
          <category> Csharp </category>
          
          <category> Csharp基础 </category>
          
          <category> Unity3D基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> 教程 </tag>
            
            <tag> .NET </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/2023/04/26/Programming/Python%E7%9F%A5%E8%AF%86%E5%BA%93/Python%E5%9F%BA%E7%A1%80/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/04/26/Programming/Python%E7%9F%A5%E8%AF%86%E5%BA%93/Python%E5%9F%BA%E7%A1%80/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h1 id="第一章-初识Python"><a href="#第一章-初识Python" class="headerlink" title="第一章 初识Python"></a>第一章 初识Python</h1><h2 id="1-1-Python简介"><a href="#1-1-Python简介" class="headerlink" title="1.1 Python简介"></a>1.1 Python简介</h2><h3 id="1-1-1-什么是-Python"><a href="#1-1-1-什么是-Python" class="headerlink" title="1.1.1 什么是 Python"></a>1.1.1 什么是 Python</h3><p><font color='red'>Python</font>，发音是[ˈpaɪθɑn]，本意是“蟒蛇”（这里需要说明的是，Python并不是以蟒蛇命名，而是以电视节目 Monty Python’s Flying Circus 来命名的）。它是 1989 年由荷兰人 Guido van Rossum 发明的一种<strong>面向对象的解释型高级语言</strong>。</p><p>Python 有着简单、开发速度快、节省时间和精力的特点。</p><p>Python 本身并非所有与的特性和功能都集成到语言核心，而是被设计为可扩充。它具有丰富和强大的库，能够把用其他语言（尤其是C++）制作的各种模块很轻松的联结在一起。为此，Python 常称为”胶水“语言。</p><h3 id="1-1-2-Python的版本"><a href="#1-1-2-Python的版本" class="headerlink" title="1.1.2 Python的版本"></a>1.1.2 Python的版本</h3><p>Python 自发布以来，主要经历三个版本的变化。</p><ul><li>1994 年发布的 Python 1.0 版本（已过时）</li><li>2000 年发布的 Python 2.0 版本 （逐渐淘汰）</li><li>2008 年发布的 Python 3.0 版本（初学者首选）</li></ul><p>Python 在版本升级时，并不是向下兼容的。</p><h3 id="1-1-3-Python都能做些什么"><a href="#1-1-3-Python都能做些什么" class="headerlink" title="1.1.3 Python都能做些什么"></a>1.1.3 Python都能做些什么</h3><p>Python 作为一种功能强大，并且简单易学的编程语言而广受好评。</p><ol><li>Web 开发</li><li>大数据处理</li><li>人工智能</li><li>自动化运维开发</li><li>云计算</li><li>爬虫</li><li>游戏开发</li></ol><blockquote><p>以下代码将会使用 Pycharm2022.1.3 编译器以及 Python 3.7.2 版本</p></blockquote><h2 id="1-2-搭建-Python-开发环境"><a href="#1-2-搭建-Python-开发环境" class="headerlink" title="1.2 搭建 Python 开发环境"></a>1.2 搭建 Python 开发环境</h2><h3 id="1-2-1-开发环境概述"><a href="#1-2-1-开发环境概述" class="headerlink" title="1.2.1 开发环境概述"></a>1.2.1 开发环境概述</h3><h3 id="1-2-2-安装-Python-解释器"><a href="#1-2-2-安装-Python-解释器" class="headerlink" title="1.2.2 安装 Python 解释器"></a>1.2.2 安装 Python 解释器</h3><h1 id="第二章-Python语言基础"><a href="#第二章-Python语言基础" class="headerlink" title="第二章 Python语言基础"></a>第二章 Python语言基础</h1><h2 id="2-1-Python-语法的特点"><a href="#2-1-Python-语法的特点" class="headerlink" title="2.1 Python 语法的特点"></a>2.1 Python 语法的特点</h2><p>学习 Python 需要了解它的语法特点，如：注释规则、代码缩进、编码规范等。下面将对学习 Python 时首先需要了解的这些语法特点进行详细介绍。</p><h3 id="2-1-1-注释规则"><a href="#2-1-1-注释规则" class="headerlink" title="2.1.1 注释规则"></a>2.1.1 注释规则</h3><p>在代码中添加的标注行文字，从而帮助程序员更好的阅读代码。注释的内容将被 Python 解释器忽略，并不会在执行结果种体现出来。</p><p>在 Python 中，通常包括3 种类型的注释，分别是：单行注释、多行注释和中文注释。</p><ol><li><p>单行注释</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure><p> ​    在  Python 中，使用 “#” 作为单行注释的符号。从符号“#”开始，直到换行结束，其后面所有的内容都会作为注释内容。</p></li><li><p>多行注释</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">注释内容</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p> ​    或者：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注释内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p> ​    多行注释通常用来为 Python 文件、模块、类或者函数（方法）等添加版权、功能信息。</p></li><li><p>中文注释</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:编码 -*-</span></span><br></pre></td></tr></table></figure><p> ​    或者：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = 编码</span></span><br></pre></td></tr></table></figure><p> ​    该注释的出现主要是为了解决 Python 2.x 中不支持直接写中文的情况。虽然在 Python 3.X 中，该问题已经不复存在。但是为了规范页面的编码，也为了方便其他人及时了解文件所使用的编码，建议在文件开头加上中文注释。</p></li></ol><h3 id="2-1-2-代码缩进"><a href="#2-1-2-代码缩进" class="headerlink" title="2.1.2 代码缩进"></a>2.1.2 代码缩进</h3><p>Python 不像其他程序语言一样，采用大括号“{ }”分隔代码块，而是采用代码缩进和冒号“:”区分代码之间的层次。</p><p>例如，下面的代码中的缩进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="built_in">float</span>( <span class="built_in">input</span>( <span class="string">&quot;请输入你的身高：&quot;</span> ) )</span><br><span class="line">weight = <span class="built_in">float</span>( <span class="built_in">input</span>( <span class="string">&quot;请输入你的体重：&quot;</span> ) )</span><br><span class="line">bmi = weight / (height * height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断身材是否合理</span></span><br><span class="line"><span class="keyword">if</span> bmi &lt; <span class="number">18.5</span> :</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;体重过轻&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bmi &gt;= <span class="number">18.5</span> <span class="keyword">and</span> bmi &lt; <span class="number">24.9</span> :</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;正常范围&quot;</span> )</span><br><span class="line"><span class="keyword">if</span> bmi &gt;= <span class="number">24.9</span> <span class="keyword">and</span> bmi &lt; <span class="number">29.9</span> :</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;体重过重&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="2-1-3-编码规范"><a href="#2-1-3-编码规范" class="headerlink" title="2.1.3 编码规范"></a>2.1.3 编码规范</h3><ol><li>编写规则<ul><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块</li><li>不要再行尾添加分号，也不要用分号将两条命令放在同一行</li><li>建议每行不超过 80 个字符</li><li>使用必要的空行可以增强代码的可读性</li><li>通常情况下，运算符两侧、函数参数之间、逗号“,”两侧，建议添加空格</li><li>应该避免在循环中使用+和+=操作符累加字符串。这是因为字符串是不可变的，这样做会创造不必要的临时对象。</li><li>适当使用异常处理</li></ul></li><li>命名规范<ul><li>模块名尽量短小，并且全部使用小写字母，可以用下划线分隔多个单词</li><li>模块名尽量短小，并且全部使用小写字母，不推荐使用下划线</li><li>类名采用单词首字母大写形式（即 Pascal 风格）</li><li>模块内部的类采用下划线+Pascal 风格的类名组成</li><li>函数、类的属性和方法的命名规则同模块类似</li><li>常量命名时采用全部大写字母，可以使用下划线</li><li>单下划线“_”开头的模块变量或者函数时受保护的，在使用 import * from 语句从模块中导入时，这些变量或者函数不能被导入。</li><li>使用双下划线”__“开头的实例变量或方法是类私有的</li></ul></li></ol><h2 id="2-2-Python-中的变量"><a href="#2-2-Python-中的变量" class="headerlink" title="2.2 Python 中的变量"></a>2.2 Python 中的变量</h2><h3 id="2-2-1-保留字与标识符"><a href="#2-2-1-保留字与标识符" class="headerlink" title="2.2.1 保留字与标识符"></a>2.2.1 保留字与标识符</h3><ol><li><p>保留字</p><p> ​    保留字是 Python 语言中已经被赋予特定含义的一些单词，开发程序时，不可以把这些保留字作为变量、函数、类、模块和其他对象的名称来使用。</p><p> ​    Python 中的保留的关键字可以通过以下方法查看：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"></span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure></li><li><p>标识符</p><p> ​    标识符简单理解为一个名字</p><p> ​    Python 语言的标识符命名规则如下：</p><ul><li>由字母、下划线和数字组成，并且不能以数字开</li><li>不能使用 Python 中的保留字</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">and</th><th style="text-align:center">as</th><th style="text-align:center">assert</th><th style="text-align:center">break</th><th style="text-align:center">class</th><th style="text-align:center">continue</th></tr></thead><tbody><tr><td style="text-align:center">def</td><td style="text-align:center">del</td><td style="text-align:center">elif</td><td style="text-align:center">else</td><td style="text-align:center">except</td><td style="text-align:center">finally</td></tr><tr><td style="text-align:center">for</td><td style="text-align:center">from</td><td style="text-align:center">False</td><td style="text-align:center">global</td><td style="text-align:center">if</td><td style="text-align:center">import</td></tr><tr><td style="text-align:center">in</td><td style="text-align:center">is</td><td style="text-align:center">lambda</td><td style="text-align:center">nonlocal</td><td style="text-align:center">not</td><td style="text-align:center">None</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">pass</td><td style="text-align:center">raise</td><td style="text-align:center">return</td><td style="text-align:center">try</td><td style="text-align:center">Ture</td></tr><tr><td style="text-align:center">while</td><td style="text-align:center">with</td><td style="text-align:center">yield</td><td style="text-align:center">\\</td><td style="text-align:center">\\</td><td style="text-align:center">\\</td></tr></tbody></table></div><h3 id="2-2-2-变量"><a href="#2-2-2-变量" class="headerlink" title="2.2.2 变量"></a>2.2.2 变量</h3><p>在 Python 中，严格意义上变量应该称为“名字”，也可以理解为标签。</p><p>定义变量：</p><ul><li>变量名应该是一个有效的标识符</li><li>不能使用保留字</li><li>慎用小写字母 “l” 和大写字母“O”</li><li>应该选用有意义的单词作为变量名</li></ul><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = value</span><br></pre></td></tr></table></figure><p>另外，Python 是一种动态语言，也就是说，变量的类型可以随时变化。</p><blockquote><p>在 Python 中，使用内置函数type()可以返回变量类型。</p></blockquote><p>在 Python 中，允许多个变量指向同一个值。</p><blockquote><p>在Python 中，使用内置函数id()可以返回变量所指的内存地址。</p></blockquote><h2 id="2-3-基本数据类型"><a href="#2-3-基本数据类型" class="headerlink" title="2.3 基本数据类型"></a>2.3 基本数据类型</h2><h3 id="2-3-1-数字"><a href="#2-3-1-数字" class="headerlink" title="2.3.1 数字"></a>2.3.1 数字</h3><ol><li><p>整数</p><ol><li><p>十进制</p><p> ​    例如以下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1456151515151</span></span><br></pre></td></tr></table></figure><blockquote><p>不能以 0 作为十进制数的开头（ 0 除外）</p></blockquote></li><li><p>八进制</p><blockquote><p>在 Python3.X 中，对于八进制数，必须以 0o/0O 开头</p></blockquote></li><li><p>十六进制</p><blockquote><p>在 Python3.X 中，对于十六进制数，必须以 0x/0X 开头</p></blockquote></li><li><p>二进制</p></li></ol></li><li><p>浮点数</p><p> ​    浮点数由整数部分和小数部分组成，主要用于处理包括小数的数。浮点数也可用科学计数法表示。</p></li><li><p>复数</p><p> ​    Python 中的复数与数学中的复数形式完全一致，都是由实部和虚部组成</p></li></ol><h3 id="2-3-2-字符串"><a href="#2-3-2-字符串" class="headerlink" title="2.3.2 字符串"></a>2.3.2 字符串</h3><p>字符串就是连续的字符序列，可以是计算机所能表示的一切字符集合。在 Python 中，字符串数以不可变序列，通常使用单引号、双引号或者三引号、六引号括起来。其中单引号和双引号祖父序列必须在同一行上，而三引号内的字符串可以分布在连续的多行上。</p><h3 id="2-3-3-布尔型"><a href="#2-3-3-布尔型" class="headerlink" title="2.3.3 布尔型"></a>2.3.3 布尔型</h3><h3 id="2-3-3-数据类型的转换"><a href="#2-3-3-数据类型的转换" class="headerlink" title="2.3.3 数据类型的转换"></a>2.3.3 数据类型的转换</h3><p>在 Python 中，提供了以下函数进行各数据类型的转换</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">int(x)</td><td style="text-align:center">将 x 转成整数类型</td></tr><tr><td style="text-align:center">float(x)</td><td style="text-align:center">将 x 转成浮点数类型</td></tr><tr><td style="text-align:center">complex(real ,imag)</td><td style="text-align:center">创建一个复数</td></tr><tr><td style="text-align:center">str(x)</td><td style="text-align:center">将 x 转成字符串</td></tr><tr><td style="text-align:center">repr(x)</td><td style="text-align:center">将 x 转成表达式字符串</td></tr><tr><td style="text-align:center">eval(str)</td><td style="text-align:center">计算 字符串中的有效 Python 表达式，并返回一个对象</td></tr><tr><td style="text-align:center">chr(x)</td><td style="text-align:center">将整数 x 转换成一个字符</td></tr><tr><td style="text-align:center">ord(x)</td><td style="text-align:center">将一个字符 x 转换为它对应的整数值</td></tr><tr><td style="text-align:center">hex(x)</td><td style="text-align:center">将一个整数 x 转换为一个十六进制字符串</td></tr><tr><td style="text-align:center">oct(x)</td><td style="text-align:center">将一个整数 x 转换为一个八进制字符串</td></tr></tbody></table></div><h2 id="2-4-基本输入和输出"><a href="#2-4-基本输入和输出" class="headerlink" title="2.4 基本输入和输出"></a>2.4 基本输入和输出</h2><h3 id="2-4-1-使用-input-函数"><a href="#2-4-1-使用-input-函数" class="headerlink" title="2.4.1 使用 input() 函数"></a>2.4.1 使用 input() 函数</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="built_in">input</span>(<span class="string">&quot;提示文字&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 Python 3.X 中，无论输入的是数字还是字符，都将被作为字符串读取。因此想要接收整数，需要把接受的字符串进行类型转换。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable =<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入整数&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="2-4-2-使用-print-函数输出"><a href="#2-4-2-使用-print-函数输出" class="headerlink" title="2.4.2 使用 print() 函数输出"></a>2.4.2 使用 print() 函数输出</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello world!\n&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="第三章-运算符与表达式"><a href="#第三章-运算符与表达式" class="headerlink" title="第三章 运算符与表达式"></a>第三章 运算符与表达式</h1><h2 id="3-1-运算符"><a href="#3-1-运算符" class="headerlink" title="3.1 运算符"></a>3.1 运算符</h2><p>运算符是一些特殊的符号，主要用于数学计算、比较大小和逻辑运算等。</p><h3 id="3-1-1-算数运算符"><a href="#3-1-1-算数运算符" class="headerlink" title="3.1.1 算数运算符"></a>3.1.1 算数运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">加</td><td style="text-align:center">12.45+16</td><td style="text-align:center">28.45</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减</td><td style="text-align:center">5.231-3.21</td><td style="text-align:center">2.021</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘</td><td style="text-align:center">5*0.1</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除</td><td style="text-align:center">7/2</td><td style="text-align:center">3.5</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">取余</td><td style="text-align:center">7%2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">取整</td><td style="text-align:center">7//2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">幂</td><td style="text-align:center">2**4</td><td style="text-align:center">16</td></tr></tbody></table></div><blockquote><p>在算数操作符中使用 % 取余，如果除数是负数，那么取得的结果也是一个负值。</p><p>在 Python 中，<strong>除法运算，一律按照浮点数进行运算</strong>，因此两个整数相除，结果是浮点数。</p><p>注意：在使用除法、取余和取整运算时，除数不能为 0 ，否则会出现异常。</p></blockquote><h3 id="3-1-2-赋值运算符"><a href="#3-1-2-赋值运算符" class="headerlink" title="3.1.2 赋值运算符"></a>3.1.2 赋值运算符</h3><p>赋值运算符主要用来为变量赋值。使用时，可以直接把等基本赋值运算符右边的值赋给左边的变量，也可以是进行某些运算后再赋值给左边。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-比较（关系）运算符"><a href="#3-1-3-比较（关系）运算符" class="headerlink" title="3.1.3 比较（关系）运算符"></a>3.1.3 比较（关系）运算符</h3><p>用于对变量或表达式的结果进行大小、真假等比较。如果比较为真，则返回 Ture；如果为假，则返回 False 。</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">作用</th><th style="text-align:center">举例</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="3-1-4-逻辑运算符"><a href="#3-1-4-逻辑运算符" class="headerlink" title="3.1.4 逻辑运算符"></a>3.1.4 逻辑运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">用法</th><th style="text-align:center">结合方向</th></tr></thead><tbody><tr><td style="text-align:center">and</td><td style="text-align:center">逻辑与</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">逻辑或</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">逻辑非</td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="3-1-5-位操作符"><a href="#3-1-5-位操作符" class="headerlink" title="3.1.5 位操作符"></a>3.1.5 位操作符</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">举例</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">按位与</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">按位或</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">按位异或</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">按位取反</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移位运算符</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移位运算符</td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="3-2-运算优先级"><a href="#3-2-运算优先级" class="headerlink" title="3.2 运算优先级"></a>3.2 运算优先级</h2><p>由高到低依次是：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">**</td><td style="text-align:center">幂运算</td></tr><tr><td style="text-align:center">~、+、-</td><td style="text-align:center">取反、正号和负号</td></tr><tr><td style="text-align:center">*、/、%、//</td><td style="text-align:center">算数运算符</td></tr><tr><td style="text-align:center">+、-</td><td style="text-align:center">加、减</td></tr><tr><td style="text-align:center">&lt;&lt;、&gt;&gt;</td><td style="text-align:center">左移和右移</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">按位与</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">按位异或</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">按位或</td></tr><tr><td style="text-align:center">&lt;、&lt;=、&gt;、&gt;=、!=、==</td><td style="text-align:center">比较运算符</td></tr></tbody></table></div><h1 id="第四章-流程控制语句"><a href="#第四章-流程控制语句" class="headerlink" title="第四章 流程控制语句"></a>第四章 流程控制语句</h1><h2 id="4-1-程序结构"><a href="#4-1-程序结构" class="headerlink" title="4.1 程序结构"></a>4.1 程序结构</h2><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul><h2 id="4-2-选择语句"><a href="#4-2-选择语句" class="headerlink" title="4.2 选择语句"></a>4.2 选择语句</h2><p>在生活中，我们总是要做出许多选择，程序也是一样。</p><blockquote><p>Python 中，没有 switch 语句，因此为了实现多重选择的功能，只能使用 if……elif……else分支语句或者if语句的嵌套</p></blockquote><h3 id="4-2-1-最简单的-if-语句"><a href="#4-2-1-最简单的-if-语句" class="headerlink" title="4.2.1 最简单的 if 语句"></a>4.2.1 最简单的 if 语句</h3><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure><blockquote><p>如果只有一条语句，语句块可以直接写到冒号的右侧。但是，为了程序的可读性，建议不要这么做。</p></blockquote><h3 id="4-2-2-if……else语句"><a href="#4-2-2-if……else语句" class="headerlink" title="4.2.2 if……else语句"></a>4.2.2 if……else语句</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>在使用else时，else一定不能单独使用。</p></blockquote><h3 id="4-2-3-if……elif……else语句"><a href="#4-2-3-if……elif……else语句" class="headerlink" title="4.2.3 if……elif……else语句"></a>4.2.3 if……elif……else语句</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">2</span>:</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块n</span><br></pre></td></tr></table></figure><h3 id="4-2-4-if语句的嵌套"><a href="#4-2-4-if语句的嵌套" class="headerlink" title="4.2.4 if语句的嵌套"></a>4.2.4 if语句的嵌套</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句块<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句块<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="4-3-循环语句"><a href="#4-3-循环语句" class="headerlink" title="4.3 循环语句"></a>4.3 循环语句</h2><h3 id="4-3-1-while-循环"><a href="#4-3-1-while-循环" class="headerlink" title="4.3.1 while 循环"></a>4.3.1 while 循环</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure><h3 id="4-3-2-for-循环"><a href="#4-3-2-for-循环" class="headerlink" title="4.3.2 for 循环"></a>4.3.2 for 循环</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 对象:</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure><ol><li><p>进行数值循环</p><p> ​    在使用 for 循环时，最基本的应用就是进行数值循环。例如，实现从 1 到 100 的累加。示例代码如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = UTF-8</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;计算 1 到 100 的累加\n&quot;</span> )</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">1</span>, <span class="number">101</span>, <span class="number">1</span> ) :</span><br><span class="line">    <span class="built_in">sum</span> += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;结果是：&quot;</span>, <span class="built_in">sum</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">计算 1 到 100 的累加</span></span><br><span class="line"><span class="string">结果是：5050</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p> ​    其中用到range()函数：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(start,end,step)</span><br></pre></td></tr></table></figure><p> ​    各参数说明如下：</p><ul><li>start：用于指定计数的起始值（包含该值），可以省略，默认值为 0 ；</li><li>end：用于指定计数的结束值（不包含该值），不能省略；</li><li>step：用于指定步长，即两个数之间的间隔，可以省略，默认值为 1 。</li></ul></li><li><p>遍历字符串</p><p> ​    使用 for 循环语句除了可以循环数值，还可以逐个遍历字符串。例如，下面的代码可以将横向显示的字符串转换为纵向显示。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = UTF-8</span></span><br><span class="line">string = <span class="string">&quot;人生苦短，我用Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> string:</span><br><span class="line">    <span class="built_in">print</span>(ch)</span><br></pre></td></tr></table></figure><p> ​    </p><blockquote><p>for 循环语句还可以用于迭代（遍历）列表、元组、集合和字典等</p></blockquote></li></ol><h3 id="4-3-3-循环嵌套"><a href="#4-3-3-循环嵌套" class="headerlink" title="4.3.3 循环嵌套"></a>4.3.3 循环嵌套</h3><p>在 Python 中，允许一个循环体嵌入另一个循环，这称为<font color='red'>循环嵌套</font>。在 Python 中， for 循环和 while 循环都可以进行循环嵌套。</p><h2 id="4-4-break、continue和pass语句"><a href="#4-4-break、continue和pass语句" class="headerlink" title="4.4 break、continue和pass语句"></a>4.4 break、continue和pass语句</h2><ol><li>break：完全终止当前所有循环；</li><li>continue：终止当前循环，进入下一次循环迭代；</li><li>pass：表示空语句，不做任何事，一般起到占位作用。</li></ol><h1 id="第五章-复杂数据类型"><a href="#第五章-复杂数据类型" class="headerlink" title="第五章 复杂数据类型"></a>第五章 复杂数据类型</h1><h2 id="5-1-序列"><a href="#5-1-序列" class="headerlink" title="5.1 序列"></a>5.1 序列</h2><p>序列是一块用于存放多个值得连续内存空间，并且按一定得顺序，每个值（称为元素）都分配一个数字，称为索引或位置。通过该索引可以取出相应的值。</p><h3 id="5-1-1-索引"><a href="#5-1-1-索引" class="headerlink" title="5.1.1 索引"></a>5.1.1 索引</h3><p>序列中的每个元素都有一个编号，也称为索引（Indexing）。这个索引是从 0 开始递增的，即下标为 0 表示第一个元素，下标为 1 表示第二个元素，依次类推。</p><p>Python 比较神奇，它的索引可以是负数。这个索引从右向左计数，也就是从最后一个元素开始计数。最后一个元素的索引为 -1 ，倒数第二个元素的索引值为 -2 ，依此类推。</p><h3 id="5-1-2-切片"><a href="#5-1-2-切片" class="headerlink" title="5.1.2 切片"></a>5.1.2 切片</h3><p>切片（sliceing）操作时访问序列中元素的另一种方法，它可以访问一定范围内的元素。通过切片操作可以生成一个新的序列。</p><p>切片的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sname[start:end:step]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>sname：表示被切序列的名称</li><li>start：表示切片的开始位置（包括该位置），可以省略，默认为 0 ；</li><li>end：表示切片的截至位置（不包括该位置），可以省略，默认为序列的长度</li><li>step：表示切片的步长，可以省略，默认为 1 。当省略步长时，最后一个冒号也可以省略。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verse = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(verse[<span class="number">1</span>:<span class="number">6</span>]) <span class="comment">#获取第 2 到 6 个元素</span></span><br><span class="line"><span class="built_in">print</span>(verse[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]) <span class="comment">#获取第 2、4、6 个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>如果想要复制整个序列，可以将 start 和 end 参数都省略，但是中间的冒号需要保留。</p></blockquote><h3 id="5-1-2-序列相加"><a href="#5-1-2-序列相加" class="headerlink" title="5.1.2 序列相加"></a>5.1.2 序列相加</h3><p>在 Python 中，支持两种相同类型的序列相加（adding）操作，即将两个序列进行连接，但是不会去掉重复的元素，使用 “+” 运算符实现。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verse1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">verse2 = [ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">verse3 = verse1 + verse2</span><br></pre></td></tr></table></figure><h3 id="5-1-4-乘法"><a href="#5-1-4-乘法" class="headerlink" title="5.1.4 乘法"></a>5.1.4 乘法</h3><p>在 Python 中，使用整数 <script type="math/tex">n</script> 乘以一个序列会生成新的序列。新序列的内容为原来序列被重复 <script type="math/tex">n</script> 次的结果。</p><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verse1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">verse3 = verse1 * <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5-1-5-检查某个元素是否是序列成员"><a href="#5-1-5-检查某个元素是否是序列成员" class="headerlink" title="5.1.5 检查某个元素是否是序列成员"></a>5.1.5 检查某个元素是否是序列成员</h3><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value <span class="keyword">in</span> sequence</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>value：表示要检查的元素</li><li>sequence：表示指定的序列</li></ul><p>结果：</p><ul><li>该结果为一个布尔型（bool）</li><li>如果该元素在序列里面，就返回Ture；反之，就返回False。</li></ul><p>另外，在 Python 中，也可以使用 not in 关键字实现检查某个元素是否不包含在指定的序列中</p><h3 id="5-1-6-对序列进行操作的函数"><a href="#5-1-6-对序列进行操作的函数" class="headerlink" title="5.1.6 对序列进行操作的函数"></a>5.1.6 对序列进行操作的函数</h3><p>在 Python 中，提供了内置函数计算序列的长度、最大值和最小值。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>()<span class="comment">#序列的长度，即返回序列包含的元素的个数</span></span><br><span class="line"><span class="built_in">max</span>()<span class="comment">#返回序列元素中的最大值</span></span><br><span class="line"><span class="built_in">min</span>()<span class="comment">#返回序列元素中的最小值</span></span><br></pre></td></tr></table></figure><p>除了上面介绍 3 个内置函数， Python 还提供了下表所示函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">list()</td><td style="text-align:center">将序列转化为列表</td></tr><tr><td style="text-align:center">str()</td><td style="text-align:center">将序列转化为字符串</td></tr><tr><td style="text-align:center">sum()</td><td style="text-align:center">计算元素和</td></tr><tr><td style="text-align:center">sorted()</td><td style="text-align:center">对元素进行排序</td></tr><tr><td style="text-align:center">reversed()</td><td style="text-align:center">反向序列中的元素</td></tr><tr><td style="text-align:center">enumerate()</td><td style="text-align:center">将序列组合为一个索引序列，多用在 for 循环中</td></tr></tbody></table></div><h2 id="5-2-列表"><a href="#5-2-列表" class="headerlink" title="5.2 列表"></a>5.2 列表</h2><p>Python 中的列表，也是由一系列按特定顺序排列的元素组成。它是 Python 中内置的可变序列。在形式上，列表所有元素都放在一对中括号中，两个相邻元素之间使用逗号分隔。在内容上，可以将整数、实数、字符串、列表、元组等任何类型的内容放入列表中，并且<strong>同一个列表中元素的类型可以不同</strong>，因为他们之间没有任何联系。</p><h3 id="5-2-1-列表的创建和删除"><a href="#5-2-1-列表的创建和删除" class="headerlink" title="5.2.1 列表的创建和删除"></a>5.2.1 列表的创建和删除</h3><ol><li><p>使用赋值运算符直接创建列表</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname = [element1,element2,...,element n]</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>listname：表示列表的名字，可以是任何符合 Python 命名规范的标识符</li><li>element：表示列表中的元素</li></ul></li><li><p>创建空列表</p><p> ​    在 Python 中，可以创建空列表。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emptylist = []</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>创建数值列表</p><p> ​    在 Python中，数值列表很常用。可以使用 list() 函数直接将 range() 函数循环出来的结果转换成列表。</p><p> 语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(data)</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>data：表示可以转换成列表的数据，其类型可以是 range 对象、字符串、元组或者其他可迭代的类型的数据。</li></ul></li><li><p>删除列表</p><p> ​    对于已经创建的列表，不在使用时，可以将其删除。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>( <span class="built_in">range</span>( <span class="number">11</span> ) )</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p> ​    </p><blockquote><p>del 在实际开发中，并不常用。因为 Python 自带的垃圾回收机制，会制动销毁不用的列表，所以即使我们不用手动将其删除， Python 也会自动将其收回。</p></blockquote></li></ol><h3 id="5-2-2-访问列表元素"><a href="#5-2-2-访问列表元素" class="headerlink" title="5.2.2 访问列表元素"></a>5.2.2 访问列表元素</h3><p>我们可以用索引来访问列表的某一个元素。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname[index]</span><br></pre></td></tr></table></figure><h3 id="5-2-3-遍历列表"><a href="#5-2-3-遍历列表" class="headerlink" title="5.2.3 遍历列表"></a>5.2.3 遍历列表</h3><ol><li><p>直接 for 循环实现</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> listname:</span><br><span class="line">    循环体<span class="comment">#输出item</span></span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>使用 for 循环和 enumerate() 函数实现</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(listname):</span><br><span class="line">    <span class="comment">#输出 index 和 item</span></span><br></pre></td></tr></table></figure><p> ​    参数说明：</p><ul><li>index：用于保存元素的索引值</li><li>item：用于保存获取的元素值，要输出元素内容时，直接输出该变量即可</li><li>listname：列表的名称</li></ul></li></ol><h3 id="5-2-4-添加、修改和删除列表元素"><a href="#5-2-4-添加、修改和删除列表元素" class="headerlink" title="5.2.4 添加、修改和删除列表元素"></a>5.2.4 添加、修改和删除列表元素</h3><p>添加、修改和删除列表元素也称为更新列表。在实际开发时，经常需要对列表进行更新。</p><ol><li><p>添加元素</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.append(obj)</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>listname：表示要添加的列表名称</li><li><p>obj：要添加到列表末尾的对象</p><p>​    上面介绍的是向列表中添加一个元素。如果想要将一个列表中的全部元素添加到另一个列表中，可以使用列表对象的 extend() 方法实现。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.extend(seq)</span><br></pre></td></tr></table></figure><p>​    其中：</p></li><li><p>listname：表示要添加的列表名称</p></li><li>seq：要添加到列表末尾的列表</li></ul></li><li><p>修改元素</p><p> ​    修改列表中的元素只需要通过索引获取该元素，然后在为其重新赋值即可。</p></li><li><p>删除元素</p><p> ​    删除元素主要由两种情况，一是根据索引删除，另一种是根据元素值进行删除。</p><ol><li><p>根据索引删除</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verse = [<span class="string">&quot;长亭外&quot;</span>, <span class="string">&quot;古道边&quot;</span>, <span class="string">&quot;芳草碧连天&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> verse[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>( verse )</span><br></pre></td></tr></table></figure></li><li><p>根据元素值删除</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">verse = [<span class="string">&quot;长亭外&quot;</span>, <span class="string">&quot;古道边&quot;</span>, <span class="string">&quot;芳草碧连天&quot;</span>]</span><br><span class="line">verse.remove(<span class="string">&quot;古道边&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(verse)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="5-2-5-对列表进行统计"><a href="#5-2-5-对列表进行统计" class="headerlink" title="5.2.5 对列表进行统计"></a>5.2.5 对列表进行统计</h3><ol><li><p>获取指定元素出现的次数</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.count(obj)</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>listname：表示列表的名称</li><li>obj：要匹配的元素</li></ul></li><li><p>获取指定元素首次出现的索引</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.index(obj)</span><br></pre></td></tr></table></figure></li><li><p>统计数值列表的元素和</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span>(listname[,start])</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>listname：表示列表的名称</li><li>start：表示统计开始的位置，可选参数，默认为 0 。</li></ul></li></ol><h3 id="5-2-6-对列表进行排序"><a href="#5-2-6-对列表进行排序" class="headerlink" title="5.2.6 对列表进行排序"></a>5.2.6 对列表进行排序</h3><ol><li><p>使用列表对象的 sort() 方法实现</p><p> ​    列表对象提供了 sort() 方法对原列表中的元素进行排序。排序后原列表中的元素顺序将发生改变。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listname.sort(key = <span class="literal">None</span>,reverse = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>listname：表示要进行排序的列表</li><li>key：表示指定一个从每个序列元素中提取一个比较键</li><li>reverse：可选参数。如果为 Ture，则表示降序排列，如果为 False，则表示升序排列。默认为 Falses 。</li></ul></li><li><p>使用内置的sorted() 函数实现</p><p> ​    在 Python 中，提供一个内置的 sorted() 函数，用于对列表进行排序。使用该函数进行排序后，原列表的元素顺序不变，而是返回一个新的列表。sorted() 函数语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable,key=<span class="literal">None</span>,reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>iterable：表示要进行排序的列表的名称</li><li>key：表示指定一个从每个序列元素中提取一个比较键</li><li>reverse：可选参数。如果为 Ture，则表示降序排列，如果为 False，则表示升序排列。默认为 Falses 。</li></ul></li></ol><h3 id="5-2-7-列表推导式"><a href="#5-2-7-列表推导式" class="headerlink" title="5.2.7 列表推导式"></a>5.2.7 列表推导式</h3><p>使用列表推导式可以快速生成一个列表，或者根据某个列表生成满足指定需求的列表。列表推导式通常有以下几种常用的语法格式</p><ol><li><p>生成指定范围的数值列表</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">range</span>]</span><br></pre></td></tr></table></figure><p> ​    参数说明：</p><ul><li>list：表示生成的列表名称</li><li>Expression：表达式，用于计算新列表的元素</li><li>var：循环变量</li><li><p>range：采用 range() 函数生成的 range 对像</p><p>​    例如，要生成一个包含 10 个随机数的列表，要求数的范围在 10-100 之间（包括100），具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">randomnumber = [random.randint( <span class="number">10</span>, <span class="number">100</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">10</span> )]</span><br><span class="line"><span class="built_in">print</span>( randomnumber )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>根据列表生成指定需求的列表</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newlist = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">list</span>]</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>newlist：表示新生成的列表名称</li><li>Expression：表达式，用于计算新列表的元素</li><li>var：循环变量</li><li><p>list：用于生成新列表的原列表</p><p>​    例如，定义一个记录商品价格的列表，然后应用列表推导式，生成一个将全部商品价格打五折的列表，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">price = [<span class="number">3124</span>, <span class="number">2134</span>, <span class="number">1400</span>, <span class="number">800</span>, <span class="number">500</span>]</span><br><span class="line">sale = [<span class="built_in">int</span>( x / <span class="number">2</span> ) <span class="keyword">for</span> x <span class="keyword">in</span> price]</span><br><span class="line"><span class="built_in">print</span>( price )</span><br><span class="line"><span class="built_in">print</span>( sale )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从列表中选择符合条件的元素组成新的列表</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newlist = [Expression <span class="keyword">for</span> var <span class="keyword">in</span> <span class="built_in">list</span> <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>newlist：表示新生成的列表名称</li><li>Expression：表达式，用于计算新列表的元素</li><li>var：循环变量</li><li>list：用于生成新列表的原列表</li><li>condition：条件表达式，用于指定筛选条件</li></ul></li></ol><h3 id="5-2-8-二维列表"><a href="#5-2-8-二维列表" class="headerlink" title="5.2.8 二维列表"></a>5.2.8 二维列表</h3><ol><li><p>直接定义二列列表</p><p> ​    例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p> ​    每一行为一个一维列表，列表直接用逗号隔开。</p></li><li><p>使用嵌套的 for 循环创建</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    arr.append([])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        arr[i].append(j)</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>使用列表推导式创建</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [[i <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure></li></ol><p>如果要访问二维列表中的元素，使用索引的方式。</p><h2 id="5-3-元组"><a href="#5-3-元组" class="headerlink" title="5.3 元组"></a>5.3 元组</h2><p>元组（tuple）是 Python 中另一个重要的序列结构，与列表类似，也是由一系列按照特定顺序排列的元素组成。<strong>但是它是不可变序列</strong>。因此元组也称为不可变列表。在形式上，元组的所有元素都放在一对小括号内，两个相邻的元素用逗号隔开。</p><h3 id="5-3-1-元组的创建"><a href="#5-3-1-元组的创建" class="headerlink" title="5.3.1 元组的创建"></a>5.3.1 元组的创建</h3><ol><li><p>使用赋值运算符直接创建</p><p> ​    同其他类型的 Python 语法一样，创建元组时，也可以用赋值运算符直接将一个元组赋值给变量。具体的语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuplename = (element <span class="number">1</span>,element <span class="number">2</span>,element <span class="number">3</span>,...,element n)</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>创建空元组</p><p> ​    在 Python 中，也可以创建空元组。语法如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">empty = （）</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>创建数值元组</p><p> ​    在 Python 中，可以使用 tuple() 函数直接将 range() 函数循环出来的结果转换为数值元组。</p><blockquote><p>​    有关 range() 函数的详细介绍，请参见 <a href="#4-3-2-for-循环">4.3.2</a> 节</p></blockquote><p> ​    tuple() 函数的用法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span>(data)</span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">range</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除元组</p><p> ​    对于已经创建的元组，不再使用时，可以用 del 语句将其删除。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> tuplename</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-3-2-访问元组元素"><a href="#5-3-2-访问元组元素" class="headerlink" title="5.3.2 访问元组元素"></a>5.3.2 访问元组元素</h3><p>在Python 中，如果想要把元组的所有元素输出，可以直接使用 print() 函数。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br></pre></td></tr></table></figure><p>或者通过元组的索引获取指定的元素。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span>[<span class="number">2</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span>[-<span class="number">2</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span>[<span class="number">0</span> :<span class="number">6</span> :<span class="number">2</span>] ) <span class="comment">#前两者输出的是单个元素，这个输出的是一个新的元组</span></span><br></pre></td></tr></table></figure><p>另外，元组还可以使用 for 循环和 enumerate() 函数结合进行遍历。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> <span class="built_in">enumerate</span>( <span class="built_in">tuple</span> ) :</span><br><span class="line">    <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>( item, <span class="string">&quot;,&quot;</span>, end=<span class="string">&quot;&quot;</span> )</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="built_in">print</span>( item, <span class="string">&quot;。&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="5-3-3-修改元组"><a href="#5-3-3-修改元组" class="headerlink" title="5.3.3 修改元组"></a>5.3.3 修改元组</h3><p>元组是不可变序列，所以我们不能对它单个元素的值进行修改，但是元组也不是完全不能修改。我们可以对元组重新赋值。例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br><span class="line"><span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br></pre></td></tr></table></figure><p>另外，还可以对元组进行连接组合。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">tuple2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( tuple1 + tuple2 )</span><br></pre></td></tr></table></figure><blockquote><p>在进行元组连接时，连接的内容必须都是元组。不能将元组和字符串或者是列表进行连接。</p></blockquote><h3 id="5-3-4-元组推导式"><a href="#5-3-4-元组推导式" class="headerlink" title="5.3.4 元组推导式"></a>5.3.4 元组推导式</h3><p>使用元组推导式可以快速成成一个元组，它的表现形式和列表推导式类似，只是将列表推导式中的中括号换成小括号。例如下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span> = (random.randint( <span class="number">10</span>, <span class="number">100</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">5</span> ))</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">tuple</span> )</span><br></pre></td></tr></table></figure><h3 id="5-3-5-元组与列表的区别"><a href="#5-3-5-元组与列表的区别" class="headerlink" title="5.3.5 元组与列表的区别"></a>5.3.5 元组与列表的区别</h3><ol><li>列表属于可变序列，它的元素可以随时修改或删除；而元组属于不可变序列，其中的元组不可以修改，除非<strong>整体替换</strong></li><li>列表可以使用 append() 、 extend() 、 insert() 、 remove() 和 pop() 等方法实现添加和修改列表元素；而元组没有这些方法，也不能删除元素</li><li>列表可以使用切片访问和修改列表中的元素；元组也支持切片，但是只支持切片访问元组中的元素，不支持修改</li><li>元组的访问和处理速度比列表快。所以如果只需要对其中的元组进行访问，而不进行任何修改，建议使用元组而不使用列表</li><li>列表不能作为字典的键；而元组可以</li></ol><h2 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h2><p>字典（dictionary）和列表类似，也是可变序列，不过与列表不同 ，它是无序可变序列，保存的内容是以“键-值对”的形式存放的。类似于 Java 或者 C++ 中的 Map 对象。</p><p>字典的主要特征如下：</p><ul><li>通过键而不是通过索引来读取</li><li>字典是任意对象的无序集合</li><li>字典是可变的，并且可以任意嵌套</li><li>字典中的键必须唯一</li><li>字典中的键必须不可变</li></ul><h3 id="5-4-1-字典的创建和删除"><a href="#5-4-1-字典的创建和删除" class="headerlink" title="5.4.1 字典的创建和删除"></a>5.4.1 字典的创建和删除</h3><p>定义字典是，每个元素都包含两个部分：“键”和“值”，并且在“键”和“值”之间，用冒号分隔，相邻两个元素使用逗号隔开，所有元素放在一个大括号中。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = &#123;<span class="string">&#x27;key 1&#x27;</span>:<span class="string">&#x27;value 1&#x27;</span>,<span class="string">&#x27;key 2&#x27;</span>:<span class="string">&#x27;value 2&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>dictionary：表示字典的名称</li><li>key：表示元素的键，必须是唯一的，并且不可变</li><li>value：表示元素的值，可以是任何数据类型，不是必须唯一</li></ul><p>铜列表和元组一样，也可以创建空字典。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictionary = &#123;&#125;</span><br><span class="line">dictionary = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p>Python 的 dicr() 方法除了可以创建一个空字典外，还可以通过已有数据快速创建字典。主要表现为以下两种形式：</p><ol><li><p>通过映射函数创建字典</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="built_in">dict</span>(<span class="built_in">zip</span>(list1,list2))</span><br></pre></td></tr></table></figure><p>  参数说明如下：</p><ul><li>dictionary：表示字典的名称</li><li>zip() 函数：用于将多个列表或元组对应位置的元素组合成为元组，并返回包含这些内容的 zip 对象。如果想要得到元组，可以将 zip 对象使用 tuple() 函数转换为元组；如果想要得到列表，则可以使用 list() 函数将其转换成列表</li></ul></li><li><p>通过给定的键值对</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="built_in">dict</span>(key1 = value1,key2 = value2)</span><br></pre></td></tr></table></figure><p> ​    </p><p> 在 Python 中，还可以使用 dict 对象的 fromkeys() 方法创建值为空的字典。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="built_in">dict</span>,fromkeys(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p> ​    参数说明：</p><ul><li>dictionary：表示字典的名称</li><li>list：表示作为字典的键的列表</li></ul></li></ol><h3 id="5-4-2-访问字典"><a href="#5-4-2-访问字典" class="headerlink" title="5.4.2 访问字典"></a>5.4.2 访问字典</h3><p>在 Python 中，如果想要将字典的全部元素输出，可以直接用 print() 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary )</span><br></pre></td></tr></table></figure><p>但是，使用字典是，很少直接输出它的内容。一般根据指定的键得到相应的结果。在 python 中，访问字典元素可以通过 键 的方式实现。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary )</span><br><span class="line"><span class="built_in">print</span>( dicttionary[<span class="string">&quot;甘雨&quot;</span>] )</span><br></pre></td></tr></table></figure><p>在实际开发过程中，很可能我们不知道当前存在什么键，所以避免该异常的产生。具体的解决方法是使用 if 语句对不存在的情况进行处理，即给定一个默认值。例如，可以将上面的代码修改为以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary[<span class="string">&quot;神里凌华&quot;</span>] <span class="keyword">if</span> <span class="string">&quot;神里凌华&quot;</span> <span class="keyword">in</span> dicttionary <span class="keyword">else</span> <span class="string">&quot;我的字典里没有此人&quot;</span> )</span><br></pre></td></tr></table></figure><p>另外， Python 中推荐的方法hi是使用字典对象的 get() 方法获取指定键的值。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dicttionary.get(key[,default])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>dictionary：表示当前操作的字典对象</li><li>key：指定的键</li><li>default：可选参数，默认为 None 。用于当指定的键不存在时，返回一个默认值。</li></ul><p>例如，上面的代码可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( dicttionary.get( <span class="string">&quot;雷电将军&quot;</span> ) )</span><br></pre></td></tr></table></figure><h3 id="5-4-3-遍历字典"><a href="#5-4-3-遍历字典" class="headerlink" title="5.4.3 遍历字典"></a>5.4.3 遍历字典</h3><p>字典是以“键-值对”的形式存储数据，素以就可能需要对这些“键-值对”进行获取。Python 提供了遍历字典的方法，通过遍历可以获取字典中的全部“键-值对”。</p><p>使用字典对象的 items() 方法可以获取字典的“键-值对”列表。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary.items()</span><br></pre></td></tr></table></figure><p>其中，dictionary 为字典对象；返回值为可遍历的“键-值对”元组列表。</p><blockquote><p>在 Python 中，字典对象还提供了 values() 和 keys() 方法，用于返回字典的“值”和“键”列表</p></blockquote><h3 id="5-4-4-添加、修改和删除字典元素"><a href="#5-4-4-添加、修改和删除字典元素" class="headerlink" title="5.4.4 添加、修改和删除字典元素"></a>5.4.4 添加、修改和删除字典元素</h3><p>由于字典是可变序列，所以可以随时在其中添加“键-值对”，这和列表类似。向字典中添加元素的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictionary[key] = value</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>dictionary：表示字典的名称</li><li>key：表示要添加的元素的键，必须是唯一的，并且不可变</li><li>value：表示元素的值，可以是任何数据类型，不是必须唯一</li></ul><p>由于在字典中，“键”必须是唯一的，所以如果添加的新元素的“键”已经存在，则会用新元素的值替换掉旧元素的值，相当于修改字典的元素的值。</p><p>当字典中某个元素不需要时，可以使用 del 语句将其删除。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dicttionary = <span class="built_in">dict</span>( 甘雨=<span class="string">&#x27;冰系&#x27;</span>, 胡桃=<span class="string">&quot;火系&quot;</span>, 雷电将军=<span class="string">&quot;雷系&quot;</span> )</span><br><span class="line"><span class="keyword">del</span> dicttionary[<span class="string">&quot;甘雨&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>( dicttionary )</span><br></pre></td></tr></table></figure><blockquote><p>当删除一个不存在的键时，将会抛出异常</p></blockquote><h3 id="5-4-5-字典推导式"><a href="#5-4-5-字典推导式" class="headerlink" title="5.4.5 字典推导式"></a>5.4.5 字典推导式</h3><p>使用字典推导式可以快速生成一个字典，它的表现形式和列表推导式类似。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">dictionary = &#123; i : random.randint( <span class="number">10</span>, <span class="number">100</span> ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">5</span> ) &#125;</span><br><span class="line"><span class="built_in">print</span>( dictionary )</span><br></pre></td></tr></table></figure><h2 id="5-5-集合"><a href="#5-5-集合" class="headerlink" title="5.5 集合"></a>5.5 集合</h2><p>Python中的集合（set）与数学中的集合概念类似，也是用于保存不重复元素。它有可变集合和不可变集合两种。</p><h3 id="5-5-1-创建集合"><a href="#5-5-1-创建集合" class="headerlink" title="5.5.1 创建集合"></a>5.5.1 创建集合</h3><ol><li><p>直接使用大括号创建</p><p> ​    语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname = &#123;element <span class="number">1</span>,element <span class="number">2</span>,...&#125;</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>使用 set() 函数创建</p><p> ​    在 Python 中，可以使用 set() 函数将列表、元组等其他可迭代对象转换为集合。 set() 函数的语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname = <span class="built_in">set</span>(iteration)</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-5-2-向集合中添加和删除元素"><a href="#5-5-2-向集合中添加和删除元素" class="headerlink" title="5.5.2 向集合中添加和删除元素"></a>5.5.2 向集合中添加和删除元素</h3><ol><li><p>向集合中添加元素</p><p> ​    向集合中添加元素可以使用 add() 方法实现。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname.add(element)</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>从集合中删除元素</p><p> ​    在 Python 中，可以使用 del 语句删除整个集合，也可以使用集合的 pop() 方法或者 remove() 方法删除一个元素，或者使用集合对象的 clear() 方法清空集合，使其变为空集合。</p></li></ol><h3 id="5-5-3-集合的交集、并集和差集运算"><a href="#5-5-3-集合的交集、并集和差集运算" class="headerlink" title="5.5.3 集合的交集、并集和差集运算"></a>5.5.3 集合的交集、并集和差集运算</h3><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">两个集合的交集</td></tr><tr><td style="text-align:center">$\vert$</td><td style="text-align:center">两个集合的并集</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">两个集合的差集</td></tr></tbody></table></div><h1 id="第六章-字符串"><a href="#第六章-字符串" class="headerlink" title="第六章 字符串"></a>第六章 字符串</h1><h2 id="6-1-字符串编码转换"><a href="#6-1-字符串编码转换" class="headerlink" title="6.1 字符串编码转换"></a>6.1 字符串编码转换</h2><h3 id="6-1-1-使用-encode-方法编码"><a href="#6-1-1-使用-encode-方法编码" class="headerlink" title="6.1.1 使用 encode() 方法编码"></a>6.1.1 使用 encode() 方法编码</h3><p>encode() 方法为 str 对象的方法，用于将字符串转化成二进制数据，也称为“编码”。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;人活着就是为了樱岛麻衣!&quot;</span></span><br><span class="line"><span class="built_in">str</span>.encode( encoding=<span class="string">&quot;utf-8&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">str</span> )</span><br><span class="line">//<span class="built_in">str</span>.encode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>str：表示要进行转换的字符串</li><li>encoding=”utf-8”：可选参数，默认为 utf-8，用于指定进行转码时采用的字符编码</li><li>errors=”strict”：可选参数，默认值为strict，用于指定错误的处理方式。</li></ul><blockquote><p>在使用 encode() 方法时，不会修改原字符串，只是改变显示的方式。</p></blockquote><h3 id="6-1-2-使用-decode-方法解码"><a href="#6-1-2-使用-decode-方法解码" class="headerlink" title="6.1.2 使用 decode() 方法解码"></a>6.1.2 使用 decode() 方法解码</h3><p>decode() 方法为 bytes 对象的方法，用于将二进制数据转换为字符串，即将使用 encode() 方法转换的结果再转换为字符串，也称为“解码”。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.decode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>bytes：表示要进行转换的二进制数据</li><li>encoding=”utf-8”：可选参数，默认为 utf-8，用于指定进行转码时采用的字符编码</li><li>errors=”strict”：可选参数，默认值为strict，用于指定错误的处理方式。</li></ul><blockquote><p>在使用 decode() 方法时，不会修改原字符串，只是改变显示的方式。</p></blockquote><h2 id="6-2-字符串常用操作"><a href="#6-2-字符串常用操作" class="headerlink" title="6.2 字符串常用操作"></a>6.2 字符串常用操作</h2><h3 id="6-2-1-拼接字符串"><a href="#6-2-1-拼接字符串" class="headerlink" title="6.2.1 拼接字符串"></a>6.2.1 拼接字符串</h3><p>使用“+”运算符可完成对多个字符串的拼接，并且返回一个新的字符串。例如，定义两个字符串，然后用“+”运算符连接，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;人活着就是&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;为了樱岛麻衣!&quot;</span></span><br><span class="line"><span class="built_in">print</span>( str1 )</span><br><span class="line"><span class="built_in">print</span>( str2 )</span><br><span class="line"><span class="built_in">print</span>( str1 + str2 )</span><br></pre></td></tr></table></figure><blockquote><p>字符串不允许直接与其他类型的数据进行拼接。</p></blockquote><h3 id="6-2-2-计算字符串的长度"><a href="#6-2-2-计算字符串的长度" class="headerlink" title="6.2.2 计算字符串的长度"></a>6.2.2 计算字符串的长度</h3><p>由于不同的字符所占的字节数不同，所以要计算字符串长度，需要了解各字符所占的字节数。在 Python 中，数字、英文、小数点、下划线和空格占一个字节；一个汉字可能会占 2-4 个字节，占几个字节取决于采用的编码。下面以 Python 默认的 UTF-8 编码为例，即一个汉字占三个字节。</p><p>在 Python 中，提供了 len() 函数计算字符串的长度。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(string)</span><br></pre></td></tr></table></figure><p>在默认情况下，通过 len() 函数计算字符串长度时，不区分英文、数字和汉字，所有字符都认为是一个。</p><p>在实际开发时，有时需要获取字符串实际所占的字节数。这时，可以通过使用 encode() 方法进行编码后，在进行获取。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;人活着就是为了樱岛麻衣!&quot;</span></span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">len</span>( <span class="built_in">str</span> ) )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">len</span>( <span class="built_in">str</span>.encode() ) )</span><br></pre></td></tr></table></figure><h3 id="6-2-3-截取字符串"><a href="#6-2-3-截取字符串" class="headerlink" title="6.2.3 截取字符串"></a>6.2.3 截取字符串</h3><p>由于字符串也属于序列，所以要截取字符串，可以采用切片的方法。通过切片的方法截取字符串的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string[start:end:step]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>string：表示要截取的字符串；</li><li>satrt：表示要截取的第一个字符索引（包括该字符），可选，默认为 0 ；</li><li>end：表示要截取的最后一个字符的索引（不包含该字符），可选，默认为字符串的长度；</li><li>step：表示切片的步长，可选，默认为 1 。当省略 step 时，随后一个冒号也可以省略</li></ul><h3 id="6-2-4-分割、合并字符串"><a href="#6-2-4-分割、合并字符串" class="headerlink" title="6.2.4 分割、合并字符串"></a>6.2.4 分割、合并字符串</h3><p>在 Python 中，字符串对象提供了分割和合并字符串的方法。分割字符串是把字符串分割为列表，而合并字符串时把列表合并为字符串，它们可以看作是互逆操作。</p><ol><li><p>分割字符串</p><p> ​    字符串对象的 split() 方法可以实现字符串分割。即把一个字符串按照指定的分隔符切分为字符串列表。该列表的元素中，不包含分隔符。具体的语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.split(sep,maxsplit)</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>str：表示要进行分割的字符串</li><li>sep：用于指定分隔符，可以包含多个字符，默认为 None ，即所用空字符（包括空格、换行、制表符等）</li><li>maxsplit：用于指定分割的次数，可选参数。如果不指定或者为 -1 ，则分割次数没有限制，否则，返回结果列表的元素个数最多为 maxsplit+1 </li><li>返回值：分割后的字符串列表</li></ul></li><li><p>合并字符串</p><p> ​    合并字符串与拼接字符串不同，它会将多个字符串采用固定的分隔符连接再一起。合并字符串可以使用字符串对象的 join() 方法实现。具体语法格式：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strnew = string.join(iterable)</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>strnew：表示合并后的新字符串</li><li>string：字符串类型，用于指定合并时的分隔符      </li><li>iterable：可迭代对象，该迭代对象中的所有元素（字符串）将会被合并为一个新的字符串。</li></ul></li></ol><h3 id="6-2-5-检索字符串"><a href="#6-2-5-检索字符串" class="headerlink" title="6.2.5 检索字符串"></a>6.2.5 检索字符串</h3><p>在 Python 中，字符串对象提供了很多应用于字符串查找的方法。</p><ol><li><p>count() 方法</p><p>​    count() 方法用于检索指定字符串在另一个字符串中出现的次数。如果检索的字符串不存在，则返回 0 ；否则返回出现的次数。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.count(sub[,start[,end]])</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>sub：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li><li><p>find() 方法</p><p> ​    该方法用于检索是否包含指定的子字符串。如果检索的子字符串不存在，则返回 -1 ；反之，返回首次出现该子字符串时的索引。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.find(sub[,start[,end]])</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>sub：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li><p>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</p><blockquote><p>如果只想判断指定的字符串是否存在，可以使用 in 关键字实现。sub in string ：如果存在，就返回 Ture；反之，返回 False 。另外也可以根据find() 方法的返回值是否大于 -1 来确定是否存在。</p></blockquote><p>​    </p><blockquote><p>Python 的字符串对象还提供了 rfind() 方法，从字符串右边开始查找。</p></blockquote></li></ul></li><li><p>index() 方法</p><p> ​    index() 方法与 find() 方法类似，也是用于检索是否包含子字符串。只不过如果使用 index() 方法，当指定的字符串不存在时会抛出异常。其语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.index(sub[,start[,end]])</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>sub：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li><li><p>startswitch() 方法</p><p> ​    该方法用于检索字符串是否以指定子字符串开头。如果是，返回 Ture；反之，返回 False。语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.startswitch(prefix[,start[,end]])</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>prefix：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li><li><p>endswitch() 方法</p><p> ​    该方法用于检索字符串是否以指定子字符串结尾。如果是，返回 Ture；反之，返回 False。语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.endswitch(prefix[,start[,end]])</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>str：表示原字符串</li><li>prefix：表示要检索的子字符串</li><li>start：可选参数，表示检索范围的起始位置的索引，默认为 0 ；</li><li>end：可选参数，表示检索范围的结束位置的索引，默认为一直检索结尾</li></ul></li></ol><h3 id="6-2-6-字母的大小写转换"><a href="#6-2-6-字母的大小写转换" class="headerlink" title="6.2.6 字母的大小写转换"></a>6.2.6 字母的大小写转换</h3><p>在 Python 中，字符串对象提供了 lower() 方法和 upper() 方法进行字母的大小写转换。</p><ol><li><p>lower() 方法</p><p> ​    lower() 方法用于将字符串中的全部大写字母转换成小写字母。字符串长度与原字符串长度相同。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.lower()</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>upper() 方法</p><p> ​    用于将字符串中的全部小写字母转换成大写字母。字符串长度与原字符串长度相同。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.upper()</span><br></pre></td></tr></table></figure><p> ​    </p></li></ol><h3 id="6-2-7-去除字符串中的空格和特殊字符"><a href="#6-2-7-去除字符串中的空格和特殊字符" class="headerlink" title="6.2.7 去除字符串中的空格和特殊字符"></a>6.2.7 去除字符串中的空格和特殊字符</h3><p>用户在输入数据时，可能会无意中输入多余的空格，或在一些情况下，字符串前后不允许出现空格和特殊字符，此时就需要去除字符串中的空格和特殊字符。</p><ol><li><p>strip() 方法</p><p> ​    该方法用于去掉字符串左、右两侧空格和特殊字符。其语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.strip([chars])</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>str：要去除字符的字符串</li><li>chars：可选参数，用于指定要去除的字符，可以指定多个，默认指定空格、制表符、回车符和换行符。</li></ul></li><li><p>lstrip() 方法</p><p> ​    该方法用于去掉字符串左侧的空格和特殊字符，其语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.lstrip([chars])</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>str：要去除字符的字符串</li><li>chars：可选参数，用于指定要去除的字符，可以指定多个，默认指定空格、制表符、回车符和换行符。</li></ul></li><li><p>rstrip() 方法</p><p> ​    该方法用于去掉字符串右侧的空格和特殊字符，其语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.rstrip([chars])</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>str：要去除字符的字符串</li><li>chars：可选参数，用于指定要去除的字符，可以指定多个，默认指定空格、制表符、回车符和换行符。</li></ul></li></ol><h3 id="6-2-8-格式化字符串"><a href="#6-2-8-格式化字符串" class="headerlink" title="6.2.8 格式化字符串"></a>6.2.8 格式化字符串</h3><p>格式化字符串的意思是先制定一个模板，在这个模板中预留几个位置，然后再根据需要填上相应的内容。这些空位需要通过指定的符号标记（也称为占位符），而这些符号还不会显示出来。在 Python 中，格式化字符串有两种方法。</p><ol><li><p>使用 % 操作符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%[-][+][0][m][.n]格式化字符&quot;</span>%exp</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li>-：可选参数，用于指定左对齐，正数前方无符号，负数前方加负号</li><li>+：可选参数，用于指定右对齐，正数前方加正号，负数前方加负号</li><li>0：可选参数，表示右对齐，正数前方无符号，负数前方加负号，用 0 填充数字空白处（一般与 m 参数一起使用）</li><li>m：可选参数，表示占有宽度（或数字显示出的位数）</li><li>.n：可选参数，表示小数点后保留的位数</li><li>格式化字符：用于指定字符的类型</li><li>exp：要转换的项。如果要制定的项有多个，需要通过元组的形式进行指定，但是不能使用列表。</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">格式字符</th><th style="text-align:center">说明</th><th style="text-align:center">格式字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td><td style="text-align:center">%r</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">单个字符</td><td style="text-align:center">%o</td><td style="text-align:center">八进制整数</td></tr><tr><td style="text-align:center">%d或者%i</td><td style="text-align:center">十进制整数</td><td style="text-align:center">%e</td><td style="text-align:center">指数（基底写为e）</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制整数</td><td style="text-align:center">%E</td><td style="text-align:center">指数（基底写为E）</td></tr><tr><td style="text-align:center">%f或者%F</td><td style="text-align:center">浮点数</td><td style="text-align:center">%%</td><td style="text-align:center">字符%</td></tr></tbody></table></div><ol><li><p>使用字符出对象的 fornat() 方法</p><p>​    字符串对象提供了 format() 方法用于进行字符串格式化。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.<span class="built_in">format</span>(args)</span><br></pre></td></tr></table></figure><p>​    其中：</p><ul><li>str：用于指定字符串的显示样式（即模板）</li></ul><p>​    下面重点介绍如何创建模板。在创建模板时，需要使用大括号和冒号指定占位符。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; [index] [ : [ [fill] align] [sign] [<span class="comment">#] [width] [.precision] [type] ] &#125;</span></span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li><p>index：可选参数，用于指定要设置格式对象在参数列表中的索引位置，索引值从 0 开始，默认根据值得先后顺序自动分配</p></li><li><p>fill：可选参数，用于指定空白处填充得字符</p></li><li><p>align：可选参数，用于指定对齐方式，需要配合 width 一起使用</p><ul><li>&lt;：表示内容左对齐</li><li>> ：表示内容右对齐</li><li>=：表示内容右对齐，将符号放在填充内容的最左侧，且只对数字类型有效</li><li>^：表示内容居中</li></ul></li><li><p>sign：可选参数，用于指定有无符号数</p><ul><li>+：表示正数加正号，负数加负号</li><li>-：表示正数不变，负数加负号</li><li>空格：表示正数加空格，负数加负号</li></ul></li><li><p>#：可选参数，对于二进制、八进制和十六进制，如果加上 # ，表示会显示 0b 0o 0x 前缀，否则不显示前缀</p></li><li><p>width：可选参数，用于指定所占宽度</p></li><li><p>.precision：可选参数，用于指定保留得小数位数</p></li><li><p>type：可选参数，用于指定类型</p></li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">格式化字符</th><th style="text-align:center">说明</th><th style="text-align:center">格式化字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">对字符串类型进行格式化</td><td style="text-align:center">b</td><td style="text-align:center">将十进制整数自动转换成二进制，再格式化</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">十进制整数</td><td style="text-align:center">0</td><td style="text-align:center">将十进制整数自动转换成八进制，再格式化</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">将十进制整数自动转换成对应的 Unicode 字符</td><td style="text-align:center">x或者X</td><td style="text-align:center">将十进制整数自动转换成十六进制，再格式化</td></tr><tr><td style="text-align:center">e或者E</td><td style="text-align:center">转换为科学计数法表示，再格式化</td><td style="text-align:center">f或者F</td><td style="text-align:center">转换为浮点数（默认小数点后保留6位），再格式化</td></tr><tr><td style="text-align:center">g或者G</td><td style="text-align:center">自动在科学计数法和浮点数中切换</td><td style="text-align:center">%</td><td style="text-align:center">显示百分比（默认显示小数点后6位）</td></tr></tbody></table></div><h1 id="第七章-正则表达式"><a href="#第七章-正则表达式" class="headerlink" title="第七章 正则表达式"></a>第七章 正则表达式</h1><h2 id="7-1-正则表达式语法"><a href="#7-1-正则表达式语法" class="headerlink" title="7.1 正则表达式语法"></a>7.1 正则表达式语法</h2><p>在处理字符串时，经常会有查找符合某些复杂规则的字符串的需求。正则表达式就是用于描述这些规则的工具。</p><h3 id="7-1-1-行定位符"><a href="#7-1-1-行定位符" class="headerlink" title="7.1.1 行定位符"></a>7.1.1 行定位符</h3><p>行定位符就是用来描述字符串的边界。“^”表示行的开始；“$”表示行的结尾。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^tm     <span class="comment">#从字符串的开头匹配tm</span></span><br><span class="line">tm$     <span class="comment">#从字符串的结尾匹配tm</span></span><br><span class="line">tm      <span class="comment">#从字符串的内部匹配tm</span></span><br></pre></td></tr></table></figure><h3 id="7-1-2-元字符"><a href="#7-1-2-元字符" class="headerlink" title="7.1.2 元字符"></a>7.1.2 元字符</h3><p>常用的元字符：</p><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母或数字或下划线或汉字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意的空白符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束</td></tr></tbody></table></div><h3 id="7-1-3-重复"><a href="#7-1-3-重复" class="headerlink" title="7.1.3 重复"></a>7.1.3 重复</h3><p>使用“\\w*”匹配任意数量的字母或数字。如果想匹配特定数量的字符，正则表达式为我们提供了限定符（指定数量的字符）来实现该功能。</p><p>常用的限定符如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">限定符</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">？</td><td style="text-align:center">匹配前面的字符零次或一次</td><td style="text-align:center">colou?r，该表达式可以匹配colour和color</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面的字符一次或多次</td><td style="text-align:center">go+gle，该表达式可以匹配gogle到go…gle</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面的字符零次或多次</td><td style="text-align:center">go*gle，该表达式可以匹配ggle到go…gle</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">匹配前面的字符 n 次</td><td style="text-align:center">go{2}gle，该表达式只匹配google</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">匹配前面的字符最少 n 次</td><td style="text-align:center">go{2,}，该表达式可以匹配google到goo…gle</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">匹配前面的字符最少 n 次，最多 m 次</td></tr></tbody></table></div><h3 id="7-1-4-字符类"><a href="#7-1-4-字符类" class="headerlink" title="7.1.4 字符类"></a>7.1.4 字符类</h3><p>正则表达式查找数字和字母是很简单的，因为已经有了对应这些字符集合的元字符（如：\d、\w），但是如果想要匹配没有预定义的元字符集合（比如：假名），应该怎么办？</p><p>很简单，只需要在方括号“[ ]”里列出它们就行。也可以指定一个字符范围，例如：[0-9a-zA-Z]，也完全等同于 \w （只考虑英文）</p><blockquote><p><strong>想要匹配给定字符串中的任意一个汉字，可以使用[\\u4e00-\\u9fa5]</strong></p></blockquote><h3 id="7-1-5-排除字符"><a href="#7-1-5-排除字符" class="headerlink" title="7.1.5 排除字符"></a>7.1.5 排除字符</h3><p>前面几节列出的是匹配符合指定字符集合的字符串。现在反过来，匹配不符合指定字符串集合的字符串。正则表达式提供了 “^” 字符。这里放到中括号中，表示排除的意思。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^a-zA-Z]</span><br></pre></td></tr></table></figure><p>该表达式用于匹配一个不是字母的字符。</p><h3 id="7-1-6-选择字符"><a href="#7-1-6-选择字符" class="headerlink" title="7.1.6 选择字符"></a>7.1.6 选择字符</h3><p>如何匹配身份证号码呢？身份证号码长度位 15 位或者 18 位。如果位 15 位，则全是数字；如果是 18 位，前 17 位位数字，最后一位是校验位，可能为数字或字符 X 。</p><p>在上面的描述中，包含者条件选逻辑，这就需要使用选择字符（“|”）来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ^ \d&#123;<span class="number">15</span>&#125; $ ) | ( ^ \d&#123;<span class="number">18</span>&#125; $ ) | ( (^ \d&#123;<span class="number">17</span>&#125; ) ( \d | X | x) $)</span><br></pre></td></tr></table></figure><h3 id="7-1-7-转义字符"><a href="#7-1-7-转义字符" class="headerlink" title="7.1.7 转义字符"></a>7.1.7 转义字符</h3><p>正则表达式中的转义字符与 Python 中的大同小异，都是将特殊字符变为普通字符。</p><h3 id="7-1-8-分组"><a href="#7-1-8-分组" class="headerlink" title="7.1.8 分组"></a>7.1.8 分组</h3><p>小括号字符的第一个作用就是可以改变限定符的作用范围。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( thir | four ) th</span><br></pre></td></tr></table></figure><p>小括号的第二个作用就是分组，也就是子表达式。</p><h3 id="7-1-9-在-Python-中使用正则表达式语法"><a href="#7-1-9-在-Python-中使用正则表达式语法" class="headerlink" title="7.1.9 在 Python 中使用正则表达式语法"></a>7.1.9 在 Python 中使用正则表达式语法</h3><p>在 Python 中使用正则表达式时，是将其作为模式字符串使用的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[^0-9a-z]&quot;</span></span><br><span class="line"><span class="string">&quot;\\bm\\w*\\b&quot;</span></span><br></pre></td></tr></table></figure><p>由于模式字符串可能包括大量的特殊字符和反斜杠，所以需要写为原生字符串，即在模式字符串前加 r 或 R 。例如，上面的模式字符串采用原生字符串表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r&quot;\bm\w*\b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="7-2-使用-re-模块实现正则表达式操作"><a href="#7-2-使用-re-模块实现正则表达式操作" class="headerlink" title="7.2 使用 re 模块实现正则表达式操作"></a>7.2 使用 re 模块实现正则表达式操作</h2><p>本章节将介绍如何在 Python 中使用正则表达式。</p><p>re 模块在使用时，需要应先导入 import 语句引入，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="7-2-1-匹配字符串"><a href="#7-2-1-匹配字符串" class="headerlink" title="7.2.1 匹配字符串"></a>7.2.1 匹配字符串</h3><p>匹配字符串可以使用 re 模块的 match() 、 search() 和 findall() 方法。</p><ol><li><p>使用 match() 方法进行匹配</p><p>​    match() 方法用于从字符串的开始处进行匹配，如果在起始位置匹配成功，则返回 Match 对象，否则返回 None 。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(pattern,string [,flags])</span><br></pre></td></tr></table></figure><p>​    参数说明如下：</p><ul><li><p>pattern：表示模式字符串，由要匹配的正则表达式转换而来</p></li><li><p>string：表示要匹配的字符串</p></li><li><p>flags：可选参数，表示标志位，用于控制匹配方式，如：是否区分大小写等。</p></li></ul></li><li><p>使用 search() 方法进行匹配</p><p>​    search() 方法用于在整个字符串中搜索第一个匹配的值，如果在起始位置匹配成功，则返回 Match 对象，否则返回 None 。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern,string [,flags])</span><br></pre></td></tr></table></figure><p>​    </p></li><li><p>使用 findall() 方法进行匹配</p><p>​    findall() 方法用于在整个字符串中搜索所有符合正则表达式的字符串，并以列表的形式返回。如果匹配成功，则返回包含匹配结果的列表，否则返回空列表。其语法格式如下;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern,string [,flags])</span><br></pre></td></tr></table></figure></li></ol><p>​    常用的标志如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">标志位</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">A 或 ASCII</td><td style="text-align:center">对于\\w \\W \\b \\B \\d \\D \\s \\S 只进行 ASCII 匹配（仅适用于 Python3）</td></tr><tr><td style="text-align:center">I 或者 IGNORECASE</td><td style="text-align:center">执行不区分字母大小写的匹配</td></tr><tr><td style="text-align:center">M 或者 MULTILING</td><td style="text-align:center">将^和$用于包括整个字符串的开始和结尾的每一行</td></tr><tr><td style="text-align:center">S 或者 DOTALL</td><td style="text-align:center">使用“.”字符匹配所有字符，包括换行符</td></tr><tr><td style="text-align:center">X 或者 VERBOSE</td><td style="text-align:center">忽略模式字符串中未转义的空格和注释</td></tr></tbody></table></div><h3 id="7-2-2-替换字符串"><a href="#7-2-2-替换字符串" class="headerlink" title="7.2.2 替换字符串"></a>7.2.2 替换字符串</h3><p>sub() 方法用于实现字符串的替换。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern,repl,string,count,flags)</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>pattern：表示模式字符串，由要匹配的正则表达式转换而来</li><li>repl：表示要替换的字符串</li><li>string：表示要被查找替换的原始字符串</li><li>count：可选参数，表示模式匹配后替换的最大次数，默认值为 0 ，表示替换所有的匹配</li><li>flags：可选参数，表示标志位，用于控制匹配方式，如：是否区分大小写等</li></ul><h3 id="7-2-3-使用正则表达式分割字符串"><a href="#7-2-3-使用正则表达式分割字符串" class="headerlink" title="7.2.3 使用正则表达式分割字符串"></a>7.2.3 使用正则表达式分割字符串</h3><p>split() 方法用于实现根据正则表达式分割字符串，并以列表对的形式返回。其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern,string [,maxsplit] [,flags])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>pattern：表示模式字符串，由要匹配的正则表达式转换而来</li><li>string：表示要被怕匹配的字符串</li><li>maxsplit：可选参数，表示最大的拆分次数</li><li>flags：可选参数，表示标志位，用于控制匹配方式，如：是否区分大小写等</li></ul><h1 id="第八章-函数"><a href="#第八章-函数" class="headerlink" title="第八章 函数"></a>第八章 函数</h1><h2 id="8-1-函数的创建和调用"><a href="#8-1-函数的创建和调用" class="headerlink" title="8.1 函数的创建和调用"></a>8.1 函数的创建和调用</h2><h3 id="8-1-1-创建一个函数"><a href="#8-1-1-创建一个函数" class="headerlink" title="8.1.1 创建一个函数"></a>8.1.1 创建一个函数</h3><p>创建函数也被称为定义函数。使用 def 关键字实现。具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[parameterlist]</span>):</span><br><span class="line">    [<span class="string">&quot;&quot;&quot;comments&quot;&quot;&quot;</span>]</span><br><span class="line">    [functionbody]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>functionname：函数名称，在调用函数时使用</li><li>parameterlist：可选参数，用于指定向函数中传递的参数。参数之间用逗号分隔</li><li>“””comments”””：可选参数，表示为函数指定的注释</li><li>functionbody：可选参数，用于指定函数体，即该函数被被调用之后，要执行的功能代码。</li></ul><blockquote><p>如果想定义一个什么也不做的空函数，可以使用pass语句作为占位符</p></blockquote><h3 id="8-1-2-调用函数"><a href="#8-1-2-调用函数" class="headerlink" title="8.1.2 调用函数"></a>8.1.2 调用函数</h3><p>调用函数也就是执行函数。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionname([parametersvalue])</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>functionname：函数名称，要调用的函数名称必须是已经创建好的</li><li>parametersvalue：可选参数，用于指定各个参数的值。参数之间用逗号隔开</li></ul><h2 id="8-2-参数传毒"><a href="#8-2-参数传毒" class="headerlink" title="8.2 参数传毒"></a>8.2 参数传毒</h2><h3 id="8-2-1-形式参数和实际参数"><a href="#8-2-1-形式参数和实际参数" class="headerlink" title="8.2.1 形式参数和实际参数"></a>8.2.1 形式参数和实际参数</h3><p>在使用函数时，经常会用到形式参数和实际参数。下面从两个角度了解这两种参数。</p><ol><li>通过作用理解<ul><li>形式参数：在定义函数时，函数名后面括号中的参数为<strong>形式参数</strong></li><li>实际参数：在调用一个函数时，函数名后面的括号中的参数为<strong>实际参数</strong></li></ul></li></ol><h3 id="8-2-2-位置参数"><a href="#8-2-2-位置参数" class="headerlink" title="8.2.2 位置参数"></a>8.2.2 位置参数</h3><p>位置参数也称必备参数，是必须按照正确的顺序传到函数中，即调用时的数量和位置必须和定义时是一样的。</p><ol><li><p>数量必须与定义时一致</p><p> ​    在调用函数时，指定的实际参数的数量必须与形式参数的数量一致，否则将会抛出 TypError 异常，提示缺少必要的位置参数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params"> a, b, c, d </span>) :</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nothing( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> )</span><br></pre></td></tr></table></figure><p> ​    上面代码运行的结果为：</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TypeError: <span class="title">nothing</span>() <span class="title">missing</span> 1 <span class="title">required</span> <span class="title">positional</span> <span class="title">argument</span>: &#x27;<span class="title">d</span>&#x27;</span></span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>位置必须与定义时一致</p><p> ​    在调用函数时，指定的实际参数的位置必须与形式参数的位置一致，否则将产生以下两种结果。</p><ul><li><p>抛出 TypError 异常</p><p>  ​    实际参数的类型与形式参数的类型不符，并且在函数中，这两种类型不能正常转换。</p></li><li><p>产生的结果与预期不符</p></li></ul></li></ol><h3 id="8-2-3-关键字参数"><a href="#8-2-3-关键字参数" class="headerlink" title="8.2.3 关键字参数"></a>8.2.3 关键字参数</h3><p>关键字参数是指使用形式参数的名字来确定输入的参数值。通过这种方式指定实际参数时，不再需要与形式参数的位置完全一致，只需要将参数名写正确即可。</p><p>例如，下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params"> a, b, c, d </span>) :</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nothing( a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">3</span> )</span><br></pre></td></tr></table></figure><h3 id="8-2-4-为参数设置默认值"><a href="#8-2-4-为参数设置默认值" class="headerlink" title="8.2.4 为参数设置默认值"></a>8.2.4 为参数设置默认值</h3><p>调用函数时，如果没有指定某个参数将抛出异常，为了解决这个问题，我们可以为参数设置默认值，即<strong>在定义函数时，直接指定形式参数的默认值</strong>。这样，当没有传入参数时，直接使用定义函数时设置的默认值。</p><p>定义带有默认值参数的函数的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params"> ... [parameter <span class="number">1</span> = value <span class="number">1</span> , .... ] </span>):</span><br><span class="line">    [functionbody]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>functionname：函数名称</li><li>parameter 1 = value 1：可选参数，用于指定向函数中传递的参数，并且为该参数设置默认值为 value 1</li><li>functionbody：可选参数，用于指定函数体</li></ul><blockquote><p>在定义函数时，指定的默认的形式参数必须在所有参数的后面，否则将会产生语法错误</p></blockquote><h3 id="8-2-5-可变参数"><a href="#8-2-5-可变参数" class="headerlink" title="8.2.5 可变参数"></a>8.2.5 可变参数</h3><p>在 Python 中，还可以定义可变参数。可变参数也称为不定长参数，即传入函数的实际参数可以是 0 个、1 个 到任意个。</p><ol><li><p>*parameter</p><p> ​    这种形式表示接收任意多个实际参数并将其放到一个元组中。例如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">yuanshen</span>(<span class="params"> *name </span>) :</span><br><span class="line">    string = <span class="string">&quot;原神有：&#123;&#125; 角色&quot;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> name :</span><br><span class="line">        <span class="built_in">print</span>( string.<span class="built_in">format</span>( item ), end=<span class="string">&quot;     &quot;</span> )</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&quot;&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yuanshen( <span class="string">&quot;胡桃&quot;</span> )</span><br><span class="line">yuanshen( <span class="string">&quot;胡桃&quot;</span>, <span class="string">&quot;雷电将军&quot;</span>, <span class="string">&quot;八重神子&quot;</span> )</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>**parameter</p><p> ​    这种形式表示接收任意多个类似关键字参数一样的显式赋值的实际参数，并将其放到一个字典中。</p></li></ol><h2 id="8-3-返回值"><a href="#8-3-返回值" class="headerlink" title="8.3 返回值"></a>8.3 返回值</h2><p>在 Python 中，可以在函数体内使用 return 语句为函数指定返回返回值，该返回值可以是任意类型，并且无论 return 语句出现在函数的什么位置，只要得到执行，会直接结束当前执行的函数。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [value]</span><br></pre></td></tr></table></figure><h2 id="8-4-变量的作用域"><a href="#8-4-变量的作用域" class="headerlink" title="8.4 变量的作用域"></a>8.4 变量的作用域</h2><p>变量的作用域是指程序代码能够访问该变量的区域，如果超出该区域，在访问时就会出现错误。在程序中，一般会根据变量的有效作用范围，将变量分为<strong>局部变量</strong>和<strong>全局变量</strong>。</p><h3 id="8-4-1-局部变量"><a href="#8-4-1-局部变量" class="headerlink" title="8.4.1 局部变量"></a>8.4.1 局部变量</h3><p>局部变量是指在函数内部定义并使用的变量，它只在函数内部有效。</p><h3 id="8-4-2-全局变量"><a href="#8-4-2-全局变量" class="headerlink" title="8.4.2 全局变量"></a>8.4.2 全局变量</h3><p>与局部变量对应，全局变量能够作用于函数内外的变量。</p><h2 id="8-5-匿名函数"><a href="#8-5-匿名函数" class="headerlink" title="8.5 匿名函数"></a>8.5 匿名函数</h2><p>匿名函数（lambda）是指没有名字的函数，应用在需要一个函数但又不想费神去命名这个函数的场合。通常情况下，这种函数只会使用一次。其语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">lambda</span> [arg1] : expression</span><br></pre></td></tr></table></figure><h1 id="第九章-面向对象程序设计"><a href="#第九章-面向对象程序设计" class="headerlink" title="第九章 面向对象程序设计"></a>第九章 面向对象程序设计</h1><h2 id="9-1-面向对象概述"><a href="#9-1-面向对象概述" class="headerlink" title="9.1 面向对象概述"></a>9.1 面向对象概述</h2><p>面向对象（Object Oriented）的英文缩写是OO，它是一种设计思想。从 20 世纪 60 年代提出面向对象的概念到现在，他已经发展成为一种比较成熟的编程思想，并且逐步成为目前软件开发领域的主流技术。</p><p>面向对象中的对象，通常是指客观世界中存在的对象，这个对象具有唯一性，对象之间各不相同，各有各的特点，每个对象都有自己的运动规律和内部状态；对象之间又是可以i相互联系、互相作用的。另外，对象也可以是一个抽象的事物。例如，可以从圆形、正方形、三角形等图形抽象出一个简单图形，简单图形就是一个对象，它有自己的属性和行为。</p><h3 id="9-1-1-对象"><a href="#9-1-1-对象" class="headerlink" title="9.1.1 对象"></a>9.1.1 对象</h3><p>对象，表示任意存在的食物。<strong>世间万物皆对象</strong>。</p><p>通常将对象划分为两个部分，即<strong>静态部分</strong>与<strong>动态部分</strong>。静态部分被称为“属性”，任何对象都具备自身的属性，如：人的性别；动态部分只对象的行为，即对象执行的动作，如：人可以行走。</p><h3 id="9-1-2-类"><a href="#9-1-2-类" class="headerlink" title="9.1.2 类"></a>9.1.2 类</h3><p>类是封装对象的属性和行为的载体，反过来说，具有统一属性的行为的一类实体被称为类。</p><h3 id="9-1-3-面向对象程序设计的特点"><a href="#9-1-3-面向对象程序设计的特点" class="headerlink" title="9.1.3 面向对象程序设计的特点"></a>9.1.3 面向对象程序设计的特点</h3><p>面向对象程序设计具有三大基本特征：<strong>封装</strong>、<strong>继承</strong>和<strong>多态</strong>。</p><ol><li><p>封装</p><p> ​    封装是面向对象编程的核心思想，将对象的属性和行为封装起来，而将对象的属性和行为封装起来的载体就是类。类通常对客户隐藏其实现细节，这就是封装的思想，简单来说，用户访问类的成员时，加以一定的访问限制。</p><p> ​    采用封装思想，保证了类内部数据结构的完整性，使用该类的用户不能直接看到类中的数据结构，而只能执行类允许公开的数据，这样就避免了外部对内部数据的影响，提高了程序的可维护性。</p></li><li><p>继承</p><p> ​    继承是实现重复利用的重要手段，子类通过继承父类的属性和行为的同时，又添加了子类特有的属性和行为。</p></li><li><p>多态</p><p> ​    将父类对象应用于子类的特征就是多态。</p></li></ol><h2 id="9-2-类的定义和使用"><a href="#9-2-类的定义和使用" class="headerlink" title="9.2 类的定义和使用"></a>9.2 类的定义和使用</h2><h3 id="9-2-1-定义类"><a href="#9-2-1-定义类" class="headerlink" title="9.2.1 定义类"></a>9.2.1 定义类</h3><p>在 Python 中，类的定义使用 class 关键字来实现，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;类的说明信息&quot;&quot;&quot;</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>ClassName：用于指定类名，一般采用 Pascal 命名法</li><li>BaseClass：继承的父类的类名，如果没有继承可不写（同时可以省略括号）</li><li>“””类的说明信息”””：用于指定类的文档字符串，定义该字符串后，在创建类时，输入类名和括号，将会显示该信息</li><li>statement：类体，包含该类的所有成员</li></ul><h3 id="9-2-2-创建类的实例"><a href="#9-2-2-创建类的实例" class="headerlink" title="9.2.2 创建类的实例"></a>9.2.2 创建类的实例</h3><p>定义完类后，并不会真正创建一个实例。创建类的实例的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(parameterlist)</span><br></pre></td></tr></table></figure><h3 id="9-2-3-创建-init-方法"><a href="#9-2-3-创建-init-方法" class="headerlink" title="9.2.3 创建__init__() 方法"></a>9.2.3 创建__init__() 方法</h3><p>在创建类后，通常会创建一个 __init__() 方法。该方法是一个特殊的方法，类似 Java 或 C# 的构造函数。每当创建一个类的实例化时， Python 都会自动执行它。__init__() 必须包含一个 self 参数，并且必须是第一个参数。self 参数是一个指向实例本身的引用，用于访问类中的属性和方法。在方法调用时，会自动传递实际参数 self 。因此，当__init__() 方法只有一个参数是，在创建类的实例时，就不需要指定实际参数了。</p><blockquote><p>__init__() 方法的名称中，开头结尾是<strong>双下划线</strong>，这是一种约定。</p></blockquote><h3 id="9-2-4-创建类的成员并访问"><a href="#9-2-4-创建类的成员并访问" class="headerlink" title="9.2.4 创建类的成员并访问"></a>9.2.4 创建类的成员并访问</h3><p>在 Python 中，类的成员有三种：类属性、实例属性、实例方法。</p><ol><li><p>创建实例方法并访问</p><p> ​    所谓实例方法，是在类中定义的函数。实例方法的第一个参数必须是 self ，并且必须包含一个 self 参数。创建实例方法的语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">self,parameterlist</span>):</span><br><span class="line">    block</span><br></pre></td></tr></table></figure><p> ​    参数说明如下：</p><ul><li>functionname：用于指定方法名，一般使用小写字母开头</li><li>self：必要参数，表示类的实例，其名称可以是 self 以外的单词，使用 self 只是一个习惯而已</li><li>parameterlist：用于指定除 self 参数以外的参数</li><li><p>block：方法体，实现的具体功能</p><p>实例方法创建完成后，可以通过类的实例名和（ . ）操作符进行访问。</p></li></ul></li><li><p>创建数据成员并访问</p><ul><li><p>类属性</p><p>  ​    类属性是指定义在类中，并且在类方法之外的属性。类属性可以在类的所有实例之间共享值，也就是在所有实例化的对象中公用。</p><p>  ​    类属性可以通过类名加 “ . ” 进行访问，也可以用实例名加 “ . ” 进行访问</p></li><li><p>实例属性</p><p>  ​    实例属性是指定义在类的方法中的属性，只作用于当前实例。对于实例属性，可以通过实例名称修改，但是并不会影响到另一个实例中的相应的实例属性。</p></li></ul></li><li><p>💰类属性和实例属性的区别</p><ol><li>在内存上，每个实例对象都会在内存中开辟一块空间，用于存储自身的实例属性，因此，实例属性之间不会相互影响；</li><li>类属性只会开辟一份内存空间，所有实例对象的类属性共用一块内存，因此，在实例 A 中修改类属性，会导致实例 B ….等所有当前存在的实例对象的类属性发生变化</li></ol></li></ol><h3 id="9-2-5-self-参数的详细解读"><a href="#9-2-5-self-参数的详细解读" class="headerlink" title="9.2.5 self 参数的详细解读"></a>9.2.5 self 参数的详细解读</h3><p>self 有两个基本作用：</p><ul><li>区别类属性和实例属性（类属性没有self），同时区分传入类的参数与实例属性</li><li>占位符，表示对当前操作对象的引用</li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> :</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self, a, b </span>) :</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line">zhangsan = Person( <span class="number">1</span>, <span class="number">2</span> )</span><br><span class="line">lisi = Person(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>( Person.a )</span><br><span class="line"><span class="built_in">print</span>( zhangsan.a )</span><br><span class="line"><span class="built_in">print</span>( zhangsan.b )</span><br></pre></td></tr></table></figure><ol><li><p>首先，传入类的构造方法的参数a、b，为了区分实例属性 a 和 b</p></li><li><p>当创建zhangsan时，self 将代表着zhangsan，类中的所有self 均可以被替换为zhangsan（前提是当前操作的是zhangsan这个实例对象）</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#伪代码</span></span><br><span class="line">zhangsan = Person(a = <span class="number">1</span>,b = <span class="number">2</span>):</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> zhangsan, a, b </span>) :</span><br><span class="line">        zhangsan.a = a</span><br><span class="line">        zhangsan.b = b</span><br></pre></td></tr></table></figure><p> ​    当创建lisi时，就是把 self 替换成 lisi 。</p><p> ​    由此可见，self 代表着对当前对象的引用。</p></li></ol><h3 id="9-2-6-访问限制"><a href="#9-2-6-访问限制" class="headerlink" title="9.2.6 访问限制"></a>9.2.6 访问限制</h3><p>在类的内部可以定义属性和方法，而在类的外部则可以直接调用属性或方法来操作数据，从而隐藏了类内部的复杂逻辑。但是，Python 并没有对属性和方法的访问权限进行限制。为了保护类内部的某些属性或方法不被外部访问，可以在属性或方法名前添加单下划线、双下划线或者首尾加双下划线，从而限制访问权限。</p><ul><li>_foo：以单下划线开头的表示 保护（protected）类型的成员，只允许该类本身和子类进行访问，但是不能使用 “ from module import * ” 语句导入</li><li>__foo：以双下划线开头的表示 private（私有）类型的成员，只允许定义该方法的类本身进行访问，而且也不能通过类的实例进行访问，但是可以通过 “ 类的实例名.类名.__xxx ” 进行访问</li><li>__foo__：首尾双下划线表示特殊定义方法，一般是系统定义名字，如：__init__ </li></ul><h2 id="9-3-属性"><a href="#9-3-属性" class="headerlink" title="9.3 属性"></a>9.3 属性</h2><p>本章节介绍的属性与前面的类属性和实例属性不同。本章节要介绍的属性是一种特殊的属性，访问它时将计算它的值。</p><h3 id="9-3-1-创建用于计算的属性"><a href="#9-3-1-创建用于计算的属性" class="headerlink" title="9.3.1 创建用于计算的属性"></a>9.3.1 创建用于计算的属性</h3><p>在 Python 中，可以通过 @property（修饰器）将一个方法转换为属性，从而实现用于计算的属性。将方法转换为属性后，可直接通过方法名来访问方法，而不需要在添加一对小括号，这样可以让代码更加简洁。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methodname</span>(<span class="params">self</span>):</span><br><span class="line">        block</span><br><span class="line">    </span><br><span class="line">tmp = ClassName()</span><br><span class="line"><span class="built_in">print</span>(tmp.methodname)</span><br></pre></td></tr></table></figure><h3 id="9-3-2-为属性添加安全保护机制"><a href="#9-3-2-为属性添加安全保护机制" class="headerlink" title="9.3.2 为属性添加安全保护机制"></a>9.3.2 为属性添加安全保护机制</h3><p>在 Python 中，默认情况下，创建的类属性或者实例属性可以在类体外进行修改，如果想要限制其不能在类体外修改，可以将其设置为私有，但是设置为私有后，在类体外也不能获取它的值。如果想要创建一个可以读取，但是不能修改的属性，那么可以使用 @property（修饰器）实现只读属性。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">YuanShen</span> :</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>) :</span><br><span class="line">        self.__company = <span class="string">&quot;米哈游&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">company</span>(<span class="params"> self </span>) :</span><br><span class="line">        <span class="keyword">return</span> self.__company</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">game = YuanShen()</span><br><span class="line"><span class="built_in">print</span>( game.company )</span><br></pre></td></tr></table></figure><h2 id="9-4-继承"><a href="#9-4-继承" class="headerlink" title="9.4 继承"></a>9.4 继承</h2><p>在编写类时，并不是每次都要从空白开始。当要编写的类和另一个已经存在的类之间存在一定的继承关系，就可以通过继承来达到代码重用的目的，提高开发效率。</p><h3 id="9-4-1-继承的基本语法"><a href="#9-4-1-继承的基本语法" class="headerlink" title="9.4.1 继承的基本语法"></a>9.4.1 继承的基本语法</h3><p>继承是面向对象编程最重要的特性之一。</p><p>具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>(<span class="title class_ inherited__">baseclasslist</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;类的帮助信息&quot;&quot;&quot;</span></span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>baseclasslist：用于指定继承的父类，可以有多个。如果不指定，将使用所有Python对象的根类 Object </li></ul><h3 id="9-4-2-方法重写"><a href="#9-4-2-方法重写" class="headerlink" title="9.4.2 方法重写"></a>9.4.2 方法重写</h3><p>父类的成员都会被子类继承（除了私有成员），当父类中的某个方法不完全适用于子类时，就需要在子类中重新定义这个方法，这和 Java 语言中的方法重写是一样的。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> :</span><br><span class="line">    color = <span class="string">&quot;绿色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;水果的颜色是：&quot;</span>, color, <span class="string">&quot;的！&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>( <span class="title class_ inherited__">Fruit</span> ) :</span><br><span class="line">    color = <span class="string">&quot;红色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( color, <span class="string">&quot;是水果的颜色&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apple = Apple()</span><br><span class="line">apple.harvest( <span class="string">&quot;白色&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="9-4-3-子类调用父类的-init-方法"><a href="#9-4-3-子类调用父类的-init-方法" class="headerlink" title="9.4.3 子类调用父类的__init__() 方法"></a>9.4.3 子类调用父类的__init__() 方法</h3><p>在子类中定义__init__() 方法时，不会自动调用父类的__init__() 方法。因此，要让子类调用父类的__init__() 方法进行必要的初始化，需要在子类的__init__() 方法里面使用 super() 函数调用父类的__init__() 方法。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> :</span><br><span class="line">    color = <span class="string">&quot;绿色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;我是父类&quot;</span> )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;水果的颜色是：&quot;</span>, color, <span class="string">&quot;的！&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>( <span class="title class_ inherited__">Fruit</span> ) :</span><br><span class="line">    color = <span class="string">&quot;红色&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self </span>) :</span><br><span class="line">        <span class="built_in">print</span>( <span class="string">&quot;我是子类&quot;</span> )</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">harvest</span>(<span class="params"> self, color </span>) :</span><br><span class="line">        <span class="built_in">print</span>( color, <span class="string">&quot;是水果的颜色&quot;</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apple = Apple()</span><br></pre></td></tr></table></figure><h1 id="第十章-模块"><a href="#第十章-模块" class="headerlink" title="第十章 模块"></a>第十章 模块</h1><h2 id="10-1-模块概述"><a href="#10-1-模块概述" class="headerlink" title="10.1 模块概述"></a>10.1 模块概述</h2><p>在 Python 中，一个扩展名为 .py 的文件就称为一个模块。通常情况下，我们把能够实现某一特定功能的代码放置在一个文件中作为一个模块，从而方便其他程序和脚本导入并使用。另外，使用模块也可以避免函数名和变量名冲突。</p><h2 id="10-2-自定义模块"><a href="#10-2-自定义模块" class="headerlink" title="10.2 自定义模块"></a>10.2 自定义模块</h2><p>在 Python 中，自定义模块有两个作用，意识规范代码，让代码更易阅读，另一个是方便其他程序使用已经编写好的代码，提高开发效率。自定义模块的主要分为两部分，一部分是创建模块，另一部分是导入模块。</p><h3 id="10-2-1-创建模块"><a href="#10-2-1-创建模块" class="headerlink" title="10.2.1 创建模块"></a>10.2.1 创建模块</h3><p>创建模块可以将模块中的相关代码编写在一个单独的文件中，并且将该文件命名为“ 模块名.py ” 的形式。</p><blockquote><p>创建模块时，设置的模块名不能是 Python 自带的标准模块名称。模块文件的扩展名必须是 .py</p></blockquote><h3 id="10-2-2-导入模块"><a href="#10-2-2-导入模块" class="headerlink" title="10.2.2 导入模块"></a>10.2.2 导入模块</h3><p>创建模块后，就可以在其他程序中使用该模块。使用模块需要先以模块的形式加载模块中的代码，这可以使用import语句实现。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> modulename [<span class="keyword">as</span> alias]</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>modulename：要导入的模块的名称</li><li>as alias：给模块起的别名，通过别名也可以使用模块</li></ul><p>使用 import 语句还可以一次性导入多个模块，在导入多个模块时，模块名之间用逗号隔开。</p><p>在使用 import 语句导入模块时，每执行一条 import 语句，都会创建一个新的命名空间（namespace），并且在该命名空间中执行与 .py 文件相关的所有语句。所以，在执行时，需要在具体的变量、函数和类名前加上 “模块名” 前缀。如果不想再每次导入模块时都创建一个新的命名空间，而是将具体的定义导入当前的命名空间中，这时可以使用 from…import 语句。具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> member</span><br><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>modulename：要导入的模块名称</li><li>member：用于指定导入的变量、函数或类等</li><li>使用星号✳：表示导入模块里面的全部内容</li></ul><blockquote><p>使用 import 导入模块时，模块名是区分大小写的</p></blockquote><h3 id="10-2-3-模块搜索目录"><a href="#10-2-3-模块搜索目录" class="headerlink" title="10.2.3 模块搜索目录"></a>10.2.3 模块搜索目录</h3><p>当使用 import 语句导入模块时，默认情况下，会按照以下顺序进行查找：</p><ol><li>当前执行的 Python 脚本所在目录</li><li>到 PYTHONPATH（环境变量）下的每个目录中查找</li><li>到 Python 的默认安装位置目录下查找</li></ol><p>以上各个目录的具体位置保存在标准模块 sys 的 sys.path 变量中。可以通过下面代码查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( sys.path )</span><br></pre></td></tr></table></figure><p>如果导入的模块不在 上述代码运行结果的目录 中，那么在导入模块是将会抛出异常。这时，我们可以通过以下 3 中方法添加指定的目录到 sys.path 中。</p><ol><li><p>临时添加</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;E:/xx/xx&quot;</span></span><br><span class="line">sys.path.append( path )</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>增加 .pth 文件（🎆推荐用法）</p><p> 在 Python 安装目录下的 Lib\\site-package 子目录中，创建一个扩展名为 .pth 的文件，文件名任意。在该文件中添加要导入的模块所在目录。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#.pth 文件</span></span><br><span class="line">E:/xx/xx</span><br></pre></td></tr></table></figure><p> ​    </p><blockquote><p>创建 .pth 文件后，需要重新打开要执行导入模块的 Python 文件，否则新添加的目录不起作用。</p></blockquote><p> ​    </p></li><li><p>在 PYTHONPATH 环境变量中添加</p></li></ol><h2 id="10-3-Python-中的包"><a href="#10-3-Python-中的包" class="headerlink" title="10.3 Python 中的包"></a>10.3 Python 中的包</h2><p>使用模块可以避免函数名和变量名重名引发为错误。那么，模块名重复则么办呢？在 Python 中提出了包（package）的概念。包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下。这样，既可以起到规范代码的作用，又可以避免模块名重复引起的错误。</p><h3 id="10-3-1-Python-程序的包的结构"><a href="#10-3-1-Python-程序的包的结构" class="headerlink" title="10.3.1 Python 程序的包的结构"></a>10.3.1 Python 程序的包的结构</h3><h3 id="10-3-2-创建和使用包"><a href="#10-3-2-创建和使用包" class="headerlink" title="10.3.2 创建和使用包"></a>10.3.2 创建和使用包</h3><ol><li><p>创建包</p><p> ​    创建包实际上就是创建一个文件夹，并且在该文件夹中创建一个名为“__init__.py” 的Python 文件。在__init__.py文件中，可以不编写任何代码，也可以编写一些 Python 代码。在__init__.py文件中所编写的代码，在导入包时会自动执行。</p><p> ​    </p></li><li><p>使用包</p><ul><li>使用 “import + 完整包名 + 模块名” </li><li>使用 “from + 完整包名 import 模块名” </li><li>使用 “import + 完整包名 + 模块名 + import + 定义名” </li></ul></li></ol><h3 id="10-3-4-以主程序的形式执行"><a href="#10-3-4-以主程序的形式执行" class="headerlink" title="10.3.4 以主程序的形式执行"></a>10.3.4 以主程序的形式执行</h3><p>在 Python 中，执行的脚本文件在导入模块时，会执行模块里面的代码，如果模块里面存在测试代码，如：print() 等，同样也会执行该函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;米哈游&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是测试代码！&quot;</span>)</span><br></pre></td></tr></table></figure><p>这显然不是我们想看到的，我们希望导入的模块的函数不会自动执行，而是我们手动去调用。因此，在模块里面，添加下列代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;米哈游&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是测试代码！&quot;</span>)</span><br></pre></td></tr></table></figure><p>将模块里面的测试代码放入“if __name__ == “__main__“:” 里面。当模块里面的代码以主程序运行时，就会执行测试代码，而模块以库导入其他主程序时，就不会执行测试代码。</p><h2 id="10-4-引用其他模块"><a href="#10-4-引用其他模块" class="headerlink" title="10.4 引用其他模块"></a>10.4 引用其他模块</h2><p>在 Python 中，除了自定义的模块外，还可以引用其他模块，主要包括标准模块和第三方模块。</p><h3 id="10-4-1-导入和使用标准模块"><a href="#10-4-1-导入和使用标准模块" class="headerlink" title="10.4.1 导入和使用标准模块"></a>10.4.1 导入和使用标准模块</h3><p>Python 中提供了 200 多个内置的标准模块，涵盖了 Python 运行时服务、文字模式匹配、操作系统接口、数学运算、对象永久保存、网络和 Internet 脚本和GUI构建等方面。可以在 Python 的<a href="https://docs.python.org/">帮助文档</a>查看。</p><h3 id="10-4-2-第三方模块的下载与安装"><a href="#10-4-2-第三方模块的下载与安装" class="headerlink" title="10.4.2 第三方模块的下载与安装"></a>10.4.2 第三方模块的下载与安装</h3><p>在进行 Python 程序开发时，除了可以使用 Python 内置的标准模块，还有很多第三方模块可以让我们使用。对于这些第三方模块，可在 Python 的官网推出的<a href="https://pypi.org/">皮皮 ·Python 包索引)</a>中可以让我们找到。</p><ol><li><p>安装第三方模块</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install modulename</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>卸载第三方模块</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall modulename</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>查看已经安装的第三方模块</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p> ​    </p></li></ol><h1 id="第十一章-异常处理"><a href="#第十一章-异常处理" class="headerlink" title="第十一章 异常处理"></a>第十一章 异常处理</h1><h2 id="11-1-异常概述"><a href="#11-1-异常概述" class="headerlink" title="11.1 异常概述"></a>11.1 异常概述</h2><p>在程序运行过程中，经常会遇到各种错误，这些错误统称为异常。</p><div class="table-container"><table><thead><tr><th style="text-align:center">异常</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">NameError</td><td style="text-align:center">尝试访问一个没有声明变量引发的错误</td></tr><tr><td style="text-align:center">IndexError</td><td style="text-align:center">索引超出序列范围引发的错误</td></tr><tr><td style="text-align:center">IndentionError</td><td style="text-align:center">缩进错误</td></tr><tr><td style="text-align:center">ValueError</td><td style="text-align:center">传入的值错误</td></tr><tr><td style="text-align:center">KeyError</td><td style="text-align:center">请求一个不存在的字典关键字引发的错误</td></tr><tr><td style="text-align:center">IOError</td><td style="text-align:center">输入输出错误</td></tr><tr><td style="text-align:center">ImpotyError</td><td style="text-align:center">当 import 语句无法找到模块或 from 无法在模块中找到相应的名称时引发的错误</td></tr><tr><td style="text-align:center">AttributeError</td><td style="text-align:center">尝试访问未知的对象属性引发的错误</td></tr><tr><td style="text-align:center">TypeError</td><td style="text-align:center">类型不合适引发的错误</td></tr><tr><td style="text-align:center">MemoryError</td><td style="text-align:center">内存不足</td></tr><tr><td style="text-align:center">ZeroDivisionError</td><td style="text-align:center">除数为 0 引发的错误</td></tr></tbody></table></div><blockquote><p>上述所示的异常，了解即可</p></blockquote><h2 id="11-2-异常处理语句"><a href="#11-2-异常处理语句" class="headerlink" title="11.2 异常处理语句"></a>11.2 异常处理语句</h2><h3 id="11-2-1-try…except-语句"><a href="#11-2-1-try…except-语句" class="headerlink" title="11.2.1 try…except 语句"></a>11.2.1 try…except 语句</h3><p>具体语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    block1</span><br><span class="line"><span class="keyword">except</span> [ExceptionName [<span class="keyword">as</span> alias]]:</span><br><span class="line">    block2</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>block1：表示可能出现的错误的代码块</li><li>ExceptionName [as alias]：可选参数，用于指定要捕获的异常</li><li>block2：表示进行异常处理的代码块</li></ul><blockquote><p>使用 try…except 语句捕获异常后，当程序出现错误时，程序会继续执行</p></blockquote><h3 id="11-2-2-try…except…else-语句"><a href="#11-2-2-try…except…else-语句" class="headerlink" title="11.2.2  try…except…else 语句"></a>11.2.2  try…except…else 语句</h3><p>与 try…except 不同的时，在 try 语句没有发生异常的时候，就会执行 else 中的代码</p><h3 id="11-2-3-try…except…finally-语句"><a href="#11-2-3-try…except…finally-语句" class="headerlink" title="11.2.3  try…except…finally 语句"></a>11.2.3  try…except…finally 语句</h3><p>完整的异常处理应该包含 finally 代码块，通常情况下，无论程序中有无异常产生， finally 代码块中的代码总会执行。</p><h3 id="11-2-4-使用-raise-语句抛出异常"><a href="#11-2-4-使用-raise-语句抛出异常" class="headerlink" title="11.2.4 使用 raise 语句抛出异常"></a>11.2.4 使用 raise 语句抛出异常</h3><p>如果某个函数或方法可能会产生异常，但不想在当前函数或方法中处理这个异常，则可以使用 raise 语句在函数或方法中抛出异常。raise 语句的基本格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raisl [ExceptionName[(reason)]]</span><br></pre></td></tr></table></figure><h2 id="11-3-程序调试"><a href="#11-3-程序调试" class="headerlink" title="11.3 程序调试"></a>11.3 程序调试</h2><h1 id="第十二章-文件及目录操作"><a href="#第十二章-文件及目录操作" class="headerlink" title="第十二章 文件及目录操作"></a>第十二章 文件及目录操作</h1><h2 id="12-1-基本文件操作"><a href="#12-1-基本文件操作" class="headerlink" title="12.1 基本文件操作"></a>12.1 基本文件操作</h2><p>在 Python 中，内置了文件（File）对象。在使用文件对象时，首先需要通过内置的 open() 方法创建一个文件对象，然后通过该对象提供的一些方法进行一些基本文件操作。</p><h3 id="12-1-1-创建和打开文件"><a href="#12-1-1-创建和打开文件" class="headerlink" title="12.1.1 创建和打开文件"></a>12.1.1 创建和打开文件</h3><p>在 Python 中，想要操作文件需要首先创建或打开指定文件并创建文件对象，这样可以使用内置的 open() 方法实现。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(filename [, mode [, buffering]] )</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>file：被创建的文件对象</li><li>filename：要创建或打开的文件的名称，需要使用单引号或者双引号括起来。如果打开的文件和当前文件在同一目录下，直接使用文件名即可，否则需要制定完整的路径</li><li>mode：可选参数，用于指定文件的打开模式</li><li>buffering：可选参数，用于指定读写文件的缓冲模式，值为 0 表示不缓存；值为 1 表示缓存；如果大于 1 ，则表示缓冲区的大小。默认为缓存模式</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">打开模式</th><th style="text-align:left">说明</th><th style="text-align:center">注意</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:left">以只读模式打开文件。文件的指针将会放在文件的开头</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">rb</td><td style="text-align:left">以二进制格式打开文件，并且采用只读模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">r+</td><td style="text-align:left">打开文件后，可以读取文件内容，也可以写入新的内容覆盖原有内容（从文件开头进行覆盖）</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">rb+</td><td style="text-align:left">以二进制格式打开文件，并且采用读写模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件必须存在</td></tr><tr><td style="text-align:center">w</td><td style="text-align:left">以只写模式打开文件</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">wb</td><td style="text-align:left">以二进制格式打开文件，并且采用只写模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">w+</td><td style="text-align:left">打开文件后，先清空原有内容，使其变为一个空文件，对这个空文件有读写权限</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">wb+</td><td style="text-align:left">以二进制格式打开文件，并且采用读写模式。文件的指针将会在文件的开头。一般用于非文本文件，如：图片、声音等</td><td style="text-align:center">文件存在，则将其覆盖；反之，则创建新文件</td></tr><tr><td style="text-align:center">a</td><td style="text-align:left">以追加模式打开一个文件，并且采用追加模式。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ab</td><td style="text-align:left">以二进制模式打开一个文件，并且采用追加模式。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">a+</td><td style="text-align:left">以读写模式打开一个文件。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ab+</td><td style="text-align:left">以二进制模式打开一个文件，并且采用追加模式。如果该文件已经存在，文件指针将放在文件的末尾（即新内容会被写入到已有内容之后），否则，创建新文件用于读写</td></tr></tbody></table></div><h3 id="12-1-2-关闭文件"><a href="#12-1-2-关闭文件" class="headerlink" title="12.1.2 关闭文件"></a>12.1.2 关闭文件</h3><p> 打开文件后，需要及时关闭，以免对文件造成不必要的破坏。关闭文件可以使用 close() 方法实现。语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>file：为打开的文件对象</li></ul><h3 id="12-1-3-打开文件时使用-with-语句"><a href="#12-1-3-打开文件时使用-with-语句" class="headerlink" title="12.1.3 打开文件时使用 with 语句"></a>12.1.3 打开文件时使用 with 语句</h3><p>打开文件后，要将其及时关闭，，如果忘记关闭，可能会出现意想不到的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expression <span class="keyword">as</span> target:</span><br><span class="line">    <span class="keyword">with</span> - body</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><ul><li>expression：用于指定一个表达式</li><li>target：用以指定一个变量，并且将 expression 结果保存到该变量中</li><li>with - body：用于指定 with 语句体，其中可以是执行 with 语句后相关的一些操作语句。</li></ul><h3 id="12-1-4-写入文件"><a href="#12-1-4-写入文件" class="headerlink" title="12.1.4 写入文件"></a>12.1.4 写入文件</h3><p>前面我们学习了如何创建文件，但是该文件没有任何内容，它的大小是 0 KB。Python 的文件对象提供了 write() 方法，可以向该文件中写入内容。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.write(string)</span><br></pre></td></tr></table></figure><blockquote><p>在我们写入文件后，写入的内容会先保存在缓冲区，只有当调用了 flush() 或 close() 方法后，操作系统才会把缓冲区的内容写入磁盘。</p></blockquote><h3 id="12-1-5-读取文件"><a href="#12-1-5-读取文件" class="headerlink" title="12.1.5 读取文件"></a>12.1.5 读取文件</h3><ol><li><p>读取指定字符</p><p> ​    文件对象提供了 read() 方法，读取指定个数的字符。语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.read([size])</span><br></pre></td></tr></table></figure><p> ​    其中：</p><ul><li>file：为打开的文件对象</li><li><p>size：为可选参数，用于指定要读取的字符个数，默认省略为读取所有内容</p><p>​    </p><p>使用上述方法读取文件时，是从开头开始读取的。如果想要读取部分内容，可以先使用文件对象的seek() 方法将文件指针移动到新位置，然后再用 read() 方法读取。语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.seek( offset [, whence ] )</span><br></pre></td></tr></table></figure><p>​    参数说明如下;</p></li><li><p>file：表示已经打开的文件</p></li><li>offset：用于指定移动的字符个数，其具体位置与 whence 有关</li><li>whence：可选参数，用于指定从什么位置开始计算。值为 0 表示从文件头部开始计算，1 表示从文件当前位置开始计算，2 表示从文件尾部开始计算，默认省略为 0 </li></ul></li><li><p>读取一行</p><p> ​    在使用 read() 方法读取文件时，如果文件很大，一次读取全部内容到内存，容易造成内存不足，所以通常会采用逐行读取。语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filereadline()</span><br></pre></td></tr></table></figure><p> ​    </p></li><li><p>读取全部行</p><p> ​    读取全部行的作用与 read() 方法一样，只不过读取全部行时，返回的是一个字符串列表，每个元素为文件的一行内容。其语法格式如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.readlines()</span><br></pre></td></tr></table></figure><p> ​    </p></li></ol><h2 id="12-2-目录操作"><a href="#12-2-目录操作" class="headerlink" title="12.2 目录操作"></a>12.2 目录操作</h2><h3 id="12-2-1-os-和-os-path-模块"><a href="#12-2-1-os-和-os-path-模块" class="headerlink" title="12.2.1 os 和 os.path 模块"></a>12.2.1 os 和 os.path 模块</h3><p>在 Python 中，内置了 os 模块以及其子模块 os.path 用于对目录或文件进行操作。在使用 os 模块或者 os.path 模块时，需要用 import 语句进行导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br></pre></td></tr></table></figure><p>os 模块常用的变量有：</p><ul><li>name：用于获取操作系统的类型<ul><li>输出为 nt ，则代表为 Windows 操作系统</li><li>输出为 posix ，则表示为 Linux</li></ul></li><li>linesep：用于获取当前操作系统上的换行符</li><li>sep：用于获取当前操作系统所使用的路径分隔符</li></ul><p>os 模块提供的一些操作目录的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">getcwd()</td><td>返回当前的工作目录</td></tr><tr><td style="text-align:center">listdir(path)</td><td>返回指定路径下的文件和目录信息</td></tr><tr><td style="text-align:center">mkdir(path[,mode])</td><td>创建目录</td></tr><tr><td style="text-align:center">makedirs(path1/path2/path3…[,mode])</td><td>创建多级目录</td></tr><tr><td style="text-align:center">rmdir(path)</td><td>删除目录</td></tr><tr><td style="text-align:center">remove(path1/path2)</td><td>删除多级目录</td></tr><tr><td style="text-align:center">chdir(path)</td><td>把 path 设置为当前工作目录</td></tr><tr><td style="text-align:center">walk(top[,topdown[,onerror]])</td><td>遍历目录树，该方法返回一个元组，包括所有的路径、所有目录列表和文件列表三个元素</td></tr></tbody></table></div><p>os.path 模块提供一些操作目录的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">abspath(path)</td><td>用于获取文件或目录的绝对路径</td></tr><tr><td style="text-align:center">exists(path)</td><td>用于判断目录或文件是否存在，如果存在则返回 Ture；反之，返回 False</td></tr><tr><td style="text-align:center">join(path,name)</td><td>将目录与目录或文件名拼接起来</td></tr><tr><td style="text-align:center">splitext()</td><td>分离文件名或扩展名</td></tr><tr><td style="text-align:center">basename(path)</td><td>从一个目录中提取文件名</td></tr><tr><td style="text-align:center">dirname(path)</td><td>从一个路径中提取文件，不包括文件名</td></tr><tr><td style="text-align:center">isdir(path)</td><td>用于判断是否为有效路径</td></tr></tbody></table></div><h3 id="12-2-2-路径"><a href="#12-2-2-路径" class="headerlink" title="12.2.2 路径"></a>12.2.2 路径</h3><ol><li><p>相对路径</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.getcwd()) <span class="comment"># 输出当前目录</span></span><br></pre></td></tr></table></figure></li><li><p>绝对路径</p><p> ​    获取某文件的绝对路径：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.abspath(path)</span><br></pre></td></tr></table></figure></li><li><p>拼接路径</p><p> 如果想要将两个或者多个路径拼接在一起，组成一个新的路径，可以使用 <code>os.path</code> 模块的 <code>join()</code> 函数实现。具体语法如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.join(path1,path2,path3...)</span><br></pre></td></tr></table></figure></li></ol><h3 id="12-2-3-判断目录是否存在"><a href="#12-2-3-判断目录是否存在" class="headerlink" title="12.2.3 判断目录是否存在"></a>12.2.3 判断目录是否存在</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(path)</span><br></pre></td></tr></table></figure><h3 id="12-2-4-创建目录"><a href="#12-2-4-创建目录" class="headerlink" title="12.2.4 创建目录"></a>12.2.4 创建目录</h3><ol><li><p>创建一级目录</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(path,mode=<span class="number">0o777</span>)</span><br></pre></td></tr></table></figure><p> ​    参数说明：</p><ul><li>path：用于指定要创建的目录，可以使用绝对路径或相对路径</li><li>mode：用于指定数值模式，默认为0777。该参数在非 <code>UNIX</code> 系统上无效</li></ul></li><li><p>创建多级目录</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(name,mode=<span class="number">0o777</span>)</span><br></pre></td></tr></table></figure><p> ​    参数说明：</p><ul><li>name：用于指定要创建的目录，可以使用绝对路径或相对路径</li><li>mode：用于指定数值模式，默认为0777。该参数在非 <code>UNIX</code> 系统上无效</li></ul></li></ol><h3 id="12-2-5-删除目录"><a href="#12-2-5-删除目录" class="headerlink" title="12.2.5 删除目录"></a>12.2.5 删除目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rmdir(path)</span><br></pre></td></tr></table></figure><h3 id="12-2-6-遍历目录"><a href="#12-2-6-遍历目录" class="headerlink" title="12.2.6 遍历目录"></a>12.2.6 遍历目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.walk(top,topdown,oneerro,followlinks)</span><br></pre></td></tr></table></figure><h2 id="12-3-高级文件操作"><a href="#12-3-高级文件操作" class="headerlink" title="12.3 高级文件操作"></a>12.3 高级文件操作</h2><p>Python 内置的 os 模块除了可以对目录进行操作，还可以对文件进行一些高级操作，具体函数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">access(path,accessmode)</td><td>获取对文件是否有指定的访问权限</td></tr><tr><td style="text-align:center">chmod(path,mode)</td><td>修改 path 指定文件的访问权限</td></tr><tr><td style="text-align:center">remove(path)</td><td>删除 path 指定的文件路径</td></tr><tr><td style="text-align:center">rename(src,dst)</td><td>将文件或目录src重命名为dst</td></tr><tr><td style="text-align:center">stat(path)</td><td>返回path指定的文件信息</td></tr><tr><td style="text-align:center">startfile(path[,operation])</td><td>使用关联的应用程序打开 path 指定的文件</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 程序设计 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Web开发 </tag>
            
            <tag> Python </tag>
            
            <tag> 服务器 </tag>
            
            <tag> Django </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 数据可视化 </tag>
            
            <tag> 自动化运维开发 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
